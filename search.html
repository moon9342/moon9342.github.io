<!DOCTYPE html>
<html>
<head>

    <!-- Document Settings -->
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />

    <!-- Base Meta -->
    <!-- dynamically fixing the title for tag/author pages -->



    <title>Search Result</title>
    <meta name="HandheldFriendly" content="True" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />


    <!-- jQuery + Fitvids, which makes all video embeds responsive -->
    <script
            src="https://code.jquery.com/jquery-3.2.1.min.js"
            integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4="
            crossorigin="anonymous">
    </script>

    <!-- 웹 폰트 설정 -->
    <link rel="stylesheet" href="https://fonts.googleapis.com/earlyaccess/nanumgothic.css">

    <!-- Font Awesome CDN 설정 => 느림.. -->
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css">

    <!-- custom.css -->
    <link rel="stylesheet" href="/assets/built/custom.css">

    <!-- syntax.css -->
    <link rel="stylesheet" href="/assets/built/syntax.css">

    <!-- gist.css -->
    <link rel="stylesheet" href="/assets/built/better-gist-styles.css">

    <!-- Styles'n'Scripts -->
    <link rel="stylesheet" type="text/css" href="/assets/built/screen.css" />
    <link rel="stylesheet" type="text/css" href="/assets/built/screen.edited.css" />

    <!-- highlight.js -->
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.3.0/styles/default.min.css">
    <style>.hljs { background: none; }</style>

    <!--Dl Menu-->
    <script src="/assets/js/modernizr.custom.js"></script>
    <script src="/assets/js/jquery.dlmenu.js"></script>
    <script src="/assets/js/menu_main.js"></script>

    <!-- Google AdSense -->
    <script data-ad-client="ca-pub-2687024418565562" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

    <!-- This tag outputs SEO meta+structured data and other important settings -->
    <meta name="description" content="얼큰우동TV, 쉽게배우는 IT(Programming,Machine Learning,금융)" />
    <link rel="shortcut icon" href="http://localhost:4000/assets/built/images/favicon.jpg" type="image/png" />
    <link rel="canonical" href="http://localhost:4000/search" />
    <meta name="referrer" content="no-referrer-when-downgrade" />

     <!--title below is coming from _includes/dynamic_title-->
    <meta property="og:site_name" content="IT Technical Training" />
    <meta property="og:type" content="website" />
    <meta property="og:title" content="Search Result" />
    <meta property="og:description" content="얼큰우동TV, 쉽게배우는 IT(Programming,Machine Learning,금융)" />
    <meta property="og:url" content="http://localhost:4000/search" />
    <meta property="og:image" content="http://localhost:4000/assets/built/images/blog-cover2.png" />
    <meta property="article:publisher" content="https://www.facebook.com/" />
    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:title" content="Search Result" />
    <meta name="twitter:description" content="얼큰우동TV, 쉽게배우는 IT(Programming,Machine Learning,금융)" />
    <meta name="twitter:url" content="http://localhost:4000/" />
    <meta name="twitter:image" content="http://localhost:4000/assets/built/images/blog-cover2.png" />
    <meta name="twitter:label1" content="Written by" />
    <meta name="twitter:data1" content="IT Technical Training" />
    <meta name="twitter:site" content="@" />
    <meta name="twitter:creator" content="@" />
    <meta property="og:image:width" content="2000" />
    <meta property="og:image:height" content="666" />

    <script type="application/ld+json">
{
    "@context": "https://schema.org",
    "@type": "Website",
    "publisher": {
        "@type": "Organization",
        "name": "IT Technical Training",
        "logo": "http://localhost:4000/"
    },
    "url": "http://localhost:4000/search",
    "image": {
        "@type": "ImageObject",
        "url": "http://localhost:4000/assets/built/images/blog-cover2.png",
        "width": 2000,
        "height": 666
    },
    "mainEntityOfPage": {
        "@type": "WebPage",
        "@id": "http://localhost:4000/search"
    },
    "description": "얼큰우동TV, 쉽게배우는 IT(Programming,Machine Learning,금융)"
}
    </script>

    <!-- <script type="text/et-cetera" src="https://demo.ghost.io/public/ghost-sdk.min.js?v=724281a32e"></script>
    <script type="text/et-cetera">
    ghost.init({
    	clientId: "ghost-frontend",
    	clientSecret: "f84a07a72b17"
    });
    </script> -->

    <!-- 사용자 browser 확인 코드 - Chrome이 아니면 경고 메시지 출력 -->

    <script>
        var agent = navigator.userAgent.toLowerCase();
        var _iPhone = false;
        var _chrome = false;
        var result = false;
        if (agent.indexOf("iphone") != -1) {
            _iPhone = true;
        }
        if (agent.indexOf("chrome") != -1) {
            _chrome = true;
        }

        if( _iPhone || _chrome ) {
            result = true;
        }

        if( !result ) {
            alert("이 블로그는 Google Chrome Browser에 최적화 되어 있습니다 !!");
        }

    </script>

    <meta name="generator" content="Jekyll 3.6.2" />
    <link rel="alternate" type="application/rss+xml" title="Search Result" href="/feed.xml" />


</head>
<body class="page-template">

    <div class="site-wrapper">
        <!-- All the main content gets inserted here, index.hbs, post.hbs, etc -->
        <!-- < default -->
<!-- The tag above means: insert everything in this file
into the {body} of the default.hbs template -->

<!-- The big featured header, it uses blog cover image as a BG if available -->
<header class="site-header outer">
    <div class="inner">
        <nav class="site-nav">
    <div class="site-nav-left">
        
            
                <a class="site-nav-logo" href="http://localhost:4000">IT Technical Training</a>
            
        
        
            
<ul class="nav" role="menu">
<!--    <li class="nav-home" role="menuitem"><a href="/">Home</a></li>-->
    <li class="nav-about" role="menuitem"><a href="/about/">About</a></li>
<!--
    <li class="nav-data-analysis-article" role="menuitem"><a href="/author/data-analysis/">Data Analysis(R)</a></li>
    <li class="nav-python-article" role="menuitem"><a href="/author/python/">Python</a></li>
    <li class="nav-python-article" role="menuitem"><a href="/tag/jekyll/">Jekyll</a></li>
    <li class="nav-miscellaneous-article" role="menuitem"><a href="/author/fragmentary-knowledge/">Miscellaneous Article</a></li>
-->
<!--
    <li class="nav-archive" role="menuitem">
        <a href="/archive.html">All Posts</a>
    </li>
-->
    <li class="nav-python" role="menuitem">
        <a href="/tag/jekyll/">Jekyll Blog 생성</a>
    </li>
    <li class="nav-python" role="menuitem">
        <a href="/tag/python/">Python</a>
    </li>
    <li class="nav-data-science" role="menuitem">
        <a href="/tag/data-science/">Data Science</a>
    </li>
    <li class="nav-machine-learning" role="menuitem">
        <a href="/tag/machine-learning/">Machine Learning</a>
    </li>
    <li class="nav-python" role="menuitem">
        <a href="/tag/r/">R 기초강의</a>
    </li>
<!--    <li class="nav-python" role="menuitem">-->
<!--        <a href="/tag/angular/">Angular</a>-->
<!--    </li>-->
    <li class="nav-python" role="menuitem">
        <a href="/tag/et-cetera/">Et cetera</a>
    </li>
    <li class="nav-archive" role="menuitem">
        <a href="/author_archive.html">All Posts</a>
    </li>
</ul>

<!-- 아래 내용이 있으면 홈 화면 좌측 상단에 Navigation 버튼이 생성됨.. 굳이 필요없어서 comment 처리 -->

<!--
<nav id="dl-menu" class="dl-menuwrapper" role="navigation">
    <button class="dl-trigger">Open Menu</button>
    <ul class="dl-menu">
        <li><a href="http://localhost:4000/">Home</a></li>
        <li>
            <a href="#">About</a>
            <ul class="dl-submenu">
                <li style="text-align: center">
                    <img src="http://localhost:4000/assets/built/images/photo.jpg" alt="SungHoon Moon photo" class="author-photo">
                </li>
                <li>
                    <h4>SungHoon Moon</h4>
                    <p>Director of ATGLab. <br>Ph.D. in Computer Science</p>
                </li>
                <li><a href="http://localhost:4000/about/"><i class="fa fa-external-link"></i><span class="btn btn-inverse"> Learn More</span></a></li>
                <li>
                <a href="mailto:moon9342@gmail.com"><i class="fa fa-fw fa-envelope"></i> Email</a>
            </li>
                
                
                
                
                
                
                
                
                
            </ul>
        </li>
        <li>
            <a href="#">Posts</a>
            <ul class="dl-submenu">
                <li><a href="http://localhost:4000/archive">All Posts</a></li>
                <li><a href="http://localhost:4000/author_archive">All Tags</a></li>
            </ul>
        </li>
        
    </ul>
</nav>
-->
        
    </div>
    <div class="site-nav-right">
        <div class="social-links">
            
            
        </div>
        
            <a class="subscribe-button" href="#subscribe">Search</a>
        
    </div>
</nav>

    </div>
</header>

<!-- Everything inside the #post tags pulls data from the post -->
<!-- #post -->

<main id="site-main" class="site-main outer" role="main">
    <div class="inner">

        <article class="post-full post page no-image">

            <header class="post-full-header">
                <h1 class="post-full-title">Search Result</h1>
            </header>

            

            <section class="post-full-content">
                <form action="/search" method="get" hidden="hidden">
    <label for="search-box"></label>
    <input type="text" id="search-box" name="query">
</form>

<ul class="mylist" id="search-results"></ul>

<script>

    window.store = {
    
    "jekyll-regenerate-speed-up": {
        "title": "Jekyll 기반의 GitHub Page 생성(9) - Jekyll site regeneration 속도 향상시키기",
            "author": "moon9342",
            "category": "",
            "content": "Jekyll 기반의 GitHub Page 생성은 여러 절로 구성되어 있습니다.    Jekyll 기반의 GitHub Page 생성(1) - 환경설정    Jekyll 기반의 GitHub Page 생성(2) - 블로그 수정 &amp; Publishing    Jekyll 기반의 GitHub Page 생성(3) - 웹 폰트 설정    Jekyll 기반의 GitHub Page 생성(4) - rouge를 이용한 syntax highlighting    Jekyll 기반의 GitHub Page 생성(5) - lunr.js를 이용한 Search 기능 추가    Jekyll 기반의 GitHub Page 생성(6) - Google Search Console 활용    Jekyll 기반의 GitHub Page 생성(7) - GitHub Gist 활용    Jekyll 기반의 GitHub Page 생성(8) - Travis CI 활용(public Repository)    Jekyll 기반의 GitHub Page 생성(9) - Jekyll site regeneration 속도 향상시키기Site Regeneration 속도 올리기블로그에 포스트개수가 많아지고 기능이 추가될수록 Jekyll의 site generation 속도가 현저하게 떨어지게 됩니다. 어쩔 수 없는일이긴 합니다. 포스트가 1,000개 정도 되면 컴퓨터 사양에 따라 많이 다르겠지만 약 1분 가량의 시간이 걸리게 된답니다.처음에야 포스트가 얼마 없다보니 금방 site가 생성되지만 말이죠.일반적으로 우리가 새로운 포스트를 쓸 때 로컬에서 watch mode를 이용해서 파일이 변경되면 다시 site를 regeneration하도록 설정하고사용합니다. 그래야 변경된 내용을 빠르게 확인할 수 있기 때문이지요.하지만 우리가 포스트의 내용을 변경해서 저장할 때 마다 가지고 있는 모든 폴더에 있는 파일을 검색하고 generation하는 건 비효율적입니다. site regeneration 시간이 너무 오래걸려서 내가 수정한 혹은 작성한 내용을 확인하기 위해 많이 기다려야 하는 것이지요. 추후에 블로그에 글 내용이 많아지신다면 무슨 말인지 충분히 공감하실 겁니다.이 문제를 해결하기 위해 간단한 설정하나를 추가해 보도록 하겠습니다.지금까지 우리는 site를 생성하고 로컬 웹서버를 이용해 실행시키기 위해 다음과 같이 명령을 실행시켰습니다.  bundle exec jekyll serve이제 저 명령 뒤에 option을 하나 주시면 됩니다. --limit_posts 라는 option은데 뒤쪽에 숫자 인자가 들어옵니다. 예를 들어 다음과 같이 실행시키면  bundle exec jekyll serve --limit_posts 1시간상으로 마지막으로 등록된 포스트 1개만 가지고 site를 regeneration시키게 됩니다. 물론 기존의 내용은 컴파일 되지 않기때문에사이트에 나타나지는 않겠지만 현재 작업하고 있는 포스트에 대한 내용은 빠르게 확인이 가능합니다. 이렇게 작업하고 최종적으로는site 전체를 다시 build해 주시면 될 듯 합니다.End.",
        "url": "/jekyll-regenerate-speed-up"
    }
    ,
    
    "jekyll-travis-ci-public": {
        "title": "Jekyll 기반의 GitHub Page 생성(8) - Travis CI 활용(public Repository)",
            "author": "moon9342",
            "category": "",
            "content": "Jekyll 기반의 GitHub Page 생성은 여러 절로 구성되어 있습니다.    Jekyll 기반의 GitHub Page 생성(1) - 환경설정    Jekyll 기반의 GitHub Page 생성(2) - 블로그 수정 &amp; Publishing    Jekyll 기반의 GitHub Page 생성(3) - 웹 폰트 설정    Jekyll 기반의 GitHub Page 생성(4) - rouge를 이용한 syntax highlighting    Jekyll 기반의 GitHub Page 생성(5) - lunr.js를 이용한 Search 기능 추가    Jekyll 기반의 GitHub Page 생성(6) - Google Search Console 활용    Jekyll 기반의 GitHub Page 생성(7) - GitHub Gist 활용    Jekyll 기반의 GitHub Page 생성(8) - Travis CI 활용(public Repository)    Jekyll 기반의 GitHub Page 생성(9) - Jekyll site regeneration 속도 향상시키기영상설명이번 영상은 Travis CI를 이용하여 우리블로그의 build와 배포를 자동화하는 방법에 대한 내용입니다.Jekyll 기반의 GitHub Page 생성(8) - Travis CI 활용 영상Travis CI 활용(public Repository)CI ( Continuous Integration )의 개념에 대해서 잘 알지 못하시는 분은 여기를 클릭하셔서 간단하게 이해를 하고 오시면 됩니다.이 포스트에서는 Travis CI를 이용하여 Jekyll Source Folder안의 내용을 GitHub Repository에 commit했을 때 자동으로 GitHub Page에 블로그가 deploy되도록 하는 방법에 대해서 알아보겠습니다.일단은 사용하는 GitHub Repository는 모두 Public으로 되어 있다고 가정하고 진행합니다. 만약 Private Repository를 이용하실려면 좀 더 복잡한 처리와 돈이 들어갑니다. (Travis CI는 GitHub Public Repository에 대해서는 무료이지만 Private Repository에 대해서는 일정량의 금액을 지불해야 합니다.)그럼 천천히 한번 진행해 보도록 하죠GitHub에 2개의 Repository 준비먼저 Jekyll Source Folder ( C:/blogmaker )에 대한 GitHub Repository를 준비합니다. Public으로 생성하셔야 합니다.저는 GitHubPageMaker라는 이름으로 Repository를 생성했습니다. 생성할 때 README.md 파일을 추가해서 생성하지 않습니다.  https://github.com/moon9342/GitHubPageMaker 형태로 생성되겠군요.그 다음은 GitHub Page에서 운영할 블로그에 대한 GitHub Repository를 준비합니다. 역시 마찬가지로 Public으로 생성하셔야 합니다.Repository의 이름은 형식이 정해져 있습니다. {GitHub ID}.github.io 로 Repository를 생성하셔야 합니다. 생성할 때 README.md 파일 하나 추가해서 생성합니다.  https://github.com/moon9342/moon9342.github.io 형태로 생성되겠네요.Local Git Repository 생성 및 Remote 연결GitHub에 원격 Repository가 생성되었으니 이번에는 로컬에 Repository를 생성합니다. C:/blogmaker 폴더에서 command 창을 열고다음을 입력합니다.  git initC:/blogmaker에 git Repository를 생성합니다. 이제 다음의 명령어를 이용해서 로컬 Repository에 파일을 추가하고 commit까지 진행합니다.  git add *  git commit -m “initial commit”자 이제 원격 Repository와 연결하는 작업을 수행합니다. 다음의 명령을 이용합니다.  git remote add origin https://github.com/moon9342/GitHubPageMaker.git현재의 로컬 Repository가 원격 Repository와 연결되었습니다. 연결상태를 확인하려면 다음과 같이입력하면 됩니다.  git remote -vGit Submodule 생성Jekyll Source Folder( C:/blogmaker )에 대한 Repository와 실제 블로그를 운영할 Repository를git submodule로 묶습니다. Submodule의 개념은 여기나 혹은 다른 블로그를 참조하세요.command 창에서 다음과 같이 입력합니다. ( command 창의 현재 경로는 C:/blogmaker 입니다.)  git submodule add https://github.com/moon9342/moon9342.github.io.git output현재 Repository의 하위에 output이라는 이름의 폴더가 만들어지고 해당 폴더는 moon9342.github.io Repository에 대한 로컬 git Repository가 됩니다. ( 내부적으로 git clone이 실행됩니다. )output이라는 이름은 다른 이름으로 변경하셔도 됩니다. 단 _config.yml에 있는 destination 속성의 값과 이 이름이 같아야 합니다.정상적으로 clone이 진행되어서 submodule이 생성되면 다음과 같이 입력합니다.  git submodule updategit은 submodule에 대한 삭제명령을 제공하지 않기 때문에 만약 기존의 submodule을 삭제하려면 다음과 같이 해야 합니다.  Repository 루트에 있는 .gitmodules 파일 수정  Repository 루트의 .git 폴더안의 config 파일 수정 ( [submodule “xxx”] 부분 수정)  git의 cache에서 submodule 삭제 ( git rm --cached module_path )_config.yml 1차 수정Jekyll Source Folder( C:/blogmaker )에 있는 내용을 컴파일 하면 그 결과가 output 폴더에 들어가도록_config.yml을 수정합니다._config.yml의 destination 부분을 찾아 ./output/으로 수정합니다.Travis 사이트에 접속Travis 사이트에 접속해서 GitHub Repository에 대한 연결을 활성화 시킵니다.기본적으로 Public Repository만 사용할 수 있습니다. 만약 Private Repository를 사용하고 싶으면 별도의 비용을 지불해야 합니다. ( 비용이 좀 비싼편입니다. )  https://travis-ci.org =&gt; Public Repository를 위한 site입니다. GitHub 계정으로 로그인 합니다.  https://travis-ci.com =&gt; Private Repository를 위한 site입니다. GitHub 계정으로 로그인 합니다.그림에서와 같이 연동할 GitHub Repository를 선택해서 Enabled 시켜줍니다.잠깐 정리하자면, 연동된 GitHub Repository인 GitHubPageMaker에 push가 이루어지면 Travis CI가 .travis.yml 설정파일을찾아서 이를 이용해 특정 작업을 수행하게 됩니다. 당연히 GitHubPageMaker Repository에 .travis.yml 파일을 작성해서 넣어 놓아야합니다.우리는 이 .travis.yml과 Rakefile을 이용하여 output안에 있는 내용을 commit하고 push하게 될 것입니다. output은 GitHub Page와 연동되는 Repository이기 때문에 결국 Jekyll로 컴파일한 내용이 GitHub Page Repository로 들어가게 되는 겁니다.Token 생성Travis CI에서 다른 Repository로 push를 하기 위해서는 token이 필요합니다.GitHub에 접속해 Setting &gt; Developer settings &gt; Personal access tokens에 들어가서 Generate New Token을 클릭합니다.적당히 description을 작성하고 Select scopes 중 repo 선택하고 generate token을 클릭하면 새로운 token이 생성됩니다. 이 token을 바로 이용할 건 아니기 때문에 어딘가에 잘 저장해 둡니다.이 token값을 직접 Travis CI 설정파일( .travis.yml )에 직접 노출시키면 안되고 이 값을 암호화해서 사용해야 합니다.일단 command 창을 열어서 travis gem을 설치합니다.  gem install travis설치가 끝나면 다음의 명령을 이용해서 암호화를 진행합니다. 만약 로그인을 안했다는 메시지가 나오면 다음과 같이 로그인 후 진행하시면 됩니다. (ID/PW는 GitHub의 ID/PW를 이용합니다.)  travis login --pro  travis encrypt GITHUB_TOKEN=&lt;token&gt; -r &lt;repo-name&gt;여기서 &lt;token&gt;에는 아까 우리가 획득한 GitHub token을 넣어주시면 됩니다. &lt;repo-name&gt;부분에는 우리의Jekyll Source Folder에 대한 Repository이름을 주면 됩니다. 주의하실점은 {ID/RepoName} 형태로 사용하셔야 합니다. 저의 경우를 예로 들자면 다음과 같습니다.  travis encrypt GITHUB_TOKEN=123abc456xxx -r moon9342/GitHubPageMaker위의 과정을 거치면 암호화된 값을 얻을 수 있는데 이 값을 아래와 같이 .travis.yml안에 설정하시면 됩니다.env:  global:    secure: \"여기에 암호화된 값을 넣습니다.\"branches:  only:    - master사용되는 파일 수정이제 _config.yml, .travis.yml, Rakefile 파일을 아래와 같이 적절하게 수정해야 합니다. Ruby언어로 작성된 script를 보는게 영 껄끄럽지만 어렵지 않는 내용이니 천천히 보시면 됩니다._config.yml 파일입니다.# Jekyll configurationmarkdown: kramdown# kramdown : markdown의 개조판.# markdown에서 불편한 사항을 개선한 형태.# MyDataowner:  name:           SungHoon Moon  avatar:         photo.jpg  bio:            &quot;Ph.D. in Computer Science&quot;  email:          moon9342@gmail.com  # Social networking links used in footer. Update and remove as you like.  twitter:  facebook:  github:  stackexchange:  linkedin:  instagram:  flickr:  tumblr:  # google plus id, include the &#39;+&#39;, eg +mmistakes  google_plus:highlighter: rouge# text highlighter로 rouge이용# 2016.02월 이후로 syntax highlighter는 rouge만 지원.# Pygments 사용불가.paginate: 20# 작성한 모든 post를 하나의 페이지에 열거할 수 없으니# pagination이 필요하고 몇개의 post를 하나의 page에서# 보여줄 건지를 설정.language: &#39;en-uk&#39;# 언어 설정url: https://moon9342.github.io# Google Search Console에서 사용하는 sitemap.xml 생성시# 이 url key값이 존재하지 않으면 sitemap.xml이# 정상적으로 생성되지 않는다.# 또한 disqus(댓글시스템)를 이용하기 위해서도 필요.# 자신의 github page url을 입력# ( https://your_github_id.github.io 형식 )baseurl: /# Website infotitle: IT Technical Training# 자신의 blog title.description: IT기반기술교육 블로그# blog home에 표시될 blog에 대한 전반적인 설명.cover: assets/built/images/blog-cover1.png# blog home에 표시될 blog cover image.logo:logo_dark:favicon: assets/built/images/favicon.jpg# favicon으로 사용할 imageproduction_url: https://moon9342.github.io/# 최종적으로 blog가 운영될 urlsource_url: https://github.com/moon9342/GitHubPageMaker/# blogmaker(jekyll source folder)에 대한 github repository# Social infonavigation: True# Navigation bar link를 보여줄건지 여부subscribers: True# subscriber 기능을 사용할건지의 여부# 저는 약간의 수정을 통해 subscriber 기능대신# lunr.js를 이용한 검색 기능으로 대체 사용했습니다.# 검색기능으로 대체하기 위해서# `_includes/subscribe-form.html` 파일의 수정이 필요합니다.twitter:facebook:# 만약 twitter와 facebook을 이용하면 username을 입력# Disqusdisqus: Truedisqus_shortname: xxxxxxxx# disqus는 온라인 댓글 시스템. 댓글 기능을 사용하기 위해# disqus를 이용할 것인지 여부와 만약 사용하면# disqus shortname을 입력 ( disqus username이 아님 )# Google Analyticsgoogle_analytics: UA-xxxxxxxx-x # replace with your GA tracking identifier# Google Analytics을 사용할 경우 GA tracking identifier를 입력# Permalinkspermalink: /:title# permalink: /author/:author# permalink: /tag/:title# 각각의 post에 고정주소를 어떤 방식으로 할당할 것인지를 결정# 이 값을 바꾸면 작성한 포스트의 저장위치나 파일이름이 변경된다.# gems and other configsplugins: [jekyll-paginate, jekyll-feed, jekyll-gist]feed:  path: feed.xml# Travis-CI 설정입니다.safe: Falselsi: Falseusername: moon9342repo: GitHubPageMaker# username : travis-ci와 연동하는 github의 username# repo: travis-ci와 연동하는 github의 repository이름# https://github.com/&lt;username&gt;/&lt;repository&gt;branch: master# 사용할 branch명relative_source:destination: ./output/# compile된 결과가 생성되는 폴더# 이 폴더안의 내용이 우리가 운영하는 블로그 내용이 컴파일되서 들어간다.# 이 폴더안의 내용을 github repository(https://username.github.io)에 push# 만약 Travis-CI를 이용할 예정이면 이 부분을 git submodule로# github repository(https://username.github.io)에 연결해야 한다.# exclude는 Jekyll컴파일 시 destination에 포함될 필요가# 없는것들을 명시한다. (node_modules와 필요없는 것들은 제외)exclude:  - README.md  - Rakefile  - Gemfile  - Gemfile.lock  - changelog.md  - &quot;*.Rmd&quot;  - vendor  - .travis.yml  - node_modules  - assets/css  - assets/images  - _posts/angular  - _posts/et-cetera  - _posts/python  - _posts/typescript#  - _posts/jekyll  - _posts/iot  - _posts/r  - _posts/economy.travis.yml 파일입니다.sudo: falselanguage: rubycache: bundlerrvm:- 2.4.2install:  # Install Jekyll and dependencies  - bundle installbefore_script:  - git config --global user.email &quot;moon9342@gmail.com&quot;  - git config --global user.name &quot;SungHoon Moon&quot;script: bundle exec rake site:deploy --quiet #--trace# Generate your secure token with the travis gem:# get Github token from your Travis CI profile page# gem install travis# GH_TOKEN from https://github.com/settings/tokens# travis encrypt &#39;GIT_NAME=&quot;YOUR_USERNAME&quot; GIT_EMAIL=&quot;YOUR_EMAIL&quot; GH_TOKEN=YOUR_TOKEN&#39;env:  global:    secure: &quot;xxxxxxxxxxxxxxxxxxxx&quot;branches:  only:    - masterRakefile 파일입니다.############################################################################### Modified version of jekyllrb Rakefile# https://github.com/jekyll/jekyll/blob/master/Rakefile##############################################################################require &#39;rake&#39;require &#39;date&#39;require &#39;yaml&#39;CONFIG = YAML.load(File.read(&#39;_config.yml&#39;))USERNAME = CONFIG[&quot;username&quot;]REPO = CONFIG[&quot;repo&quot;]SOURCE_BRANCH = CONFIG[&quot;branch&quot;]DESTINATION_BRANCH = &quot;master&quot;def check_destination  unless Dir.exist? CONFIG[&quot;destination&quot;]    sh &quot;git clone https://$GIT_NAME:$GITHUB_TOKEN@github.com/#{USERNAME}/#{REPO}.git #{CONFIG[&quot;destination&quot;]}&quot;  endendnamespace :site do  desc &quot;Generate the site&quot;  task :build do    check_destination    sh &quot;bundle exec jekyll build&quot;  end  desc &quot;Generate the site and serve locally&quot;  task :serve do    check_destination    sh &quot;bundle exec jekyll serve&quot;  end  desc &quot;Generate the site, serve locally and watch for changes&quot;  task :watch do    sh &quot;bundle exec jekyll serve --watch&quot;  end  desc &quot;Generate the site and push changes to remote origin&quot;  task :deploy do    # Detect pull request    if ENV[&#39;TRAVIS_PULL_REQUEST&#39;].to_s.to_i &gt; 0      puts &#39;Pull request detected. Not proceeding with deploy.&#39;      exit    end    # Configure git if this is run in Travis CI    if ENV[&quot;TRAVIS&quot;]      sh &quot;git config --global user.name $GIT_NAME&quot;      sh &quot;git config --global user.email $GIT_EMAIL&quot;      sh &quot;git config --global push.default simple&quot;    end    # Make sure destination folder exists as git repo    check_destination    sh &quot;git checkout #{SOURCE_BRANCH}&quot;    Dir.chdir(CONFIG[&quot;destination&quot;]) { sh &quot;git checkout #{DESTINATION_BRANCH}&quot; }    # Generate the site    sh &quot;bundle exec jekyll build&quot;    # Commit and push to github    sha = `git log`.match(/[a-z0-9]{40}/)[0]    Dir.chdir(CONFIG[&quot;destination&quot;]) do      # check if there is anything to add and commit, and pushes it      sh &quot;if [ -n &#39;$(git status)&#39; ]; then            git add --all .;            git commit -m &#39;Updating to #{USERNAME}/#{REPO}@#{sha}.&#39;;            git push https://$GITHUB_TOKEN@github.com/#{USERNAME}/#{USERNAME}.github.io.git #{DESTINATION_BRANCH} --quiet ;         fi&quot;      puts &quot;Pushed updated branch #{DESTINATION_BRANCH} to GitHub Pages&quot;    end  endend모든 설정이 끝났습니다. 이제 GitHub에 push작업을 해 보시면 Travis CI가 동작하면서 내부적으로 처리해서 결과를알려줍니다. 해보시면 아시겠지만 거의 스팸메일처럼 날라옵니다.Travis CI 사이트에 들어가면 CI Server가 어떻게 처리하는지를 실시간적으로 log를 출력해 보여주는데 그걸 보시면서 혹 문제가 있는 부분이 있으면 해결하시면 됩니다.Private Repository 사용우리는 두개의 Repository를 사용하고 있고 둘 다 Public으로 사용하고 있습니다. 당연한 말이지만이 중 중요한 것은 여러 설정과 실제 원본내용이 들어있는 Jekyll Source Folder에 대한 Repository인GitHubPageMaker Repository입니다. {GitHub ID}.github.io Repository는 Public으로 설정하고 Jekyll Source Folder는 Private으로 관리하고 싶은 경우는 위의 과정에서 약간만 손보시면 됩니다.  GitHub에서 해당 Repository를 Private으로 설정합니다.  travis-ci.com으로 접속하셔서 Private Repository에 대한 연결을 활성화 시킵니다.  획득한 token을 암호화 시키는 부분에서 다음과 같이 --pro 옵션을 추가합니다.  travis encrypt GITHUB_TOKEN=123abc456xxx -r moon9342/GitHubPageMaker --pro나머지 부분은 동일합니다.Travis CI를 이용할 경우 속도문제Travis CI를 돌려보면 알겠지만 내부적으로 bundle install을 매번 수행합니다. 이 간단한 것 하나 해결하는데2분가량의 시간이 걸리고 대부분의 시간이 설치시간입니다. 이 문제를 해결할 수 있는 방법 역시 있습니다.cache 처리인데요. 이 부분은 나중에 포스팅 할 예정입니다. 문제가 꼬리에 꼬리를 물면서 계속 튕겨 나오네요. 그러면서 배우는 거죠 머 ^^;일단 이런 문제가 있어요~ 라는 문제 제기만 하고 이번 글은 정리하도록 하겠습니다.End.",
        "url": "/jekyll-travis-ci-public"
    }
    ,
    
    "jekyll-gist": {
        "title": "Jekyll 기반의 GitHub Page 생성(7) - GitHub Gist 활용",
            "author": "moon9342",
            "category": "",
            "content": "Jekyll 기반의 GitHub Page 생성은 여러 절로 구성되어 있습니다.    Jekyll 기반의 GitHub Page 생성(1) - 환경설정    Jekyll 기반의 GitHub Page 생성(2) - 블로그 수정 &amp; Publishing    Jekyll 기반의 GitHub Page 생성(3) - 웹 폰트 설정    Jekyll 기반의 GitHub Page 생성(4) - rouge를 이용한 syntax highlighting    Jekyll 기반의 GitHub Page 생성(5) - lunr.js를 이용한 Search 기능 추가    Jekyll 기반의 GitHub Page 생성(6) - Google Search Console 활용    Jekyll 기반의 GitHub Page 생성(7) - GitHub Gist 활용    Jekyll 기반의 GitHub Page 생성(8) - Travis CI 활용(public Repository)    Jekyll 기반의 GitHub Page 생성(9) - Jekyll site regeneration 속도 향상시키기영상설명이번 영상은 Code Snippet을 관리하기 위한 도구인 GitHub Gist를 우리블로그에서 사용하는 방법에 대한 내용입니다.Jekyll 기반의 GitHub Page 생성(7) - GitHub Gist 활용 영상GitHub Gist 활용GitHub의 Gist에 대해서 잘 알지 못하시는 분은 여기를 클릭하셔서 간단하게 Gist에 대한 이해를 하고 오시면 됩니다.그럼 설치부터 천천히 알아보도록 하죠.먼저 gist를 사용할 수 있도록 gem을 설치해야 합니다. 아래와 같이 command 창에서 명령어를 입력합니다.  gem install jekyll-gistgem 설치가 끝나면 _config.yml을 수정해야 합니다.아래의 코드는 저의 _config.yml입니다.# Jekyll configurationmarkdown: kramdown# kramdown : markdown의 개조판.# markdown에서 불편한 사항을 개선한 형태.# MyDataowner:  name:           SungHoon Moon  avatar:         photo.jpg  bio:            &quot;Ph.D. in Computer Science&quot;  email:          moon9342@gmail.com  # Social networking links used in footer. Update and remove as you like.  twitter:  facebook:  github:  stackexchange:  linkedin:  instagram:  flickr:  tumblr:  # google plus id, include the &#39;+&#39;, eg +mmistakes  google_plus:highlighter: rouge# text highlighter로 rouge이용# 2016.02월 이후로 syntax highlighter는 rouge만 지원.# Pygments 사용불가.paginate: 20# 작성한 모든 post를 하나의 페이지에 열거할 수 없으니# pagination이 필요하고 몇개의 post를 하나의 page에서# 보여줄 건지를 설정.language: &#39;en-uk&#39;# 언어 설정url: https://moon9342.github.io# Google Search Console에서 사용하는 sitemap.xml 생성시# 이 url key값이 존재하지 않으면 sitemap.xml이# 정상적으로 생성되지 않는다.# 또한 disqus(댓글시스템)를 이용하기 위해서도 필요.# 자신의 github page url을 입력# ( https://your_github_id.github.io 형식 )baseurl: /# Website infotitle: IT Technical Training# 자신의 blog title.description: IT기반기술교육 블로그# blog home에 표시될 blog에 대한 전반적인 설명.cover: assets/built/images/blog-cover1.png# blog home에 표시될 blog cover image.logo:logo_dark:favicon: assets/built/images/favicon.jpg# favicon으로 사용할 imageproduction_url: https://moon9342.github.io/# 최종적으로 blog가 운영될 urlsource_url: https://github.com/moon9342/GitHubPageMaker/# blogmaker(jekyll source folder)에 대한 github repository# Social infonavigation: True# Navigation bar link를 보여줄건지 여부subscribers: True# subscriber 기능을 사용할건지의 여부# 저는 약간의 수정을 통해 subscriber 기능대신# lunr.js를 이용한 검색 기능으로 대체 사용했습니다.# 검색기능으로 대체하기 위해서# `_includes/subscribe-form.html` 파일의 수정이 필요합니다.twitter:facebook:# 만약 twitter와 facebook을 이용하면 username을 입력# Disqusdisqus: Truedisqus_shortname: xxxxxxxx# disqus는 온라인 댓글 시스템. 댓글 기능을 사용하기 위해# disqus를 이용할 것인지 여부와 만약 사용하면# disqus shortname을 입력 ( disqus username이 아님 )# Google Analyticsgoogle_analytics: UA-xxxxxxxx-x # replace with your GA tracking identifier# Google Analytics을 사용할 경우 GA tracking identifier를 입력# Permalinkspermalink: /:title# permalink: /author/:author# permalink: /tag/:title# 각각의 post에 고정주소를 어떤 방식으로 할당할 것인지를 결정# 이 값을 바꾸면 작성한 포스트의 저장위치나 파일이름이 변경된다.# gems and other configsplugins: [jekyll-paginate, jekyll-feed, jekyll-gist]feed:  path: feed.xml# Travis-CI 설정입니다.safe: Falselsi: Falseusername: moon9342repo: GitHubPageMaker# username : travis-ci와 연동하는 github의 username# repo: travis-ci와 연동하는 github의 repository이름# https://github.com/&lt;username&gt;/&lt;repository&gt;branch: master# 사용할 branch명relative_source:destination: ./output/# compile된 결과가 생성되는 폴더# 이 폴더안의 내용이 우리가 운영하는 블로그 내용이 컴파일되서 들어간다.# 이 폴더안의 내용을 github repository(https://username.github.io)에 push# 만약 Travis-CI를 이용할 예정이면 이 부분을 git submodule로# github repository(https://username.github.io)에 연결해야 한다.# exclude는 Jekyll컴파일 시 destination에 포함될 필요가# 없는것들을 명시한다. (node_modules와 필요없는 것들은 제외)exclude:  - README.md  - Rakefile  - Gemfile  - Gemfile.lock  - changelog.md  - &quot;*.Rmd&quot;  - vendor  - .travis.yml  - node_modules  - assets/css  - assets/images  - _posts/angular  - _posts/et-cetera  - _posts/python  - _posts/typescript#  - _posts/jekyll  - _posts/iot  - _posts/r  - _posts/economy위의 코드는 gist를 이용하여 불러온 코드입니다.중간쯤에plugins: [jekyll-paginate, jekyll-feed, jekyll-gist]부분처럼 설치한 jekyll-gist를 추가시킵니다.그리고 포스트를 하나 생성해서 다음과 같은 구문을 이용하여 gist를 불러오면 됩니다.gist를 불러올 때 JavaScript 링크를 붙였넣는것이 아닙니다. 만약 불러올 링크가 아래와 같으면&lt;script src=\"https://gist.github.com/moon9342/d37bb68b8a51c21d4fe6d1b03dfdfa3e.js\"&gt;&lt;/script&gt;여기에서moon9342/d37bb68b8a51c21d4fe6d1b03dfdfa3e부분만 이용합니다. 즉, 아래와 같이 불러오시면 됩니다.{% gist moon9342/d37bb68b8a51c21d4fe6d1b03dfdfa3e %} 오류 해결한방에 된다면 좋겠지만 잘 안될 수 있습니다.가장 많이 나는 오류는 SSL_connect 오류입니다. Windows 10 사용자들은 다음과 같은 오류가 높은 확률로 발생합니다.  SSL_connect returned=1 errno=0 state=SSLv3 read server certificate B: certificate verify failed에러 메시지를 보니 그냥 해결할 수 있는 종류가 아닌 듯 보입니다. Stack Overflow 사이트에서 찾아보면 몇가지 해결 방안을 발견할 수 있습니다.command 창을 열고 다음과 같이 하나하나 실행 하시면 됩니다.  gem update --system  gem install rubygems-update  update_rubygems위의 과정은 RubyGem을 최신으로 upgrade 시키는 작업입니다.그런 다음 링크를 클릭해서 파일 하나를 다운로드 받습니다. 이 파일은 .pem 파일로 certificate 역할을 하는 파일입니다.파일을 다운로드해서 적절한 위치에 복사합니다. (원하는 폴더에 저장해놓으면 됩니다.)저는 C:/myRuby 폴더를 생성하고 이 안에 해당 파일을 복사해 넣었습니다. 파일이름은 cacert.pem이라고 했습니다.이제 시스템 환경변수를 하나 생성합니다. 환경변수 이름은 SSL_CERT_FILE로 하셔야 하며 환경변수의 값으로파일에 대한 절대경로를 넣어줍니다. 저같은 경우는 C:/myRuby/cacert.pem로 설정해야 겠네요.여기까지 진행했으면 command 창을 다시 열어서(환경변수가 변경되었으니 다시 열어야죠!) 블로그를 다시 build 하시면 됩니다.SSL_connect 문제에 대한 보다 자세한 설명은 링크에서 확인하실 수 있습니다.위와 같이 해서 Code Snippet을 원하는 곳에 붙여 사용할 수 있습니다. gist에서 제공하는default theme가 맘에 안드시면 다음의 CUSTOMIZING GITHUB GISTS를 방문해 보세요. 조금만 살펴보시면 원하는 style로 gist를 사용하실 수 있습니다.End.",
        "url": "/jekyll-gist"
    }
    ,
    
    "jekyll-sitemap": {
        "title": "Jekyll 기반의 GitHub Page 생성(6) - Google Search Console 활용",
            "author": "moon9342",
            "category": "",
            "content": "Jekyll 기반의 GitHub Page 생성은 여러 절로 구성되어 있습니다.    Jekyll 기반의 GitHub Page 생성(1) - 환경설정    Jekyll 기반의 GitHub Page 생성(2) - 블로그 수정 &amp; Publishing    Jekyll 기반의 GitHub Page 생성(3) - 웹 폰트 설정    Jekyll 기반의 GitHub Page 생성(4) - rouge를 이용한 syntax highlighting    Jekyll 기반의 GitHub Page 생성(5) - lunr.js를 이용한 Search 기능 추가    Jekyll 기반의 GitHub Page 생성(6) - Google Search Console 활용    Jekyll 기반의 GitHub Page 생성(7) - GitHub Gist 활용    Jekyll 기반의 GitHub Page 생성(8) - Travis CI 활용(public Repository)    Jekyll 기반의 GitHub Page 생성(9) - Jekyll site regeneration 속도 향상시키기영상설명이번 영상은 우리의 GitHub Page를 Google 검색엔진에 노출시켜 작성한 글이 다른 사람에게 쉽게 노출되도록 설정하는 방법에 대한 내용입니다.Jekyll 기반의 GitHub Page 생성(6) - Google Search Console 활용 영상Google Search Console 활용이번에는 우리의 GitHub Page를 Google 검색엔진에 노출시켜 작성한 글이 다른 사람에게 쉽게 노출되도록 처리해 보겠습니다. 이 작업을 하지 않으면 작성된 글이 웹에 노출될 확률이 현저하게 떨어집니다.Google이 제공하는 Google Search Console을 이용하여 내 GitHub Page의 domain을 등록시키고 sitemap.xml을생성해 Google Search Console에 제출하면 됩니다. sitemap.xml을 등록해 두면 Google 검색 크롤러가 주기적으로페이지를 크롤링하여 indexing하게 됩니다.그럼 간단히 시작해 보겠습니다.  먼저 C:/blogmaker 폴더 아래에 robots.txt 파일을 생성합니다.정확히 말하면 GitHub Page의 root밑에 robots.txt가 존재하면 됩니다.User-agent: *Allow: /Sitemap: https://moon9342.github.io/sitemap.xmlGitHub Page를 이용하기 때문에 모든 검색엔진을 다 설정했습니다. 만약 특정 위치가 크롤링이 되지 않게끔설정하려면 다음과 같이 처리하면 됩니다.User-agent: *Allow: /Disallow: /privateData/Sitemap: https://moon9342.github.io/sitemap.xmlrobots.txt에 대한 조금 더 자세한 설명을 보실려면 여기를 클릭하세요.그런다음 sitemap.xml을 작성해야 합니다. sitemap.xml 역시 GitHub Page의 root밑에 존재해야 하며추후에 Google Search Console에 제출해야 합니다.  C:/blogmaker 폴더 아래에 sitemap.xml 파일을 생성합니다.다음과 같은 형태로 작성합니다.---layout: null---&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;urlset xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;        xsi:schemaLocation=&quot;http://www.sitemaps.org/schemas/sitemap/0.9 http://www.sitemaps.org/schemas/sitemap/0.9/sitemap.xsd&quot;        xmlns=&quot;http://www.sitemaps.org/schemas/sitemap/0.9&quot;&gt;    {% for post in site.posts %}    &lt;url&gt;        &lt;loc&gt;{{ site.url }}{{ post.url }}.html&lt;/loc&gt;        {% if post.lastmod == null %}        &lt;lastmod&gt;{{ post.date | date_to_xmlschema }}&lt;/lastmod&gt;        {% else %}        &lt;lastmod&gt;{{ post.lastmod | date_to_xmlschema }}&lt;/lastmod&gt;        {% endif %}        {% if post.sitemap.changefreq == null %}        &lt;changefreq&gt;weekly&lt;/changefreq&gt;        {% else %}        &lt;changefreq&gt;{{ post.sitemap.changefreq }}&lt;/changefreq&gt;        {% endif %}        {% if post.sitemap.priority == null %}        &lt;priority&gt;0.5&lt;/priority&gt;        {% else %}        &lt;priority&gt;{{ post.sitemap.priority }}&lt;/priority&gt;        {% endif %}    &lt;/url&gt;    {% endfor %}&lt;/urlset&gt;작성이 끝났으면 이제 Google Search Console에 접속합니다. 아래 처럼 자신의 Github page url을 입력합니다.정상적으로 등록되면 아래와 같은 화면을 보실 수 있습니다.왼쪽 메뉴의 크롤링 - Sitemaps를 선택해 sitemap.xml을 추가합니다. 먼저 테스트를 진행한 다음 이상이 없으면 sitemap.xml 파일을 추가합니다. 정상적으로 처리되면 다음과 같은 화면을 보실 수 있습니다.  추후에 site:moon9342.github.io을 브라우져 주소창에 넣고 접속하면 현재 indexing이 어떻게 되어 있나를 확인할 수 있습니다.End.",
        "url": "/jekyll-sitemap"
    }
    ,
    
    "jekyll-search": {
        "title": "Jekyll 기반의 GitHub Page 생성(5) - lunr.js를 이용한 Search 기능 추가",
            "author": "moon9342",
            "category": "",
            "content": "Jekyll 기반의 GitHub Page 생성은 여러 절로 구성되어 있습니다.    Jekyll 기반의 GitHub Page 생성(1) - 환경설정    Jekyll 기반의 GitHub Page 생성(2) - 블로그 수정 &amp; Publishing    Jekyll 기반의 GitHub Page 생성(3) - 웹 폰트 설정    Jekyll 기반의 GitHub Page 생성(4) - rouge를 이용한 syntax highlighting    Jekyll 기반의 GitHub Page 생성(5) - lunr.js를 이용한 Search 기능 추가    Jekyll 기반의 GitHub Page 생성(6) - Google Search Console 활용    Jekyll 기반의 GitHub Page 생성(7) - GitHub Gist 활용    Jekyll 기반의 GitHub Page 생성(8) - Travis CI 활용(public Repository)    Jekyll 기반의 GitHub Page 생성(9) - Jekyll site regeneration 속도 향상시키기영상설명Jekyll은 정적 사이트 generator이기 때문에 검색 기능이 따로 없습니다.이번 영상은 블로그 검색기능을 추가 &amp; 설정하는 방법에 대한 내용입니다.Jekyll 기반의 GitHub Page 생성(5) - 블로그 Search 기능 추가 영상lunr.js를 이용한 Search 기능 추가Jekyll은 정적 사이트 generator이기 때문에 검색 기능이 따로 없습니다. 여러가지 방법을 동원해서 만들 수 있긴 하지만 최종적으로 2가지 방법이 적당할 듯 보입니다.하나는 Google Custom Search를 이용하여 블로그내 검색 기능을 추가하는 것입니다. 쉽고 편하게 검색 기능을 붙이수는 있으나 다음과 같은 단점이 있습니다.  광고가 뜬다 ( 참을 수 있습니다. )  style을 조절하기가 쉽지 않다. ( 참기 힘듭니다. 안 예뻐요! )Google Custom Search는 일단 제외하고 조금 찾아보니 lunr.js를 이용하면 검색 기능을 어렵지 않게 붙일 수 있을 듯 보였습니다. lunr.js는 client side full-text search engine입니다. 검색 기능을 붙이는 방식은 아래의두 사이트를 참고 하였습니다.  Jekyll search using lunr.js  한글 검색 패치Jasper2 theme가 가지고 있는 subscribe 화면을 수정해서 search 기능을 구현해 보겠습니다.Jasper2 theme는 subscribe 기능을 위한 링크를 가지고 있습니다.해당 링크를 누르면 다음과 같은 그림을 볼 수 있습니다.흠.. 새로운 포스트가 등록될 때마다 메일로 전송해주는 것이군요. 당연히 외부 기능을 제공받아야 사용할 수 있습니다.Jasper2 theme는 말 그대로 theme입니다. 모양만 제공해 주는것이지요.저는 이 화면을 검색 화면으로 대체해서 사용했습니다.먼저 _includes/site-nav.html파일을 열어 블로그 안에서 표현되는 Subscribe라는 글자를 Search로 변경합니다.&lt;div class=\"site-nav-right\"&gt;        &lt;div class=\"social-links\"&gt;            {% if site.facebook %}                &lt;a class=\"social-link social-link-fb\"                    href=\"https://facebook.com/{{ site.facebook }}\"                    target=\"_blank\"                    rel=\"noopener\"&gt;{% include facebook.html %}&lt;/a&gt;            {% endif %}            {% if site.twitter %}                &lt;a class=\"social-link social-link-tw\"                    href=\"https://twitter.com/{{ site.twitter }}\"                    target=\"_blank\"                    rel=\"noopener\"&gt;{% include twitter.html %}&lt;/a&gt;            {% endif %}        &lt;/div&gt;        {% if site.subscribers %}            &lt;a class=\"subscribe-button\" href=\"#subscribe\"&gt;Search&lt;/a&gt;        {% endif %}    &lt;/div&gt;맨 아래쪽&lt;a class=\"subscribe-button\" href=\"#subscribe\"&gt;Search&lt;/a&gt;라고 보이는 부분을 수정했습니다.(단순히 Subscribe라는 글자를 Search로 변경했습니다.)그 다음은 기존의 Subscribe 화면을 검색 페이지에 맞게 수정하는 것입니다._layouts/default.html을 열어서 검색 화면으로 수정합니다.{% if site.subscribers %}        &lt;div id=\"subscribe\" class=\"subscribe-overlay\"&gt;            &lt;a class=\"subscribe-overlay-close\" href=\"#\"&gt;&lt;/a&gt;            &lt;div class=\"subscribe-overlay-content\"&gt;                {% if site.logo %}                    &lt;img class=\"subscribe-overlay-logo\"                          src=\"{{ site.baseurl }}{{ site.logo }}\"                          alt=\"{{ site.title }}\" /&gt;                {% endif %}                &lt;h1 class=\"subscribe-overlay-title\"&gt;Search {{ site.title }}&lt;/h1&gt;                &lt;p class=\"subscribe-overlay-description\"&gt;                lunr.js를 이용한 posts 검색 &lt;/p&gt;                {% include subscribe-form.html placeholder=\"keyword\" %}            &lt;/div&gt;        &lt;/div&gt;{% endif %}그 다음으로 _includes/subscribe-form.html을 열어서 수정했습니다.코드는 아래와 같습니다.&lt;span id=\"searchform\" method=\"post\" action=\"/subscribe/\" class=\"\"&gt;    &lt;input class=\"confirm\" type=\"hidden\" name=\"confirm\"  /&gt;    &lt;input class=\"location\" type=\"hidden\" name=\"location\"  /&gt;    &lt;input class=\"referrer\" type=\"hidden\" name=\"referrer\"  /&gt;    &lt;div class=\"form-group\"&gt;        &lt;input class=\"subscribe-email\" onkeyup=\"myFunc()\"                id=\"searchtext\" type=\"text\" name=\"searchtext\"                 placeholder=\"Search...\" /&gt;    &lt;/div&gt;    &lt;script type=\"text/javascript\"&gt;        function myFunc() {            if(event.keyCode == 13) {                var url = encodeURIComponent($(\"#searchtext\").val());                location.href = \"/search.html?query=\" + url;            }        }    &lt;/script&gt;&lt;/span&gt;기존 코드를 수정한것이기 때문에 불필요한 코드도 좀 들어가 있습니다. 중요한 내용은입력상자에서 검색어를 입력하고 enter를 누르면 search.html페이지로 이동하면서검색 결과가 search.html에 출력된다는 정도입니다.이제 검색 결과가 표현될 C:/blogmaker/search.html을 생성해서 다음과 같은 코드를 삽입합니다.---layout: pagecurrent: searchtitle: Search Resultnavigation: truelogo:class: page-templatesubclass: &#39;post page&#39;---&lt;form action=&quot;/search&quot; method=&quot;get&quot; hidden=&quot;hidden&quot;&gt;    &lt;label for=&quot;search-box&quot;&gt;&lt;/label&gt;    &lt;input type=&quot;text&quot; id=&quot;search-box&quot; name=&quot;query&quot;&gt;&lt;/form&gt;&lt;ul class=&quot;mylist&quot; id=&quot;search-results&quot;&gt;&lt;/ul&gt;&lt;script&gt;    window.store = {    {% for post in site.posts %}    &quot;{{ post.url | slugify }}&quot;: {        &quot;title&quot;: &quot;{{ post.title | xml_escape }}&quot;,            &quot;author&quot;: &quot;{{ post.author | xml_escape }}&quot;,            &quot;category&quot;: &quot;{{ post.category | xml_escape }}&quot;,            &quot;content&quot;: {{ post.content | strip_html | strip_newlines | jsonify }},        &quot;url&quot;: &quot;{{ post.url | xml_escape }}&quot;    }    {% unless forloop.last %},{% endunless %}    {% endfor %}    };&lt;/script&gt;&lt;script src=&quot;assets/js/lunr.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;assets/js/search.js&quot;&gt;&lt;/script&gt;이제 마지막 단계만 남았습니다. 사용되는 lunr.js와 search.js를 assets/js 폴더 안에 복사해 주어야 합니다.lunr.js는 여기에서 받으실 수 있습니다.lunr.js의 Official Home은 https://lunrjs.com/입니다. 여기서받으셔도 되고 CDN을 이용하셔도 되는데 이럴 경우 우리의 코드를 수정해야 하기때문에권장하지 않습니다. 제가 제공해드린 파일을 이용하도록 하죠.search.js는 다음과 같은 코드로 작성합니다.(function() {    function displaySearchResults(results, store) {        var searchResults = document.getElementById(&#39;search-results&#39;);        if (results.length) { // Are there any results?            var appendString = &#39;&#39;;            for (var i = 0; i &lt; results.length; i++) {  // Iterate over the results                var item = store[results[i].ref];                appendString += &#39;&lt;li&gt;&lt;a href=&quot;&#39; + item.url + &#39;&quot;&gt;&lt;h6&gt;&#39; + item.title + &#39;&lt;/h6&gt;&lt;/a&gt;&#39;;                appendString += &#39;&lt;p&gt;&#39; + item.content.substring(0, 150) + &#39;...&lt;/p&gt;&lt;/li&gt;&#39;;            }            searchResults.innerHTML = appendString;        } else {            searchResults.innerHTML = &#39;&lt;li&gt;검색 결과가 없습니다.&lt;/li&gt;&#39;;        }    }    function getQueryVariable(variable) {        var query = window.location.search.substring(1);        var vars = query.split(&#39;&amp;&#39;);        for (var i = 0; i &lt; vars.length; i++) {            var pair = vars[i].split(&#39;=&#39;);            if (pair[0] === variable) {                return decodeURIComponent(pair[1].replace(/\\+/g, &#39;%20&#39;));            }        }    }    function trimmerEnKo(token) {        return token            .replace(/^[^\\w가-힣]+/, &#39;&#39;)            .replace(/[^\\w가-힣]+$/, &#39;&#39;);    };    var searchTerm = getQueryVariable(&#39;query&#39;);    if (searchTerm) {        document.getElementById(&#39;search-box&#39;).setAttribute(&quot;value&quot;, searchTerm);        // Initalize lunr with the fields it will be searching on. I&#39;ve given title        // a boost of 10 to indicate matches on this field are more important.        var idx = lunr(function () {            this.pipeline.reset();            this.pipeline.add(                trimmerEnKo,                lunr.stopWordFilter,                lunr.stemmer            );            this.field(&#39;id&#39;);            this.field(&#39;title&#39;, { boost: 10 });            this.field(&#39;author&#39;);            this.field(&#39;category&#39;);            this.field(&#39;content&#39;);        });        for (var key in window.store) { // Add the data to lunr            idx.add({                &#39;id&#39;: key,                &#39;title&#39;: window.store[key].title,                &#39;author&#39;: window.store[key].author,                &#39;category&#39;: window.store[key].category,                &#39;content&#39;: window.store[key].content            });            var results = idx.search(searchTerm); // Get lunr to perform a search            displaySearchResults(results, window.store); // We&#39;ll write this in the next section        }    }})();잘 동작하는지 한번 실행시켜보겠습니다.검색 결과 화면에 대한 css는 취향에 맞게 설정해 사용하면 됩니다.!!End.",
        "url": "/jekyll-search"
    }
    ,
    
    "jekyll-rouge": {
        "title": "Jekyll 기반의 GitHub Page 생성(4) - rouge를 이용한 syntax highlighting",
            "author": "moon9342",
            "category": "",
            "content": "Jekyll 기반의 GitHub Page 생성은 여러 절로 구성되어 있습니다.    Jekyll 기반의 GitHub Page 생성(1) - 환경설정    Jekyll 기반의 GitHub Page 생성(2) - 블로그 수정 &amp; Publishing    Jekyll 기반의 GitHub Page 생성(3) - 웹 폰트 설정    Jekyll 기반의 GitHub Page 생성(4) - rouge를 이용한 syntax highlighting    Jekyll 기반의 GitHub Page 생성(5) - lunr.js를 이용한 Search 기능 추가    Jekyll 기반의 GitHub Page 생성(6) - Google Search Console 활용    Jekyll 기반의 GitHub Page 생성(7) - GitHub Gist 활용    Jekyll 기반의 GitHub Page 생성(8) - Travis CI 활용(public Repository)    Jekyll 기반의 GitHub Page 생성(9) - Jekyll site regeneration 속도 향상시키기영상설명IT 블로그는 블로그 내용에 코드를 포함하고 있는 경우가 상당히 많습니다. 이런 코드의 가독성을 높이기 위해 syntax highlighting 기능을 많이 이용합니다.이번 영상은 블로그 내용에 포함된 코드의 가독성을 높이기 위해 syntax highlighting 기능을 설정하는 방법에 대한 내용입니다.Jekyll 기반의 GitHub Page 생성(4) - syntax highlighting 설정 영상rouge를 이용한 syntax highlightingrouge는 pure-ruby syntax highlighter입니다. 이를 이용하면 블로그에 코드를 붙여넣을 때 간단하게 syntax highlighting 기능을 이용할 수 있습니다.Jekyll은 syntax highlighting을 위해 Pygments도 지원했었는데 Jekyll 3(2016년 02월)부터 Pygments를지원하지 않습니다._config.yml 설정 파일에 다음과 같이 설정한 부분이 있습니다.# Jekyll configurationmarkdown: kramdown# kramdown : markdown의 개조판.# markdown에서 불편한 사항을 개선한 형태.highlighter: rouge# text highlighter로 rouge이용# 2016.02월 이후로 syntax highlighter는 rouge만 지원.# Pygments 사용불가......._config.yml에 설정은 잡아놨는데 실제 설치는 아직 안했습니다. gem을 이용하여 rouge를 설치합니다.command 창을 열어서 다음과 같이 입력합니다.  gem install rougerouge는 특정 style을 가진 css파일을 생성하기 위한 command-line tool을 가지고 있습니다. rougify명령을 이용하면 우리가 원하는 스타일의 css 파일을 생성할 수 있습니다.일단 다음의 명령어로 어떤 스타일을 사용할 수 있는지 확인합니다.  rougify help style아래 부분에 available themes가 보이는 군요. 여기에서 맘에 드는거 하나를 선택해서 style.css를 생성할 수 있습니다.제가 사용하고 있는 theme는 monokai.sublime 입니다.이제 다음과 같은 명령어로 원하는 theme로 css 파일을 생성합니다.  rougify style monokai.sublime &gt; assets/css/syntax.css자 이제 C:/blogmaker/assets/css/syntax.css 파일이 생성되었습니다.이 css파일에 대한 링크를 post에서 사용할 수 있도록 _layouts/default.html에 추가해야 합니다.&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;    &lt;!-- Document Settings --&gt;    &lt;meta charset=\"utf-8\" /&gt;    &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\" /&gt;    &lt;!-- Base Meta --&gt;    ...    ...       &lt;!-- 웹 폰트 설정 --&gt;    &lt;link rel=\"stylesheet\"           href=\"https://fonts.googleapis.com/earlyaccess/nanumgothic.css\"&gt;    &lt;!-- syntax.css --&gt;    &lt;link rel=\"stylesheet\" href=\"/assets/built/syntax.css\"&gt;새로운 css 파일이 생성되었으니 gulp를 이용해 css task를 실행시켜야 합니다. 그래야 minified된 css파일이생성이 되서 블로그에서 이용할 수 있을 테니까요.이제 준비가 끝났습니다. 포스트에서 글 작성할 때 다음과 같은 code block을 이용하게 됩니다.code block에 대해 사용하는 언어를 명시해 주면 그에 맞춰 문법 강조를 하게 됩니다. ~~~javascriptfunction syntaxHighlight(code) {   var foo = 'Hello World';   var bar = 100;}~~~위의 코드에 대한 결과입니다.function syntaxHighlight(code) {   var foo = 'Hello World';   var bar = 100;}End.",
        "url": "/jekyll-rouge"
    }
    ,
    
    "jekyll-font": {
        "title": "Jekyll 기반의 GitHub Page 생성(3) - 웹 폰트 설정",
            "author": "moon9342",
            "category": "",
            "content": "Jekyll 기반의 GitHub Page 생성은 여러 절로 구성되어 있습니다.    Jekyll 기반의 GitHub Page 생성(1) - 환경설정    Jekyll 기반의 GitHub Page 생성(2) - 블로그 수정 &amp; Publishing    Jekyll 기반의 GitHub Page 생성(3) - 웹 폰트 설정    Jekyll 기반의 GitHub Page 생성(4) - rouge를 이용한 syntax highlighting    Jekyll 기반의 GitHub Page 생성(5) - lunr.js를 이용한 Search 기능 추가    Jekyll 기반의 GitHub Page 생성(6) - Google Search Console 활용    Jekyll 기반의 GitHub Page 생성(7) - GitHub Gist 활용    Jekyll 기반의 GitHub Page 생성(8) - Travis CI 활용(public Repository)    Jekyll 기반의 GitHub Page 생성(9) - Jekyll site regeneration 속도 향상시키기영상설명블로그를 운영할 때 가장 신경써야 하는 부분 중 하나는 readability입니다. Jasper2는 영문일 경우 상당히 가독성이 좋은데한글을 사용하니 폰트때문에 가독성이 많이 떨어지더군요. 그래서 폰트를 좀 바꾸어봤습니다.이번 영상은 생성한 블로그의 가독성을 높이기 위해 웹폰트를 설정하는 방법에 대한 내용입니다.Jekyll 기반의 GitHub Page 생성(3) - 웹폰트 설정 영상웹 폰트 설정먼저 사용할 웹 폰트를 물색해야 합니다. 구글에서 찾아보면 원하시는 웹 폰트를 쉽게 찾을 수 있습니다.만만한 나눔고딕 폰트를 이용해 보겠습니다.&lt;link rel=\"stylesheet\" href=\"https://fonts.googleapis.com/earlyaccess/nanumgothic.css\"&gt;나눔고딕 폰트에 대한 링크입니다.이제 _layout/default.html 파일을 열어서 해당 폰트 링크를 넣어줍니다. 다음과 비슷하게 되겠네요.&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;    &lt;!-- Document Settings --&gt;    &lt;meta charset=\"utf-8\" /&gt;    &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\" /&gt;    &lt;!-- Base Meta --&gt;    ...    ...    &lt;!-- 웹 폰트 설정 --&gt;    &lt;link rel=\"stylesheet\" href=\"https://fonts.googleapis.com/earlyaccess/nanumgothic.css\"&gt;이제 css파일을 수정해서 특정 class에 대한 font-family에 나눔고딕 폰트를 추가해 주면 되겠네요.Jasper2에서 일반적인 포스트는 모두 .post-full-content css class의 영향을 받습니다.다른 theme를 이용하시는 분은 포스트들이 어떤 css class에 영향을 받는지를 확인하셔서 그 class를 찾아 수정하시면 됩니다.assets/css/screen.css 파일을 열어서 .post-full-content 부분을 찾아 다음과 같이 수정합니다.Georgia는 영문폰트이기 때문에 영문은 일단 이 폰트를 먼저 이용하게 되고 한글 부분은 Nanum Gothic을 사용하게 됩니다..post-full-content {    position: relative;    margin: 0 auto;    padding: 70px 100px 0;    min-height: 230px;    font-family: Georgia, 'Nanum Gothic', serif;    font-size: 2.2rem;    line-height: 1.6em;    background: #fff;}css가 변경되었으니 gulp를 이용하여 css task를 수행합니다. 이전 포스트에 gulp 수행에대한 내용을 참고하시면 될 듯 합니다.이제 다시 bundle exec jekyll serve을 수행하면 새로 만들어진 css를 이용하여 블로그가 생성될 것이고 한글로 쓴 내용의 폰트가 나눔고딕으로 변경되는 것을 볼 수 있습니다.End.",
        "url": "/jekyll-font"
    }
    ,
    
    "jekyll-struct": {
        "title": "Jekyll 기반의 GitHub Page 생성(2) - 블로그 수정 &amp; Publishing",
            "author": "moon9342",
            "category": "",
            "content": "Jekyll 기반의 GitHub Page 생성은 여러 절로 구성되어 있습니다.    Jekyll 기반의 GitHub Page 생성(1) - 환경설정    Jekyll 기반의 GitHub Page 생성(2) - 블로그 수정 &amp; Publishing    Jekyll 기반의 GitHub Page 생성(3) - 웹 폰트 설정    Jekyll 기반의 GitHub Page 생성(4) - rouge를 이용한 syntax highlighting    Jekyll 기반의 GitHub Page 생성(5) - lunr.js를 이용한 Search 기능 추가    Jekyll 기반의 GitHub Page 생성(6) - Google Search Console 활용    Jekyll 기반의 GitHub Page 생성(7) - GitHub Gist 활용    Jekyll 기반의 GitHub Page 생성(8) - Travis CI 활용(public Repository)    Jekyll 기반의 GitHub Page 생성(9) - Jekyll site regeneration 속도 향상시키기영상설명이번 영상은 자신의 local 컴퓨터에 생성한 블로그를 내 입맛에 맞게 수정하는 방법과 새로운 post를 올리는 방법, 그리고 GitHub Page에 내 블로그를 개설하는 방법에 대한 내용입니다.Jekyll 기반의 GitHub Page 생성(2) - 블로그 수정 영상 (환경설정파일 수정)Jekyll 기반의 GitHub Page 생성(2) - 블로그 수정 영상 (author와 tag 수정)Jekyll 기반의 GitHub Page 생성(2) - 블로그 수정 영상 (메뉴 수정 및 post올리기)Jekyll 기반의 GitHub Page 생성(2) - 블로그 수정 영상 (Archive 설정)Jekyll 기반의 GitHub Page 생성(2) - 블로그 수정 영상 (post의 목차설정)Jekyll 기반의 GitHub Page 생성(2) - GitHub Page에 Blog 올리기블로그 수정이전 포스트에서 Jasper2 theme를 이용한 블로그가 실행되는 것 까지 확인을 했습니다.Jasper2나 혹은 다른 theme를 사용하실 때도 이제부터가 문제입니다. 자신의 입맛에 맞도록 theme를 수정해야 하는데이게 쉬운일이 아닙니다. 개발쪽에 있으신 분들은 쉽게 접근하실 수 있지만 그렇지 않은 경우 상당히 난해합니다.“그냥 Tistory 쓰고말지” 라는 말이 나올정도로요.사실 GitHub Page에서 블로그를 운영하는 사람들 중 많은 사람이 Front-End 개발이 가능한 사람들 입니다.Jekyll은 정적 사이트 생성기 입니다. Liquid template을 기반으로 markdown형식의 텍스트파일을 HTML로 변환해주는 변환 도구라고 보시면 됩니다.이전 포스트에서 Jasper2 theme를 압축해제한 폴더를 기억하시나요? C:/blogmaker 였습니다. 이 폴더가 Jekyll Source Folder가 됩니다.이 Jekyll Source Folder 안의 _post라는 폴더에 우리가 작성하려는 글을 markdown 형식으로 작성합니다. 그런 후 bundle exec jekyll serve 명령을 이용하여 build시키면 저장된 글에 대해 컴파일이 진행되고 결과물이 destination 폴더에 생성됩니다.추후에 GitHub Page에 올려 사용하는 실제적인 블로그가 바로 이 destination 폴더 안에 있는 내용입니다. 따라서 Git을 이용하여 변환된 결과물(destination 폴더안의 내용)을 GitHub Page와 연동되는 GitHub Repository에 push해 주어야 합니다.그리고 사용하는 IDE는 WebStorm을 이용하도록 하겠습니다.그럼 천천히 진행해 보겠습니다.환경설정 파일(_config.yml) 수정Jekyll은 설정파일로 YAML 파일을 이용합니다. YAML에 대한 설명은 YAML이란 링크에 간단히 정리되어 있습니다.이 설정에 대한 파일이 바로 _config.yml입니다. 블로그 생성에 대한 전체 환경 세팅을 담당하는 파일이라고 생각하시면 됩니다.  C:/blogmaker폴더안에서 _config.yml을 찾아 해당내용을 자신에 맞게 수정해서 사용해야 합니다.아래는 제가 사용하는 _config.yml에 대한 내용과 그 설명입니다. 주석이 달린 부분을 중심으로 자신에 맞게 수정해서 사용하시면 됩니다.# Jekyll configurationmarkdown: kramdown# kramdown : markdown의 개조판.# markdown에서 불편한 사항을 개선한 형태.# MyDataowner:  name:           SungHoon Moon  avatar:         photo.jpg  bio:            &quot;Ph.D. in Computer Science&quot;  email:          moon9342@gmail.com  # Social networking links used in footer. Update and remove as you like.  twitter:  facebook:  github:  stackexchange:  linkedin:  instagram:  flickr:  tumblr:  # google plus id, include the &#39;+&#39;, eg +mmistakes  google_plus:highlighter: rouge# text highlighter로 rouge이용# 2016.02월 이후로 syntax highlighter는 rouge만 지원.# Pygments 사용불가.paginate: 20# 작성한 모든 post를 하나의 페이지에 열거할 수 없으니# pagination이 필요하고 몇개의 post를 하나의 page에서# 보여줄 건지를 설정.language: &#39;en-uk&#39;# 언어 설정url: https://moon9342.github.io# Google Search Console에서 사용하는 sitemap.xml 생성시# 이 url key값이 존재하지 않으면 sitemap.xml이# 정상적으로 생성되지 않는다.# 또한 disqus(댓글시스템)를 이용하기 위해서도 필요.# 자신의 github page url을 입력# ( https://your_github_id.github.io 형식 )baseurl: /# Website infotitle: IT Technical Training# 자신의 blog title.description: IT기반기술교육 블로그# blog home에 표시될 blog에 대한 전반적인 설명.cover: assets/built/images/blog-cover1.png# blog home에 표시될 blog cover image.logo:logo_dark:favicon: assets/built/images/favicon.jpg# favicon으로 사용할 imageproduction_url: https://moon9342.github.io/# 최종적으로 blog가 운영될 urlsource_url: https://github.com/moon9342/GitHubPageMaker/# blogmaker(jekyll source folder)에 대한 github repository# Social infonavigation: True# Navigation bar link를 보여줄건지 여부subscribers: True# subscriber 기능을 사용할건지의 여부# 저는 약간의 수정을 통해 subscriber 기능대신# lunr.js를 이용한 검색 기능으로 대체 사용했습니다.# 검색기능으로 대체하기 위해서# `_includes/subscribe-form.html` 파일의 수정이 필요합니다.twitter:facebook:# 만약 twitter와 facebook을 이용하면 username을 입력# Disqusdisqus: Truedisqus_shortname: xxxxxxxx# disqus는 온라인 댓글 시스템. 댓글 기능을 사용하기 위해# disqus를 이용할 것인지 여부와 만약 사용하면# disqus shortname을 입력 ( disqus username이 아님 )# Google Analyticsgoogle_analytics: UA-xxxxxxxx-x # replace with your GA tracking identifier# Google Analytics을 사용할 경우 GA tracking identifier를 입력# Permalinkspermalink: /:title# permalink: /author/:author# permalink: /tag/:title# 각각의 post에 고정주소를 어떤 방식으로 할당할 것인지를 결정# 이 값을 바꾸면 작성한 포스트의 저장위치나 파일이름이 변경된다.# gems and other configsplugins: [jekyll-paginate, jekyll-feed, jekyll-gist]feed:  path: feed.xml# Travis-CI 설정입니다.safe: Falselsi: Falseusername: moon9342repo: GitHubPageMaker# username : travis-ci와 연동하는 github의 username# repo: travis-ci와 연동하는 github의 repository이름# https://github.com/&lt;username&gt;/&lt;repository&gt;branch: master# 사용할 branch명relative_source:destination: ./output/# compile된 결과가 생성되는 폴더# 이 폴더안의 내용이 우리가 운영하는 블로그 내용이 컴파일되서 들어간다.# 이 폴더안의 내용을 github repository(https://username.github.io)에 push# 만약 Travis-CI를 이용할 예정이면 이 부분을 git submodule로# github repository(https://username.github.io)에 연결해야 한다.# exclude는 Jekyll컴파일 시 destination에 포함될 필요가# 없는것들을 명시한다. (node_modules와 필요없는 것들은 제외)exclude:  - README.md  - Rakefile  - Gemfile  - Gemfile.lock  - changelog.md  - &quot;*.Rmd&quot;  - vendor  - .travis.yml  - node_modules  - assets/css  - assets/images  - _posts/angular  - _posts/et-cetera  - _posts/python  - _posts/typescript#  - _posts/jekyll  - _posts/iot  - _posts/r  - _posts/economy위의 설정파일에 destination: ./output/으로 설정되어 있기 때문에 command 창에서 “bundle exec jekyll serve”명령을 수행하면 C:/blogmaker/output/ 폴더가 생성되고 여기에 컴파일된 결과파일들이 저장되게 됩니다.결과파일을 C:/blogmaker ( Jekyll Source Folder )밑의 output folder로 지정한 이유는 나중에 Travis-CI와연동하기 위해서 입니다. ( git submodule로 처리하기 위함입니다. )Travis-CI를 이용하지 않고 그냥 수동으로 결과파일을 자신의 GitHub Page에 올리려면 설정파일에 destination: ../[GitHubPage]/과 같은 형식으로 설정하시면 됩니다.설정 후 “bundle exec jekyll serve” 명령을 수행하면C:/[GitHubPage]/라는 폴더가 생성되고 여기에 컴파일된 결과파일들이 저장되게 됩니다.Jekyll build 작업을 할 때 한가지 주의해야 할 점이 있습니다.기본적으로 Jekyll build는 development 세팅으로 진행됩니다. 만약 실제 GitHub Page에 Publishing할목적으로 build하는 것이라면 JEKYLL_ENV 환경변수의 값을 production으로 설정한 후 build를 진행해야 합니다. (참고링크)  위의 작업을 하지 않으면 정상적으로 URL이 생성되지 않습니다. localhost로 세팅됩니다.author 수정Jasper2는 여러 사람이 자신의 ID로 각자 글을 작성할 수 있습니다. 쉽게 말하자면 홍길동, 신사임당 이라는사람이 있다면 각각 자신의 글을 작성해서 블로깅할 수 있다는 말입니다. 블로그를 보는 사람은 각 author별로post를 모아서 볼 수 있습니다.저는 개인 블로그를 개설하는것을 전제로 설명하기 때문에 author를 1명만 만들어 사용하지만 만약 회사에서사용하는 회사 블로그인 경우 글을 작성하는 사람이 다수일 수 있으므로 author를 여러명 지정해서 사용 할 수 있습니다.아래는 제가 사용하는 authors.yml파일의 내용입니다. 해당 파일은 _data 폴더안에 위치하고 있습니다.moon9342 :  username: moon9342    # user name : martin  name: moon9342        # user full name : Martin Luther King  url_full:             # Homepage url  url:  bio: &lt;a href=&quot;https://www.youtube.com/channel/UCp-MztINXTRVkRGCnqnYNlQ&quot;&gt;돈오리TV, 쉽게배우는 IT(Programming,Machine Learning,금융)&lt;/a&gt;                        # 회사정보  picture: assets/built/images/economy-author-logo.jpg   # author image  facebook:             # facebook ID  twitter:              # twitter ID  cover: Falsetag 수정tag는 글의 범주를 정해줄 수 있는 기능입니다. 다른 author라도 같은 tag의 글을 작성할 수 있으며 author별로post를 모아볼 수 있듯이 같은 tag(같은 주제)별로 post를 모아볼 수 있습니다.아래는 tags.yml파일의 내용(예시)입니다. 해당 파일은 _data 폴더안에 위치하고 있습니다.jekyll :  name: jekyll  description: False  cover: assets/built/images/background-frontend.jpgpython :  name: python  description: False  cover: assets/built/images/background-frontend.jpgeconomy :  name: economy  description: False  cover: assets/built/images/background-frontend.jpg메뉴 수정우리 blog의 메뉴 부분의 내용을 변경하려면 _includes 폴더의 navigation.html을 수정해야 합니다.아래는 navigation.html파일의 내용(예시)입니다.Jekyll에 의해서 자동으로 생성된 archive.html 파일에는 모든 post가 시간순서로 나열되어 있는것을 확인할수 있습니다. 또한 author_archive.html 파일에는 이름과 다르게(?) tag별로 post가 나누어져 있는 것을 확인할 수 있습니다.&lt;ul class=&quot;nav&quot; role=&quot;menu&quot;&gt;    &lt;li class=&quot;nav-home&quot; role=&quot;menuitem&quot;&gt;&lt;a href=&quot;{{site.baseurl}}&quot;&gt;Home&lt;/a&gt;&lt;/li&gt;    &lt;li class=&quot;nav-about&quot; role=&quot;menuitem&quot;&gt;&lt;a href=&quot;{{site.baseurl}}about/&quot;&gt;About&lt;/a&gt;&lt;/li&gt;    &lt;li class=&quot;nav-jekyll&quot; role=&quot;menuitem&quot;&gt;&lt;a href=&quot;{{site.baseurl}}tag/jekyll/&quot;&gt;Jekyll&lt;/a&gt;&lt;/li&gt;    &lt;li class=&quot;nav-python&quot; role=&quot;menuitem&quot;&gt;&lt;a href=&quot;{{site.baseurl}}tag/python/&quot;&gt;Python&lt;/a&gt;&lt;/li&gt;    &lt;li class=&quot;nav-archive&quot; role=&quot;menuitem&quot;&gt;        &lt;a href=&quot;/archive.html&quot;&gt;All Posts&lt;/a&gt;    &lt;/li&gt;    &lt;li class=&quot;nav-archive&quot; role=&quot;menuitem&quot;&gt;        &lt;a href=&quot;/author_archive.html&quot;&gt;Tag별 Posts&lt;/a&gt;    &lt;/li&gt;&lt;/ul&gt;post 작성이제 post를 하나 작성해 보도록 하겠습니다. 적당한 author와 tag를 설정했으면 tag명과 같은 폴더를_posts 폴더 하단에 생성합니다. 그리고 .md로 되어 있는 파일을 아무거나 하나 복사해서 다음과 같이파일명을 수정합니다.  2020-06-07-python-basic.md앞에부분은 파일 작성날짜를 의미하고 python-basic 부분이 해당 파일을 jekyll로 컴파일 한 후 생성할 파일의 파일명으로 사용하게 됩니다.해당파일의 내용을 간단하게 살펴보면 다음과 같이 시작하는 것을 볼 수 있습니다.---layout: postcurrent: postcover:  assets/built/images/python-logo.pngnavigation: Truetitle: Python 강좌(1) - Python 기본 date: 2018-09-27 16:40:00tags: [python]class: post-templatesubclass: 'post tag-python'author: moon9342---포스트를 작성했으면 다시 실행하여 결과를 확인합니다.Archive 설정우리가 글을 posting하면 이 글들이 시간 순서대로 메인화면에 올라가게 됩니다. 내가 작성한모든 글들을 시간순으로 보려면 어떻게 해야할까요? 또는 모든 Tag별로 각 포스트의 제목만을시간순으로 정렬해서 보려면 어떻게 해야할까요?아래와 같은 2개의 파일을 우리 Jekyll Source Folder 루트 밑에 만들어 두시면 됩니다.  archive.md---layout: pagecurrent: archivetitle: All Postsnavigation: truelogo: class: page-templatesubclass: &#39;post page&#39;---&lt;div class=&quot;well article&quot;&gt;{%for post in site.posts %}    {% unless post.next %}        &lt;h2&gt;{{ post.date | date: &#39;%Y&#39; }}&lt;/h2&gt;        &lt;ul&gt;    {% else %}        {% capture year %}{{ post.date | date: &#39;%Y&#39; }}{% endcapture %}        {% capture nyear %}{{ post.next.date | date: &#39;%Y&#39; }}{% endcapture %}        {% if year != nyear %}            &lt;/ul&gt;            &lt;h3&gt;{{ post.date | date: &#39;%Y&#39; }}&lt;/h3&gt;            &lt;ul&gt;        {% endif %}    {% endunless %}    &lt;li&gt;&lt;span class=&quot;post-date&quot;&gt;        {% assign date_format = site.date_format.archive %}        {{ post.date | date: &#39;%Y-%m-%d&#39; }} &lt;/span&gt;&lt;a href=&quot;.{{ post.url }}&quot; target=&quot;_blank&quot;&gt;{{ post.title }}&lt;/a&gt;&lt;/li&gt;{% endfor %}&lt;/ul&gt;&lt;/div&gt;  author_archive.md---layout: pagecurrent: archivetitle: All Tagsnavigation: truelogo: class: page-templatesubclass: &#39;post page&#39;---&lt;div id=&quot;post-index&quot; class=&quot;well article&quot;&gt;{% capture site_tags %}{% for tag in site.tags %}{{ tag | first }}{% unless forloop.last %},{% endunless %}{% endfor %}{% endcapture %}{% assign tags_list = site_tags | split:&#39;,&#39; | sort %}&lt;ul class=&quot;entry-meta inline-list&quot;&gt;  {% for item in (0..site.tags.size) %}{% unless forloop.last %}    {% capture this_word %}{{ tags_list[item] | strip_newlines }}{% endcapture %}  \t&lt;li&gt;&lt;a href=&quot;#{{ this_word }}&quot; class=&quot;tag&quot;&gt;&lt;span class=&quot;term alltags&quot;&gt;{{ this_word }}&lt;/span&gt; &lt;span class=&quot;count alltags&quot;&gt;{{ site.tags[this_word].size }}&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;  {% endunless %}{% endfor %}&lt;/ul&gt;{% for item in (0..site.tags.size) %}{% unless forloop.last %}  {% capture this_word %}{{ tags_list[item] | strip_newlines }}{% endcapture %}\t&lt;article&gt;\t&lt;h2 id=&quot;{{ this_word }}&quot; class=&quot;tag-heading&quot;&gt;{{ this_word | upcase }}&lt;/h2&gt;\t\t&lt;ul&gt;    {% for post in site.tags[this_word] %}{% if post.title != null %}      &lt;!-- &lt;li class=&quot;entry-title&quot;&gt;&lt;a href=&quot;{{ site.url }}{{ post.url }}&quot; target=&quot;_blank&quot; title=&quot;{{ post.title }}&quot;&gt;{{ post.title }}&lt;/a&gt;&lt;/li&gt; --&gt;      &lt;li class=&quot;entry-title&quot;&gt;&lt;a href=&quot;{{ post.url }}&quot; target=&quot;_blank&quot; title=&quot;{{ post.title }}&quot;&gt;{{ post.title }}&lt;/a&gt;&lt;/li&gt;    {% endif %}{% endfor %}\t\t&lt;/ul&gt;\t&lt;/article&gt;&lt;!-- /.hentry --&gt;{% endunless %}{% endfor %}&lt;/div&gt;post 목차 설정각 tag별로 post들을 모아 볼 수 있긴 하지만 블로그의 특성 상 여러 글들이 뒤섞여 있을 수 밖에 없는데 목차를 이용하면 이런 문제들을 조금 완화할 수 있습니다.단, 이런 목차는 Jasper2가 제공하는 기능은 아니고 특정 CSS를 작성하고 목차에 대한 html 파일을 생성한후우리 post에 끼워 넣는 식으로 처리해야 합니다.저의 블로그 post를 보시면 post 시작부분에 목차가 먼저 나오는데 이 부분을 어떻게 설정하면 되는지 알아보겠습니다.먼저 목차를 구성하는 HTML 파일(python-table-of-contents.html)을 하나 준비해야 합니다. 이 파일은_includes 폴더에 저장해서 관리하는게 좋습니다.예시로 다음의 내용을 이용하도록 하겠습니다.&lt;span class=&quot;table-of-contents-list&quot;&gt;Python 강좌는 여러 절로 구성되어 있습니다. &lt;/span&gt;&lt;ul class=&quot;table-of-contents-list&quot;&gt;    &lt;li&gt;&lt;a href=&quot;./python-basic&quot;&gt;Python 강좌(1) - Python 기본&lt;/a&gt;&lt;/li&gt;    &lt;li&gt;&lt;a href=&quot;./python-control-statement&quot;&gt;Python 강좌(2) - Python 제어문&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;관련된 CSS style이 있어야 화면에 정상적으로 표현되기 때문에 CSS style을 지정합니다.이부분은 제공된 파일내용(assets/css/custom.css)을 그대로 이용합니다.true이 CSS 파일은 Gulp를 통해서 minified 되어야 사용할 수 있습니다. 다음의 설정내용을 이용해서Gulp를 수행시킵니다. (Gulp 설치와 CSS compile 부분은 동영상을 참고하시기 바랍니다.)간단하게 설명하면 Node.js를 설치한 후 NPM을 이용하여 필요한 module을 설치합니다. 여기서 주의할 점은 Node.js의 버전이 12버전이면 js파일에서 오류가 발생할 수 있습니다. Gulp의 버전과 Node.js의 버전에 따라서 compile 오류가 발생할 여지가 있기 때문에 만약 오류가 발생하면 버전문제를 해결해야 합니다. (저의 경우는 Node.js 버전을 11버전으로 낮추어서 사용했습니다.)compile이 성공하면 결과 파일은 /assets/built 폴더 하단에 minified CSS파일로 저장되게 됩니다.gulpfile.js의 내용은 아래의 코드를 이용합니다.var gulp = require(&#39;gulp&#39;);// gulp plugins and utilsvar gutil = require(&#39;gulp-util&#39;);var postcss = require(&#39;gulp-postcss&#39;);var sourcemaps = require(&#39;gulp-sourcemaps&#39;);var imagemin = require(&#39;gulp-imagemin&#39;);// postcss pluginsvar autoprefixer = require(&#39;autoprefixer&#39;);var colorFunction = require(&#39;postcss-color-function&#39;);var cssnano = require(&#39;cssnano&#39;);var customProperties = require(&#39;postcss-custom-properties&#39;);var easyimport = require(&#39;postcss-easy-import&#39;);gulp.task(&#39;images&#39;, function() {    return gulp.src(&#39;assets/images/*&#39;)        .pipe(imagemin())        .pipe(gulp.dest(&#39;assets/built/images/&#39;))});gulp.task(&#39;css&#39;, function () {    var processors = [        easyimport,        customProperties,        colorFunction(),        autoprefixer({browsers: [&#39;last 2 versions&#39;]}),        cssnano()    ];    return gulp.src(&#39;assets/css/*.css&#39;)        .pipe(sourcemaps.init())        .pipe(postcss(processors))        .pipe(sourcemaps.write(&#39;.&#39;))        .pipe(gulp.dest(&#39;assets/built/&#39;))});참고로 npm install에 사용되는 package.json은 다음의 내용을 이용해야합니다.{    &quot;name&quot;: &quot;blog&quot;,    &quot;description&quot;: &quot;&quot;,    &quot;version&quot;: &quot;1.0.0&quot;,    &quot;engines&quot;: {        &quot;ghost&quot;: &quot;&gt;=1.2.0&quot;    },    &quot;license&quot;: &quot;MIT&quot;,    &quot;devDependencies&quot;: {        &quot;autoprefixer&quot;: &quot;^7.2.6&quot;,        &quot;cssnano&quot;: &quot;^3.10.0&quot;,        &quot;graceful-fs&quot;: &quot;^4.1.11&quot;,        &quot;gulp&quot;: &quot;^3.9.1&quot;,        &quot;gulp-imagemin&quot;: &quot;^4.1.0&quot;,        &quot;gulp-postcss&quot;: &quot;^7.0.1&quot;,        &quot;gulp-sourcemaps&quot;: &quot;^2.6.5&quot;,        &quot;gulp-util&quot;: &quot;^3.0.8&quot;,        &quot;minimatch&quot;: &quot;^3.0.4&quot;,        &quot;postcss-color-function&quot;: &quot;^4.0.1&quot;,        &quot;postcss-custom-properties&quot;: &quot;^6.3.1&quot;,        &quot;postcss-easy-import&quot;: &quot;^3.0.0&quot;    },    &quot;config&quot;: {        &quot;posts_per_page&quot;: 25    }}마지막으로 이렇게 설정된 python-table-of-contents.html 파일을 우리의 post안에 포함시키시면 됩니다.---layout: postcurrent: postcover:  assets/built/images/python-logo.pngnavigation: Truetitle: Python 강좌(1) - Python 기본 date: 2018-09-27 16:40:00tags: [python]class: post-templatesubclass: 'post tag-python'author: moon9342---{% include python-table-of-contents.html %}GitHub Page에 Blog 올리기Travis-CI에 대한 설정은 다른 포스트에서 살펴보기로 하고 여기서는 수동으로 결과 파일을 GitHub Repository (GitHub Page에 대한 Repository)에 올리는 것으로 설명합니다.(destination: ../[GitHubPage]/ 으로 설정되어 있다고 가정합니다.)이제 C:/[GitHubPage]/파일안의 내용을 GitHub Page에 Publishing하시면 됩니다.  먼저 GitHub에 접속해서 새로운 Repository를 생성합니다. 주의할 점은Repository의 이름을 (자신의 github id).github.io로 지정해야 합니다.  Git을 이용하여 방금 만든 C:/[GitHubPage]/ 안의 내용을 Repository에 push합니다.정상적으로 push가 진행되었다면 이제 https://(자신의 github id).github.io로 접속해서 블로그가 잘 개설이 되었는지 확인합니다.이 포스트에서는 Git과 GitHub에 대한 기본적인 사용법에 대해서는 다루지 않습니다. 해당 부분은 저의 다른 포스트나혹은 여기를 이용하여 살펴보시면될 듯 합니다.GitHub Page에 블로그가 잘 개설되었나요? 블로그가 잘 개설되었다면 이제 메뉴를 원하는 형식으로 바꾸고 새로운 내용의 post도 작성해서 블로그에 올리시면 됩니다. 새로운 내용을 만들고 포스팅 작업을 해 보세요.End.",
        "url": "/jekyll-struct"
    }
    ,
    
    "jekyll-start": {
        "title": "Jekyll 기반의 GitHub Page 생성(1) - 환경설정",
            "author": "moon9342",
            "category": "",
            "content": "Jekyll 기반의 GitHub Page 생성은 여러 절로 구성되어 있습니다.    Jekyll 기반의 GitHub Page 생성(1) - 환경설정    Jekyll 기반의 GitHub Page 생성(2) - 블로그 수정 &amp; Publishing    Jekyll 기반의 GitHub Page 생성(3) - 웹 폰트 설정    Jekyll 기반의 GitHub Page 생성(4) - rouge를 이용한 syntax highlighting    Jekyll 기반의 GitHub Page 생성(5) - lunr.js를 이용한 Search 기능 추가    Jekyll 기반의 GitHub Page 생성(6) - Google Search Console 활용    Jekyll 기반의 GitHub Page 생성(7) - GitHub Gist 활용    Jekyll 기반의 GitHub Page 생성(8) - Travis CI 활용(public Repository)    Jekyll 기반의 GitHub Page 생성(9) - Jekyll site regeneration 속도 향상시키기영상설명이번 영상은 Jekyll을 이용해 자신의 local 컴퓨터에 기본적인 블로그를 생성하는 방법에 대한 영상입니다.블로그를 생성하기 위한 Ruby 설치와 Jasper2 blog template 설치 및 실행하는 방법에 대해서 알아보겠습니다. Windows 10 환경으로 진행합니다.  Jekyll 기반의 GitHub Page 생성(1) - 환경설정 영상환경설정Jekyll을 이용해 GitHub Page에 기본적인 블로그를 생성하는 방법을 제가 사용하는 Jasper2 theme를 이용하여 생성하고 설정하는 방법에 대해서 알아보겠습니다. (Windows 10환경으로 진행합니다.)GitHub Page에서 Jekyll로 기본적 형태의 블로그를 개설하는 건 별로 어렵지않게 할 수 있습니다. 하지만 맘에 드는 테마를 수정해서 사용하려면 약간의 Front End 개발 지식이 필요합니다.제 블로그에서 사용하는 테마는 Jekyll Themes 에서 검색해 찾은 Jasper2라는 Theme입니다. Ghost라는 유명한 publishing platform의 Jekyll 버전인데 맘에 들어서 이것 저것 수정해서 사용하고 있습니다.(참고로 Jasper2는 MIT License 입니다.)초기 세팅부터 Travis-CI를 이용한 Build와 배포 자동화까지 천천히 설명해보도록 하죠.  Windows 환경은 조금 까다롭습니다. Ruby 때문에 그렇습니다. 먼저 컴퓨터의 계정 ID가 한글로 되어 있으면 여러 문제가 발생합니다.한글계정이라면 먼저 계정부터 영문으로 바꾸고 시작해야 합니다.아래의 그림처럼 컴퓨터의 계정이 영문으로 되어있는지 확인합니다.제일 먼저 해야하는 작업은 Ruby를 설치하는 것입니다.Ruby는 RubyInstaller for Windows 에서 받으시면 됩니다.사용할 버전은 2.6.6입니다. 다른 버전 사용할 경우 문제가 발생할 여지가 있습니다.다운로드 받은 Ruby를 설치합니다.이제 bundler를 설치합니다. bundler는 Ruby application 개발을 위한 일관된 환경을 제공합니다. 단편적 기능 중 하나는Ruby application이 사용하는 gem의 dependency를 관리하는 것입니다. 우리는 나중에 이 bundler를 이용하여 Jekyll을사용할 것이기 때문에 설치해야 합니다.  gem install bundler기본적인 준비과정은 끝났습니다.그 다음 과정은 우리가 사용할 Theme인 Jasper2를 다운받아서 원하는 폴더에 압축을 풀어줍니다. C:/blogmaker에 다음과 같은 형태로 압축을 풀어 저장했습니다.  여기서 주의해야 할 점은 폴더 이름에 공백이 포함되어 있으면 나중에 css빌드할 때 문제가 발생합니다. 즉, C:/blogmaker처럼 폴더는 소문자로 공백없이 생성합니다.command 창을 열어서 해당 폴더(C:/blogmaker)에서 실행해 필요한 gem을 설치합니다. 다음과 같이 실행합니다.  bundle install이제 다시 아래와 같은 명령을 이용하여 실행시킵니다.  bundle exec jekyll serve만약 호스트 IP와 Port를 변경해서 실행시킬려면 아래와 같이 실행시킵니다.  bundle exec jekyll serve --host HostIP --port PortNumberJekyll은 template처리를 위해 Liquid template을 사용합니다. template 처리를 거쳐 결과 파일이특정 폴더에 저장되고 로컬 웹 서버가 실행되어서 서비스해 주기 때문에 로컬에서 블로그를 확인해 볼 수 있습니다.build 과정을 거쳐 로컬 웹서버를 이용하여 웹 서비스까지 실행시켜주는 명령이라고 생각하시면 됩니다.아래와 같은 메시지가 출력되면서 로컬 웹 서버가 4000번 포트로 기동되고 http://localhost:4000/jasper2로 접속하면 테마페이지를 보실 수 있습니다.  일단 로컬에서 화면을 띄웠습니다. 이제 각 메뉴를 원하는 내용으로 바꾸고 이미지를 내 입맛에 맞게 수정하고 기타 등등의 기능들을 추가하면 될 듯 보입니다.End.",
        "url": "/jekyll-start"
    }
    ,
    
    "python-lecture-python-django-blog-project": {
        "title": "Python Django 웹 프레임워크(8) - Blog project 개발",
            "author": "moon9342",
            "category": "",
            "content": "Python 기초강의는 여러 절로 구성되어 있습니다.     Python 기초강의(1) - Introduction    Python 기초강의(2) - Python 기본    Python 기초강의(3) - Python 제어문    Python 기초강의(4) - Python function    Python 기초강의(5) - Python 연습문제(1)    Python 기초강의(6) - Python 객체지향    Python 기초강의(7) - Python Magic Function    Python 기초강의(8) - Python First Class    Python 기초강의(9) - Python Closure    Python 기초강의(10) - Python Decorator    Python 기초강의(11) - Python Generator    Python 기초강의(12) - Python Module    Python 기초강의(13) - Python Exception &amp; File    Python 기초강의(14) - Python 연습문제(2)    Python Django 웹 프레임워크(1) - introduction    Python Django 웹 프레임워크(2) - Poll project 개발(1)    Python Django 웹 프레임워크(3) - Poll project 개발(2)    Python Django 웹 프레임워크(4) - Poll project 개발(3)    Python Django 웹 프레임워크(5) - Poll project 개발(4)    Python Django 웹 프레임워크(6) - Poll project 개발(5)    Python Django 웹 프레임워크(7) - Django의 개발방식    Python Django 웹 프레임워크(8) - Blog project 개발    Blog project 개발Poll Project의 내용을 기반으로 이번에는 ModelForm을 이용한 CRUD 구현 및 Django에 Bootstrap4를 적용해 보도록 하겠습니다.project 생성새로운 project blog를 생성합니다.  C:/python-Django&gt; django-admin startproject blogproject와 application을 모두 포함하는 폴더 이름을 MyBlog로 변경합니다.  C:/python-Django&gt; move blog MyBlogworking directory를 MyBlog 폴더로 변경합니다.  C:/python-Django&gt; cd MyBlogposts application을 생성합니다.  C:/python-Django/MyBlog&gt; python manage.py startapp posts이후부터는 PyCharm을 이용해 작업을 진행합니다.project 환경설정환경설정을 위해 project 폴더의 settings.py파일을 수정합니다. 기본적인 DEBUG=TRUE 설정에 따른 ALLOWED_HOSTS에 대한 내용을다음과 같이 수정합니다.ALLOWED_HOSTS = ['localhost', '127.0.0.1']INSTALLED_APPS 부분에 posts application을 등록합니다.INSTALLED_APPS = [    'django.contrib.admin',    'django.contrib.auth',    'django.contrib.contenttypes',    'django.contrib.sessions',    'django.contrib.messages',    'django.contrib.staticfiles',    'posts.apps.PostsConfig']blog project 폴더안에 templates 폴더를 생성한 후 TEMPLATES 부분을 수정하여 해당 templates 폴더를 기본 Template 경로로 설정합니다.TEMPLATES = [    {        'BACKEND': 'django.template.backends.django.DjangoTemplates',        'DIRS': [os.path.join(BASE_DIR, 'blog', 'templates')],        'APP_DIRS': True,        'OPTIONS': {            'context_processors': [                'django.template.context_processors.debug',                'django.template.context_processors.request',                'django.contrib.auth.context_processors.auth',                'django.contrib.messages.context_processors.messages',            ],        },    },]TIME_ZONE 부분은 세계표준시에서 한국시간으로 변경합니다.TIME_ZONE = 'Asia/Seoul'Static File(CSS, JavaScript, Image)을 사용하기 위해서 Static File 폴더를 지정하고 폴더를 BASE_DIR 하단에 생성합니다.STATIC_URL = '/static/'STATICFILES_DIRS = [    os.path.join(BASE_DIR, 'static')]기본 Table 생성기본 테이블을 생성하기 위해 다음의 명령을 수행합니다.  C:/python-Django/MyBlog&gt; python manage.py migrate관리자 계정 생성관리자 page에 접속하기 위한 계정을 생성합니다.  C:/python-Django/MyBlog&gt; python manage.py createsuperuser서버 기동project가 정상적으로 생성되었는지 확인하기 위해 내장서버를 이용해 deploy합니다.  C:/python-Django/MyBlog&gt; python manage.py runserverAdmin Page 접속 확인http://localhost:8000/admin으로 접속 후 관리자 계정으로 로그인Model 생성Model을 생성하기 위해 posts application 내의 models.py 파일에 다음과 같은 내용을입력합니다.class Post(models.Model):    author = models.CharField('작성자', max_length=20)    contents = models.CharField('글내용', max_length=100)    def __str__(self):        return self.contentsAdmin Page에 반영하기 위해서 posts application 내의 admin.py에 class를 등록합니다.from django.contrib import adminfrom posts.models import Postadmin.site.register(Post)Database 변경사항을 반영하기 위해서 migration 초안을 생성하고 설정된 Schema를 Database에 실제로 적용해야 합니다.마이그레이션 초안을 생성하기 위해서 다음과 같이 실행합니다.  C:/python-Django/MyBlog&gt; python manage.py makemigrations설정된 Schema를 Database에 적용하기 위해서 다음과 같이 실행합니다.  C:/python-Django/MyBlog&gt; python manage.py migrateURL 경로 설정blog project의 urls.py파일을 다음과 같이 수정하여 계층적으로 URL을 관리하기 위한 설정을합니다.# blog/urls.py from django.contrib import adminfrom django.urls import path, includefrom django.conf.urls import urlfrom django.views.generic.base import TemplateViewurlpatterns = [    url(r'^$', TemplateView.as_view(template_name='index.html'),        name='home'),    path('admin/', admin.site.urls),    path('posts/', include('posts.urls'))]/posts/ 경로로 들어오는 모든 request를 처리하기 위해서 posts application의 urls.py파일을 다음과 같이 작성합니다.# posts/urls.py from django.urls import pathfrom . import viewsapp_name = 'posts'  urlpatterns = [    path('list/', views.p_list, name='list'),]약간의 코드를 추가해 http://localhost:8000에 대한 Homepage설정을 추가했습니다. blog project폴더안에 templates 폴더 안에 index.html을 위치시킵니다. Bootstrap Example 중 하나를 이용해서처리했습니다.&lt;!doctype html&gt;&lt;html lang=\"en\"&gt;  &lt;head&gt;    &lt;meta charset=\"utf-8\"&gt;    &lt;title&gt;Blog Project&lt;/title&gt;    &lt;!-- Bootstrap core CSS --&gt;    &lt;link rel=\"stylesheet\"           href=\"https://stackpath.bootstrapcdn.com/bootstrap/4.5.0/css/bootstrap.min.css\"           integrity=\"sha384-9aIt2nRpC12Uk9gS9baDl411NQApFmC26EwAOH8WgZl5MYYxFfc+NcPb1dKGj7Sk\"           crossorigin=\"anonymous\"&gt;    &lt;!-- Custom styles for this template --&gt;    &lt;link href=\"/static/css/cover.css\" rel=\"stylesheet\"&gt;  &lt;/head&gt;  &lt;body class=\"text-center\"&gt;    &lt;div class=\"cover-container d-flex w-100 h-100 p-3 mx-auto flex-column\"&gt;      &lt;header class=\"masthead mb-auto\"&gt;        &lt;div class=\"inner\"&gt;          &lt;h3 class=\"masthead-brand\"&gt;My Blog&lt;/h3&gt;        &lt;/div&gt;      &lt;/header&gt;      &lt;main role=\"main\" class=\"inner cover\"&gt;        &lt;h1 class=\"cover-heading\"&gt;Blog Project&lt;/h1&gt;        &lt;p class=\"lead\"&gt;Django Framework&lt;/p&gt;        &lt;p class=\"lead\"&gt;          &lt;a href=\"/posts/list/\" class=\"btn btn-lg btn-secondary\"&gt;Enter BBS&lt;/a&gt;        &lt;/p&gt;      &lt;/main&gt;      &lt;footer class=\"mastfoot mt-auto\"&gt;        &lt;div class=\"inner\"&gt;          &lt;p&gt;Copyright 2020&lt;/p&gt;        &lt;/div&gt;      &lt;/footer&gt;    &lt;/div&gt;  &lt;/body&gt;&lt;/html&gt;기본 Template 설정하나의 html 파일을 생성해 모든 template 파일의 base html로 사용합니다.blog project folder 하단의 templates 폴더안에 기본적인 형태로 base.html을 생성합니다.Django에 Bootstrap4을 적용하기 위해서는 django-bootstrap4를 설치해야 합니다. 아래의 명령어로package를 설치합니다.  pip install django-bootstrap4설치가 완료된 다음에  blog project 폴더안의 settings.py 내 INSTALLED_APPS을 다음과 같이 수정하여 bootstrap application을 추가합니다.INSTALLED_APPS = [    'django.contrib.admin',    'django.contrib.auth',    'django.contrib.contenttypes',    'django.contrib.sessions',    'django.contrib.messages',    'django.contrib.staticfiles',    'posts.apps.PostsConfig',    'bootstrap4',]이후에 기본적으로 생성된 base.html에 Bootstrap을 사용하기 위해서 CDN을 설정합니다. 해당 CDN은 Bootstrap 홈페이지에서 copy해서 사용합니다.아래와 같이 base.html을 수정합니다.&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt;    &lt;meta charset=\"UTF-8\"&gt;    &lt;title&gt;Title&lt;/title&gt;    &lt;link rel=\"stylesheet\" href=\"https://stackpath.bootstrapcdn.com/bootstrap/4.5.0/css/bootstrap.min.css\" integrity=\"sha384-9aIt2nRpC12Uk9gS9baDl411NQApFmC26EwAOH8WgZl5MYYxFfc+NcPb1dKGj7Sk\" crossorigin=\"anonymous\"&gt;    &lt;script src=\"https://code.jquery.com/jquery-3.5.1.slim.min.js\" integrity=\"sha384-DfXdz2htPH0lsSSs5nCTpuj/zy4C+OGpamoFVy38MVBnE+IbbVYUew+OrCXaRkfj\" crossorigin=\"anonymous\"&gt;&lt;/script&gt;    &lt;script src=\"https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js\" integrity=\"sha384-Q6E9RHvbIyZFJoft+2mJbHaEWldlvI9IOYy5n3zV9zzTtmI3UksdQRVvoxMfooAo\" crossorigin=\"anonymous\"&gt;&lt;/script&gt;    &lt;script src=\"https://stackpath.bootstrapcdn.com/bootstrap/4.5.0/js/bootstrap.min.js\" integrity=\"sha384-OgVRvuATP1z7JjHLkuOU7Xw704+h835Lr+6QL9UvYjZE3Ipu6Tp75j7Bh/kR0JKI\" crossorigin=\"anonymous\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;    {% block container %}    {% endblock %}&lt;/body&gt;&lt;/html&gt;Model Form 생성Model Form을 이용해서 model과 fields를 지정하면 Model Form이 자동으로 폼 필드를 생성해주기 때문에Form 처리를 상당히 쉽게 처리할 수 있습니다.어떤 Model을 기반으로 폼을 작성할 것인지를 Meta.model 에 지정하고 fields는 Model class의 field 중 일부만 폼 클래스에서 사용하고자 할 때 지정하는 옵션입니다.posts application 폴더 내에 forms.py 파일을 생성한 후 아래의 코드와 같이 Model Form class를 생성합니다.from django import formsfrom .models import Postclass PostForm(forms.ModelForm):    class Meta:        model = Post        fields = ['author', 'contents']list 페이지 작성posts application의 views.py의 내용을 수정합니다.from django.shortcuts import renderfrom posts.models import Postdef p_list(request):    posts = Post.objects.all().order_by('-id')    return render(request, 'list.html', {'posts': posts})list.html 파일을 Bootstrap을 이용해서 수정합니다.{% extends 'base.html' %}{% block container %}&lt;script src=\"/static/js/posts.js\"&gt;&lt;/script&gt;&lt;div class=\"container\"&gt;    &lt;h1&gt;Bulletin Board System(BBS)&lt;/h1&gt;    &lt;button type=\"button\" class=\"btn btn-primary\"    onclick=\"new_post()\"&gt;새글 작성&lt;/button&gt;    &lt;div class=\"m-1\"&gt;&lt;/div&gt;    &lt;table class=\"table table-hover\"&gt;      &lt;thead class=\"thead-dark\"&gt;        &lt;tr&gt;          &lt;th scope=\"col\"&gt;#&lt;/th&gt;          &lt;th scope=\"col\"&gt;글작성자&lt;/th&gt;          &lt;th scope=\"col\"&gt;글내용&lt;/th&gt;          &lt;th scope=\"col\"&gt;수정&lt;/th&gt;          &lt;th scope=\"col\"&gt;삭제&lt;/th&gt;        &lt;/tr&gt;      &lt;/thead&gt;      &lt;tbody&gt;        {% for post in posts %}        &lt;tr&gt;          &lt;th scope=\"row\"&gt;{{ post.id }}&lt;/th&gt;          &lt;td&gt;{{ post.author }}&lt;/td&gt;          &lt;td&gt;{{ post.contents }}&lt;/td&gt;          &lt;td&gt;&lt;/td&gt;          &lt;td&gt;&lt;/td&gt;        &lt;/tr&gt;        {% endfor %}      &lt;/tbody&gt;    &lt;/table&gt;&lt;/div&gt;{% endblock %}create 페이지 작성views.py 내용을 수정합니다.POST방식일때와 GET방식일때를 구분하여 ModelForm을 create.html로 전달합니다.POST방식일 경우는 ModelForm객체에 데이터가 담겨서 저장되어야 하는 경우이며 GET방식인경우는 사용자에게 빈 양식을 보여주기 위해서 사용됩니다.from django.shortcuts import render, redirectfrom posts.models import Postfrom posts.forms import PostFormdef p_list(request):    posts = Post.objects.all().order_by('-id')    return render(request, 'list.html', {'posts': posts})def p_create(request):    # POST 방식    if request.method == 'POST':        post_form = PostForm(request.POST)                if post_form.is_valid():            post_form.save()            return redirect('posts:list')    # GET 방식    else:        post_form = PostForm()    return render(request, 'create.html', {'post_form': post_form})create.html 파일을 Bootstrap을 이용해서 수정합니다.{% extends 'base.html' %}{% load bootstrap4 %}{% block container %}&lt;div class=\"container\"&gt;    &lt;h1&gt;New Post&lt;/h1&gt;    &lt;form method=\"post\"&gt;        {% csrf_token %}         &lt;!-- {{ post_form }}--&gt;        {% bootstrap_form post_form %}        &lt;button type=\"submit\" class=\"btn btn-primary\"&gt;등록&lt;/button&gt;    &lt;/form&gt;&lt;/div&gt;{% endblock %}delete 기능 작성이번에는 list 화면에서 삭제버튼을 붙여서 delete 기능을 구현해 보겠습니다.urls.py 를 수정합니다.from django.urls import pathfrom . import viewsapp_name = 'posts'urlpatterns = [    path('list/', views.p_list, name='list'),    path('create/', views.p_create, name='create'),    path('&lt;int:post_id&gt;/delete/', views.p_delete, name='delete'),]views.py를 수정합니다.from django.shortcuts import render, redirectfrom posts.models import Postfrom posts.forms import PostFormdef p_list(request):    posts = Post.objects.all().order_by('-id')    return render(request, 'list.html', {'posts': posts})def p_create(request):    # POST 방식    if request.method == 'POST':        post_form = PostForm(request.POST)        if post_form.is_valid():            post_form.save()            return redirect('posts:list')    # GET 방식    else:        post_form = PostForm()    return render(request, 'create.html', {'post_form': post_form})def p_delete(request, post_id):    post = Post.objects.get(id=post_id)    post.delete()    return redirect('posts:list')list.html을 수정해서 버튼을 붙입니다.{% extends 'base.html' %}{% block container %}&lt;script src=\"/static/js/posts.js\"&gt;&lt;/script&gt;&lt;div class=\"container\"&gt;    &lt;h1&gt;Bulletin Board System(BBS)&lt;/h1&gt;    &lt;button type=\"button\" class=\"btn btn-primary\"    onclick=\"new_post()\"&gt;새글 작성&lt;/button&gt;    &lt;div class=\"m-1\"&gt;&lt;/div&gt;    &lt;table class=\"table table-hover\"&gt;      &lt;thead class=\"thead-dark\"&gt;        &lt;tr&gt;          &lt;th scope=\"col\"&gt;#&lt;/th&gt;          &lt;th scope=\"col\"&gt;글작성자&lt;/th&gt;          &lt;th scope=\"col\"&gt;글내용&lt;/th&gt;          &lt;th scope=\"col\"&gt;수정&lt;/th&gt;          &lt;th scope=\"col\"&gt;삭제&lt;/th&gt;        &lt;/tr&gt;      &lt;/thead&gt;      &lt;tbody&gt;        {% for post in posts %}        &lt;tr&gt;          &lt;th scope=\"row\"&gt;{{ post.id }}&lt;/th&gt;          &lt;td&gt;{{ post.author }}&lt;/td&gt;          &lt;td&gt;{{ post.contents }}&lt;/td&gt;          &lt;td&gt;&lt;/td&gt;          &lt;td&gt;&lt;a href=\"{% url 'posts:delete' post.id %}\" class=\"btn btn-danger\"&gt;삭제&lt;/a&gt;&lt;/td&gt;        &lt;/tr&gt;        {% endfor %}      &lt;/tbody&gt;    &lt;/table&gt;&lt;/div&gt;{% endblock %}update 기능 작성마지막으로 수정기능을 구현해보겠습니다.urls.py 파일을 수정합니다.from django.urls import pathfrom . import viewsapp_name = 'posts'urlpatterns = [    path('list/', views.p_list, name='list'),    path('create/', views.p_create, name='create'),    path('&lt;int:post_id&gt;/delete/', views.p_delete, name='delete'),    path('&lt;int:post_id&gt;/update/', views.p_update, name='update'),]views.py 파일을 수정합니다.from django.shortcuts import render, redirect, get_object_or_404from posts.models import Postfrom posts.forms import PostFormdef p_list(request):    posts = Post.objects.all().order_by('-id')    return render(request, 'list.html', {'posts': posts})def p_create(request):    # POST 방식    if request.method == 'POST':        post_form = PostForm(request.POST)        if post_form.is_valid():            post_form.save()            return redirect('posts:list')    # GET 방식    else:        post_form = PostForm()    return render(request, 'create.html', {'post_form': post_form})def p_delete(request, post_id):    post = Post.objects.get(id=post_id)    post.delete()    return redirect('posts:list')def p_update(request, post_id):    post = get_object_or_404(Post, id=post_id)    if request.method == 'POST':        postform = PostForm(request.POST, instance=post)        if postform.is_valid():            postform.save()            return redirect('posts:list')    else:        postform = PostForm(instance=post)        return render(request, 'create.html', {'post_form': postform})마지막으로 list.html 파일을 수정하여 수정버튼을 붙이면 됩니다.End.Python 강좌는 아래의 책과 사이트를 참조했습니다.    조금 더 자세한 사항을 알고 싶으시면 해당 사이트를 방문하세요!!    Python Official HomePage    점프 투 파이썬 - 이지스 퍼블리싱    전문가를 위한 파이썬(Fluent Python) - 한빛미디어    파이썬 웹 프로그래밍 - 한빛미디어    이미지 출처 : Designed by rawpixel.com / Freepik",
        "url": "/python-lecture-python-django-blog-project"
    }
    ,
    
    "python-lecture-python-django-mvt": {
        "title": "Python Django 웹 프레임워크(7) - Django의 개발방식",
            "author": "moon9342",
            "category": "",
            "content": "Python 기초강의는 여러 절로 구성되어 있습니다.     Python 기초강의(1) - Introduction    Python 기초강의(2) - Python 기본    Python 기초강의(3) - Python 제어문    Python 기초강의(4) - Python function    Python 기초강의(5) - Python 연습문제(1)    Python 기초강의(6) - Python 객체지향    Python 기초강의(7) - Python Magic Function    Python 기초강의(8) - Python First Class    Python 기초강의(9) - Python Closure    Python 기초강의(10) - Python Decorator    Python 기초강의(11) - Python Generator    Python 기초강의(12) - Python Module    Python 기초강의(13) - Python Exception &amp; File    Python 기초강의(14) - Python 연습문제(2)    Python Django 웹 프레임워크(1) - introduction    Python Django 웹 프레임워크(2) - Poll project 개발(1)    Python Django 웹 프레임워크(3) - Poll project 개발(2)    Python Django 웹 프레임워크(4) - Poll project 개발(3)    Python Django 웹 프레임워크(5) - Poll project 개발(4)    Python Django 웹 프레임워크(6) - Poll project 개발(5)    Python Django 웹 프레임워크(7) - Django의 개발방식    Python Django 웹 프레임워크(8) - Blog project 개발    Django의 개발방식간단한 웹 프로그램을 작성해봤으니 이제 우리가 작업한 내용을 간단하게 정리해 보도록 하겠습니다.한가지 기억해야 할 점은 다른 언어(예를 들면 Java Servlet)에서는 전체 프로그램을 Web Application이라고 부릅니다. 우리가 작업한 Poll Project를 Web Application이라고한다는 것이죠.하지만 Django에서는 약간 다르게 표현합니다. Django에서는 전체 프로그램을 Project라고표현합니다. 그리고 모듈화된 단위 프로그램들을 application 이라고 표현합니다. 즉, application의 집합이 project가 되는 개념입니다.Django는 이런 application을 개발할 때 기본적으로 MVT pattern에 따라서 개발합니다.MVT Pattern일반적으로 application을 개발할 때 흔히 사용하는 구조는 MVC pattern입니다. MVC pattern은 프로그램의 구성 요소를 Model-View-Controller로 구분해 한 요소가 다른 요소에 미치는 영향을 최소화 하도록 설계하는 방식을 의미합니다.Django도 이런 MVC pattern 개념을 그대로 받아들여서 사용합니다. 단, MVC pattern에서의View를 Template으로 Controller를 View라고 표현하며 이를 MVT pattern이라고 합니다.장고의 MVT pattern을 그림을 묘사하면 아래와 같습니다.웹 클라이언트로부터 요청을 받고, Django에서 MVT pattern에 따라서 처리하는 과정을 살펴보면다음과 같습니다.  클라이언트로부터 요청을 받으면 URLConf를 이용하여 URL을 분석합니다.  URL 분석 결과를 통해 해당 URL에 대한 처리를 담당한 View를 결정합니다.  View는 자신의 로직을 실행하면서 데이터베이스 처리가 필요하면 Model을 통해 처리합니다.  View는 로직처리가 끝나면 Template을 사용하여 클라이언트에게 전송할 HTML 파일을 생성합니다.  View는 최종결과로 HTML 파일을 클라이언트에게 전송합니다.ModelModel은 사용될 데이터에 대한 정의를 담고 있는 Django의 class입니다. Django는 ORM 기법을사용하여 데이터베이스를 class로 mapping해서 사용할 수 있습니다. 쉽게 말하면 하나의 Model class는하나의 Table에 mapping되고 Model class의 속성은 Table의 column에 mapping됩니다.장점은 무엇일까요?ORM을 이용하면 Database에 대한 처리를 SQL없이 class를 다루는 것처럼 할 수 있어서 편리합니다.또한 Database Engine을 바꾸어도 ORM을 통한 API는 변경할 필요가 없습니다.간단한 예로 아래의 Model class를 예로 들어보죠from django.db import modelsclass Person(models.Model):    first_name = models.CharField(max_length=30)    last_name = models.CharField(max_length=30)위의 Model class의 정의는 내부적으로 다음의 SQL 명령을 사용하여 Database Table을생성하게 됩니다.CREATE TABLE myapp_person (    \"id\" serial NOT NULL PRIMARY KEY,    \"first_name\" varchar(30) NOT NULL,    \"last_name\" varchar(30) NOT NULL);      위에서 보듯이 Table명은 application명과 Model class명을 _ 로 연결하고 모두 소문자로표현합니다. 다른 이름으로 직접 지정할 수 도 있습니다.        PRIMARY KEY는 Person class에서 지정하지 않아도 Django에서 자동으로 부여합니다. 이 부분역시 직접 지정할 수 도 있습니다.  URLConf클라이언트로부터 요청을 받으면 Django는 가장 먼저 요청에 들어 있는 URL을 분석합니다. 즉,URL이 urls.py 파일에 정의된 URL pattern과 매칭되는지를 분석한다는 거죠.Python의 URL 정의 방식을 Elegant URL이라고 부릅니다. 기존 다른 언어의 URL 정의방식보다 쉽고 직관적이기 때문입니다.URL을 정의하기 위해서는 urls.py 파일에 URL과 View 함수를 매핑하는 코드를 작성해야 합니다.이를 URLConf 라고 합니다. 아래는 예제로 작성된 urls.py입니다.from django.urls import pathfrom . import viewsurlpatterns = [    path('articles/2003/', views.special_case_2003),    path('articles/&lt;int:year&gt;/', views.year_archive),    path('articles/&lt;int:year&gt;/&lt;int:month&gt;/', views.month_archive),    path('articles/&lt;int:year&gt;/&lt;int:month&gt;/&lt;slug:slug&gt;/', views.article_detail),]웹 클라이언트가 웹 서버에 Request를 보낼 때, Django에서 URL을 분석하는 순서를 보면다음과 같습니다.  settings.py 파일의 ROOT_URLCONF 항목을 읽어서 최상위 URLConf 파일의 위치를 알아냅니다.  URLConf를 로딩하여 URL list를 검사합니다.  검사 순서는 위에서부터 순서대로 URL list를 검사하며 URL pattern이 매치되면 검사를 종료합니다.  매치된 View 함수를 호출합니다. 호출 시 HttpRequest객체와 URL에서 추출된 데이터를 View 함수에인자로 넘겨줍니다.  URL list 끝가지 검사했는데도 매칭에 실패하면 에러를 처리하는 View 함수를 호출합니다.여기서 주의해야 할 부분은 &lt;int:month&gt; 처럼 꺽쇠를 사용하는 부분입니다. 이는 URL 에서 일부데이터를 추출하기 위한 것으로 &lt;type:name&gt; 형태로 사용합니다. 만약 요청 URL이/articles/2020/이라면 호출되는 View 함수는 view.year_archive(request,year=2020) 처럼호출합니다.이런 꺽쇠 부분을 Django에서는 Path Converter라고 부릅니다. 여기에서 사용되는 타입은 str, int, slug, path 등이 있습니다.  str : /를 제외한 모든 문자열과 매치됩니다. 타입이 지정되지 않으면 default로 str입니다.  int : 0 또는 양의 정수와 매치됩니다.  slug : slug형식의 문자열과 매치됩니다. (ASCII, 숫자, 하이픈, 밑줄)  path : /를 포함한 모든 문자열과 매치됩니다. 이는 URL의 일부가 아니라 전체를 추출하고자할때 사용됩니다.또한 Regular Expression(정규 표현식)을 사용해서 URL을 좀 더 세밀하게 표현 할 수 도 있습니다.이 부분은 책이나 다른 문서를 참조하세요~ViewView는 일반적으로 Request를 받아서 Database 처리 등 로직에 맞는 처리를 하고, 그 결과데이터를 HTML로 변환하기 위해서 Template 처리를 한 후 최종 HTML로 된 응답 데이터를 웹 클라이언트에게 반환하는 역할을 수행합니다.일반적으로 views.py 파일에 작성되며 다른 파일에 작성해도 상관은 없습니다.간단한 예로 현재의 날짜와 시간을 HTML로 반환해주는 View 함수는 다음과 같습니다.from django.http import HttpResponseimport datetimedef current_datetime(request):    now = datatime.datetime.now()    html = \"&lt;html&gt;&lt;body&gt;현재 시각은 : %s&lt;/body&gt;&lt;/html&gt;\" % now    return httpResponse(html)만약 Error를 반환하고 싶다면 아래처럼 HttpResponseNotFound와 같은에러 응답 객체를 반환하면 됩니다.return HttpResponseNotFound(\"&lt;h1&gt;페이지를 찾을 수 없습니다.&lt;/h1&gt;\")TemplateDjango가 클라이언트에게 반환하는 최종 응답은 HTML text입니다. 개발자가응답에 사용할 html 파일을 작성하면, 장고는 이를 해석해서 데이터를 적용해최종 HTML text를 생성하고 이를 클라이언트에게 보내주게 됩니다.이런 과정에서 개발자가 작성하는 html 파일을 Template 파일이라고 부릅니다.Template file은 .html 확장자를 가지며 Django의 Template 시스템 문법에 맞게작성합니다. 조심해야 할 사항은 이 Template 파일을 적절한 디렉토리에 위치시켜야한다는 점 입니다.Django에서 Template 파일을 찾을 때 TEMPLATE_DIRS 와 INSTALLED_APPS에서 지정된application의 디렉토리를 검색합니다. 이 항목들은 settings.py에 지정되어 있습니다.End.Python 강좌는 아래의 책과 사이트를 참조했습니다.    조금 더 자세한 사항을 알고 싶으시면 해당 사이트를 방문하세요!!    Python Official HomePage    점프 투 파이썬 - 이지스 퍼블리싱    전문가를 위한 파이썬(Fluent Python) - 한빛미디어    파이썬 웹 프로그래밍 - 한빛미디어    이미지 출처 : Designed by rawpixel.com / Freepik",
        "url": "/python-lecture-python-django-mvt"
    }
    ,
    
    "python-lecture-python-django-poll-project-5": {
        "title": "Python Django 웹 프레임워크(6) - Poll project 개발(5)",
            "author": "moon9342",
            "category": "",
            "content": "Python 기초강의는 여러 절로 구성되어 있습니다.     Python 기초강의(1) - Introduction    Python 기초강의(2) - Python 기본    Python 기초강의(3) - Python 제어문    Python 기초강의(4) - Python function    Python 기초강의(5) - Python 연습문제(1)    Python 기초강의(6) - Python 객체지향    Python 기초강의(7) - Python Magic Function    Python 기초강의(8) - Python First Class    Python 기초강의(9) - Python Closure    Python 기초강의(10) - Python Decorator    Python 기초강의(11) - Python Generator    Python 기초강의(12) - Python Module    Python 기초강의(13) - Python Exception &amp; File    Python 기초강의(14) - Python 연습문제(2)    Python Django 웹 프레임워크(1) - introduction    Python Django 웹 프레임워크(2) - Poll project 개발(1)    Python Django 웹 프레임워크(3) - Poll project 개발(2)    Python Django 웹 프레임워크(4) - Poll project 개발(3)    Python Django 웹 프레임워크(5) - Poll project 개발(4)    Python Django 웹 프레임워크(6) - Poll project 개발(5)    Python Django 웹 프레임워크(7) - Django의 개발방식    Python Django 웹 프레임워크(8) - Blog project 개발    마지막 화면 작성아래의 그림은 우리의 Poll Project의 전체 처리 흐름을 도식화 한 것이죠.이전 절에서 첫화면에 있는 3개의 질문 중 하나를 선택했을 때, 질문에 대한 답변 항목을보여주고 투표하도록 하는 화면을 작성해 보았습니다.이번에는 답변항목을 선택한 후 Vote 버튼을 클릭했을 때 처리되는 부분에 과정과 최종화면을 작성해 보겠습니다.먼저 View 함수인 vote() 부터 알아봐야 할 듯 합니다.View 함수인 vote()의 호출과 연관된 URL은 detail.html안의 form tag의 action에서나타납니다.&lt;form action=\"{% url 'polls:vote' question.id %}\"          method=\"post\"&gt;이 부분은 결국 polls/urls.py 파일안에 다음과 같은 부분과 mapping되게 됩니다.app_name = \"polls\"urlpatterns = [    path('', views.index, name='index'),    path('&lt;int:question_id&gt;/', views.detail, name='detail'),    path('&lt;int:question_id&gt;/vote/', views.vote, name='vote'),    path('&lt;int:question_id&gt;/results/', views.results, name='results'),]그럼 vote() 함수를 작성해 보도록 하죠.from django.shortcuts import render, get_object_or_404from polls.models import Question, Choicefrom django.http import HttpResponseRedirect, HttpResponsefrom django.urls import reversedef vote(request,question_id):    question = get_object_or_404(Question, pk=question_id)    try:        selected_choice = question.choice_set.get(pk=request.POST['choice'])    except (KeyError, Choice.DoesNotExist):        return render(request, 'polls/detail.html', {            'question': question,            'error_message': \"아무것도 선택하지 않았어요!!\"        })    else:        selected_choice.votes += 1        selected_choice.save()        return HttpResponseRedirect(reverse('polls:results', args=(question.id,)))이번에도 상당히 복잡할 듯 보이네요. 기억해야 하는 부분들을 하나씩 살펴보겠습니다.      이번에는 redirect 라는 기능이 필요합니다. 이를 위해 HttpResponseRedirect를import 합니다.        url 처리를 위해 reverse() 함수를 역시 import 처리 합니다.        vote() 함수의 request 객체는 필수 인자이고 detail() 처럼 question_id 인자를 더받습니다.        get_object_or_404() 단축함수를 사용하였고 이번에는 Choice Table을 검색하는용도로 사용되고 있습니다. 검색 조건은 pk=request.POST['choice']로 되어 있네요.request.POST는 form의 데이터를 담고 있는 객체입니다. request.POST['choice']는form의 데이터 중 key값이 choice에 해당하는 값인 choice.id를 의미하겠네요.        만약 choice라는 key가 request.POST에 존재하지 않으면 KeyError exception이발생합니다. 또한 검색 조건에 맞는 객체가 없으면 Choice.DoesNotExist exception이발생합니다.        만약 exception이 발생하면 render() 함수를 이용해 question과 error_message 변수를detail.html로 전달합니다. 사용자에게 질문 항목을 다시 보여주기 위함이죠.        exception이 발생하지 않으면 Choice 객체의 votes 속성의 값을 1증가시킵니다. 그리고변경사항을 Choice Table에 적용하게 됩니다.        주의해야 할 점은 이번에 vote()함수가 반환하는 객체가 HttpResponse가 아닌 HttpResponseRedirect 라는 것입니다. HttpResponseRedirect 객체는 redirect할 URL을인자로 가지며 reverse() 함수를 이용하여 생성합니다. 이 reverse() 함수는 URL pattern으로부터URL string을 구하기 위해서 사용합니다. 당연히 URLConf에 이미 정의된 URL pattern을 활용해서URL string을 추출하게 됩니다.  View 함수 results()와 Template 작성View 함수인 vote() 함수의 redirect로 results() 함수가 호출되게 됩니다. 정확하게는서버로 부터 redirect 하라는 내용을 결과로 받은 클라이언트 웹 브라우져가 redirect URL로다시 요청을 보내는 것이죠.이번에는 먼저 results() 함수를 작성한 후 결과를 보여주는 result.html Template 파일을 작성하도록하겠습니다.아래와 같이 results() 함수를 작성합니다.def results(request, question_id):    question = get_object_or_404(Question, pk=question_id)    return render(request, 'polls/results.html', {        'question': question    })앞에서 다 설명했던 부분들이니 바로 results.html 파일을 작성하도록 하겠습니다. &lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt;    &lt;meta charset=\"UTF-8\"&gt;    &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;h1&gt;{{ question.question_text }}&lt;/h1&gt;    &lt;ul&gt;    {% for choice in question.choice_set.all %}        &lt;li&gt;{{ choice.choice_text }} - {{ choice.votes }} vote{{ choice.votes|pluralize }}&lt;/li&gt;    {% endfor %}    &lt;/ul&gt;    &lt;a href=\"{% url 'polls:detail' question.id %}\"&gt;다시 투표&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;음.. 대부분의 내용은 이제 어느정도 이해가 갈 듯 합니다. 한가지 특이한 코드가 있는데choice.votes|pluralize입니다. choice.votes의 값에 따라서 복수 접미사(s)를붙여주는 역할을 합니다.이제 모든 작업을 완료했습니다. 서버를 기동하고 /polls로 접속해서 잘 동작하는지확인해보도록 하죠.End.Python 강좌는 아래의 책과 사이트를 참조했습니다.    조금 더 자세한 사항을 알고 싶으시면 해당 사이트를 방문하세요!!    Python Official HomePage    점프 투 파이썬 - 이지스 퍼블리싱    전문가를 위한 파이썬(Fluent Python) - 한빛미디어    파이썬 웹 프로그래밍 - 한빛미디어    이미지 출처 : Designed by rawpixel.com / Freepik",
        "url": "/python-lecture-python-django-poll-project-5"
    }
    ,
    
    "python-lecture-python-django-poll-project-4": {
        "title": "Python Django 웹 프레임워크(5) - Poll project 개발(4)",
            "author": "moon9342",
            "category": "",
            "content": "Python 기초강의는 여러 절로 구성되어 있습니다.     Python 기초강의(1) - Introduction    Python 기초강의(2) - Python 기본    Python 기초강의(3) - Python 제어문    Python 기초강의(4) - Python function    Python 기초강의(5) - Python 연습문제(1)    Python 기초강의(6) - Python 객체지향    Python 기초강의(7) - Python Magic Function    Python 기초강의(8) - Python First Class    Python 기초강의(9) - Python Closure    Python 기초강의(10) - Python Decorator    Python 기초강의(11) - Python Generator    Python 기초강의(12) - Python Module    Python 기초강의(13) - Python Exception &amp; File    Python 기초강의(14) - Python 연습문제(2)    Python Django 웹 프레임워크(1) - introduction    Python Django 웹 프레임워크(2) - Poll project 개발(1)    Python Django 웹 프레임워크(3) - Poll project 개발(2)    Python Django 웹 프레임워크(4) - Poll project 개발(3)    Python Django 웹 프레임워크(5) - Poll project 개발(4)    Python Django 웹 프레임워크(6) - Poll project 개발(5)    Python Django 웹 프레임워크(7) - Django의 개발방식    Python Django 웹 프레임워크(8) - Blog project 개발    두번째 화면 작성아래의 그림은 우리의 Poll Project의 전체 처리 흐름을 도식화 한 것이죠.이전 절에서 /polls/ URL로 접속했을 때 View 함수와 Template 파일을 작성해서 첫 화면을 browser에 출력해보았습니다.이번에는 첫화면에 있는 3개의 질문 중 하나를 선택했을 때, 질문에 대한 답변 항목을보여주고 투표하도록 하는 화면을 작성해 보도록 하겠습니다.먼저 Template 화면부터 생성하면서 어떠한 데이터가 View 함수로부터 넘어오면 되는지를생각해보면 될 듯 합니다.Template 파일의 이름은 detail.html 이고 아래와 같이 입력합니다.&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt;    &lt;meta charset=\"UTF-8\"&gt;    &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;h1&gt;{{ question.question_text }}&lt;/h1&gt;    {% if error_message %}    &lt;p&gt;&lt;strong&gt;{{ error_message }}&lt;/strong&gt;&lt;/p&gt;    {% endif %}    &lt;form action=\"{% url 'polls:vote' question.id %}\"          method=\"post\"&gt;    {% csrf_token %}    {% for choice in question.choice_set.all %}        &lt;input type=\"radio\" name=\"choice\"               id=\"choice{{ forloop.counter }}\"               value=\"{{ choice.id }}\"&gt;        &lt;label for=\"choice{{ forloop.counter }}\"&gt;            {{ choice.choice_text }}        &lt;/label&gt;&lt;br&gt;    {% endfor %}        &lt;br&gt;        &lt;input type=\"submit\" value=\"Vote\"&gt;    &lt;/form&gt;&lt;/body&gt;&lt;/html&gt;상당히 복잡하네요. 하나씩 알아보도록 하겠습니다.      question.question_text : 질문을 제목으로 사용하는 것입니다. 크게 표현하기 위해서&lt;h1&gt; tag를 이용하고 있습니다.        error_message : 만약 에러가 있으면 에러 메시지를 화면에 보여주기 위해서 if 처리를했습니다. 에러 체크는 View의 vote() 함수에 구현될 것입니다. 만약 vote() 함수에서 exception이 발생하면 error_message를 담아서 detail.html Template을 rendering하게 됩니다.        form에 입력된 데이터는 POST 방식으로 서버측에 전달됩니다. REST 환경이 아닐때는GET과 POST방식을 사용하는데 데이터를 읽어올때는 일반적으로 GET, 서버측의 데이터를 변경할때는POST 방식을 이용합니다. (반드시 그런것은 아닙니다.) 그러면 데이터를 어디로 보낼까요?action 속성에 해당 URL을 명시합니다. 여기서는 url template tag를 이용하여 받는 곳의URL을 polls:vote로 설정했습니다. polls:vote에서 polls는 namespace를 의미하고 vote는URL의 이름을 의미합니다. 이 부분은 polls/urls.py에 명시되어 있습니다. 결과적으로 받는곳의URL은 /polls/1/vote/ 과 같은 형식이 될 것입니다.        form을 처리하는데 보안상의 issue를 해결하기 위해 csrf_token template tag를 사용했습니다.CSRF(Cross Site Request Forgery) 공격은 특정 웹사이트에서 이미 인증받은 사용자를 이용하여 웹사이트를 공격하는 방법입니다.        for 구문을 이용하여 Question 객체가 가지고 있는 데이터를 이용하여 radio button을 구현하고있습니다.        forloop.counter : for loop를 실행한 횟수를 담고 있는 template 변수 입니다. 여기서 labeltag의 for 속성과 radio button의 id 속성 값이 같아야 서로 바인딩 된다는것도 추가로 기억해야 합니다.        Vote 버튼을 누르면 사용자가 선택한 form data가 POST 방식으로 polls:vote URL로 전송됩니다.이렇게 전송된 데이터는 View 함수 vote()에서 access 할 수 있습니다.        마지막으로 Question 객체의 choose_set 속성에 대해서 알아보겠습니다. Question Table과 Choice Table은 1:N 의 관계를 가지고 있고 Foreign Key로 연결되어 있습니다. 이렇게 1:N의 관계에서1 Table에 N Table의 항목이라는 의미로 xxx_set 속성을 default로 제공합니다. 즉, question.choice_set.all()이라고 하면 Question Table의 question record에 연결된 Choice Table의모든 record를 의미하게 됩니다. 단, Template 문법상 method 호출을 표시하는 ()는 사용하지 않기때문에Template 파일에서는 question.choice_set.all 이라고 사용된 것입니다.  상당히 복잡했는데 몇번을 다시 보고 동영상을 통해서 이해하시면 좋을 듯 합니다.이제 이 Template을 사용하는 View 함수인 detail() 함수를 작성하고 실행해서 투표항목이 정상적으로출력이 되는지를 확인해 보도록 하겠습니다.views.py 파일을 다시 열고 기존의 index() 함수 다음에 아래의 코드를 입력합니다.from django.shortcuts import render, get_object_or_404from polls.models import Questiondef index(request):    latest_question_list = Question.objects.all().order_by('-pub_date')[:5]    context = {'latest_question_list': latest_question_list}    return render(request, 'polls/index.html', context)def detail(request, question_id):    question = get_object_or_404(Question, pk=question_id)    return render(request, 'polls/detail.html', {'question': question})View 함수를 정의했습니다. detail()이라는 함수를 정의했고 추가적으로 URL로 부터 추출한question_id 인자를 View 함수의 인자로 넘겨 받았습니다.path('&lt;int:question_id&gt;/', views.detail, name='detail')위의 부분에서 &lt;int:question_id&gt; 부분을 의미합니다.      get_object_or_404() : Django에서 제공되는 단축함수입니다. 이 함수의 첫번째 인자는Model class이고 두번째 인자부터는 검색 조건을 여러 개 사용할 수 있습니다. 우리예제에서는검색조건이 pk=question_id 이기 때문에 primary key가 question_id와 일치하는 객체를 조회하게 됩니다. 만약 조회된 객체가 없을 시 Http404 exception이 발생하게 됩니다.        추가적으로 get_list_or_404() 단축함수도 있습니다. 이것은 대상객체의 집합을 list로가져올 때 사용합니다.  지금까지의 작업 확인지금까지 작성한 내용으로 서버를 기동시켜서 /polls/로 접속한 후3개의 질문 중 하나를 선택했을 때, 질문에 대한 답변 항목을 보여주고 투표하도록 하는 화면이 나오는지를 확인하도록 하겠습니다. 아직 미구현인 부분들은 주석처리 후 서버를 기동시켜서 접속을 해보도록 하죠특히 form tag action 속성부분은 일단 주석처리해야 할 듯 합니다.{% comment %}    &lt;form action=\"{% url 'polls:vote' question.id %}\"          method=\"post\"&gt;{% endcomment %}    &lt;form action=\"\"          method=\"post\"&gt;그리고 데이터베이스에 각 질문에 대한 선택항목을 저장하지 않았기 때문에Admin site에 접속해서 질문에 대한 선택항목을 저장한 후 실행하면 다음과 같은 화면을보실 수 있습니다.End.Python 강좌는 아래의 책과 사이트를 참조했습니다.    조금 더 자세한 사항을 알고 싶으시면 해당 사이트를 방문하세요!!    Python Official HomePage    점프 투 파이썬 - 이지스 퍼블리싱    전문가를 위한 파이썬(Fluent Python) - 한빛미디어    파이썬 웹 프로그래밍 - 한빛미디어    이미지 출처 : Designed by rawpixel.com / Freepik",
        "url": "/python-lecture-python-django-poll-project-4"
    }
    ,
    
    "python-lecture-python-django-poll-project-3": {
        "title": "Python Django 웹 프레임워크(4) - Poll project 개발(3)",
            "author": "moon9342",
            "category": "",
            "content": "Python 기초강의는 여러 절로 구성되어 있습니다.     Python 기초강의(1) - Introduction    Python 기초강의(2) - Python 기본    Python 기초강의(3) - Python 제어문    Python 기초강의(4) - Python function    Python 기초강의(5) - Python 연습문제(1)    Python 기초강의(6) - Python 객체지향    Python 기초강의(7) - Python Magic Function    Python 기초강의(8) - Python First Class    Python 기초강의(9) - Python Closure    Python 기초강의(10) - Python Decorator    Python 기초강의(11) - Python Generator    Python 기초강의(12) - Python Module    Python 기초강의(13) - Python Exception &amp; File    Python 기초강의(14) - Python 연습문제(2)    Python Django 웹 프레임워크(1) - introduction    Python Django 웹 프레임워크(2) - Poll project 개발(1)    Python Django 웹 프레임워크(3) - Poll project 개발(2)    Python Django 웹 프레임워크(4) - Poll project 개발(3)    Python Django 웹 프레임워크(5) - Poll project 개발(4)    Python Django 웹 프레임워크(6) - Poll project 개발(5)    Python Django 웹 프레임워크(7) - Django의 개발방식    Python Django 웹 프레임워크(8) - Blog project 개발    View와 Template아래의 그림은 우리의 Poll Project의 전체 처리 흐름을 도식화 한 것입니다.다시한번 느끼지만 그림에는 정말 소질이 없군요.(글자도 잘 안보이고…)기본적으로 4개의 URL을 사용하고 여기에 Admin site까지 포함하여 총 5개의 URL을 이용할것입니다. 그리고 각각의 URL은 View와 1:1로 mapping되어 있습니다. 일반적으로 URL은 View와1:1 mapping을 하지만 N:1의 관계도 가능합니다.각각의 View는 Template을 이용하여 결과 화면을 클라이언트에게 전송하게 됩니다.제일 먼저 처리해야 하는 내용은 URL과 View의 mapping처리 입니다. 이것을 URLConf라고 하며urls.py 파일에 작성합니다.from django.contrib import adminfrom django.urls import pathfrom polls import viewsurlpatterns = [    path('admin/', admin.site.urls),    path('polls/', views.index, name='index'),    path('polls/&lt;int:question_id&gt;/', views.detail, name='detail'),    path('polls/&lt;int:question_id&gt;/vote/', views.vote, name='vote'),    path('polls/&lt;int:question_id&gt;/results/', views.results, name='results'),]몇가지 기억해야 하는 사항이 있습니다.      URL pattern matching은 위에서 아래로 진행됩니다. 따라서 정의하는 순서에 유의해야 합니다.        Django의 Admin site에 대한 URLConf는 이미 정의 되어 있습니다. 항상 똑같이 사용하세요.        path() 함수를 이용하여 URL과 View를 mapping하고 있습니다.  여기서 중요한 것은 path() 함수인데 path()함수는 2개의 필수인자를 가집니다. 우리예에서 보듯이 route와 view입니다. 또한 kwargs와 name 2개의 선택인자를 가질 수 있습니다.  route : URL pattern을 표현하는 문자열입니다. URL String이라고도 합니다.  view : URL String이 matching되면 호출되는 View의 함수입니다. HttpRequest 객체와 URL String에서추출된 항목이 View 함수의 인자로 전달됩니다.  kwargs : URL String에서 추출된 항목외에 추가적인 인자를 View 함수에 전달할 목적으로 dict 형태로사용됩니다.  name : 각 URL pattern에 대한 논리적인 이름입니다. 이 이름은 Template에서 사용됩니다.두가지 예만 들어보겠습니다.만약 요청 URL이 /polls/ 라면 path('polls/', views.index, name='index') 부분이 matching됩니다. 이 경우 URL String에서 추출되는 항목이 없기 때문에 views.index(request) 처럼View 함수가 호출됩니다. 그리고 이 URL pattern의 이름은 index로 정의했습니다.만약 요청 URL이 /polls/5 라면 URL String에서 추출되는 항목이 있기 때문에 views.detail(request,question_id=3)처럼 인자가 대입되서 View 함수가 호출되게 됩니다. 그리고이 URL pattern의 이름은 detail로 정했습니다.기억해야 할 점 또 하나는 mysite/settings.py 파일에 ROOT_URLCONF 항목이 정의되어 있는데Django는 URL 분석 시, 이 항목에 정의된 urls.py파일을 가장 먼저 분석하게 됩니다.여기서 조금 복잡한 사항이 하나 나옵니다. 지금 우리가 하는 것처럼 mysite/urls.py 파일에모든 URL과 View의 mapping을 기술 할 수도 있지만 이런 경우 재사용과 관리에 문제가 발생할 수 있습니다.그래서 일반적으로 urls.py를 applciation단위로 나누어서 작성합니다.즉, mysite/urls.py의 내용은 아래와 같이 작성합니다.from django.contrib import adminfrom django.urls import path, includefrom polls import views urlpatterns = [    path('admin/', admin.site.urls),    path('polls/', include('polls.urls')),]그리고 MyFirstWebPoll/polls/urls.py 파일은 아래와 같이 작성합니다.from django.urls import pathfrom . import viewsapp_name = 'polls'urlpatterns = [    path('', views.index, name='index'),    path('&lt;int:question_id&gt;/', views.detail, name='detail'),    path('&lt;int:question_id&gt;/vote/', views.vote, name='vote'),    path('&lt;int:question_id&gt;/results/', views.results, name='results'),]이렇게 파일을 나누어서 URL과 View의 mapping을 관리할 수 있습니다. 당연히 파일을분리해서 관리하는 것이 훨씬 좋은 방법입니다. app_name = 'polls' 부분은 URL pattern이 충돌나는 것을 방지하기 위한 namespace 설정입니다.우리의 예제는 파일을 나누어서 URL과 View의 mapping관리를 하는 방법을 사용하도록하겠습니다.Template 작성위에서 URL과 View에 대한 mapping설정을 했으니 이제 View와 Template을 작성할 차례입니다.이 둘은 서로 서로에게 영향을 미치기 때문에 보통 같이 작업하는게 일반적이지만 UI화면을먼저 생각하면서 로직처리를 하는것이 쉬울 수 있기 때문에 View보다는 Template을 먼저 작성하면조금 더 쉬운 경향이 있습니다.자 그럼 Template 파일 index.html을 작성해보도록 하죠. 이 Template 파일 역시 관리상의이유로 하나의 폴더에서 모든 Template을 관리하는 것이 아니라 application별로 따로 관리합니다.  C:/python-Django/MyFirstWebPoll/polls&gt; mkdir templates  C:/python-Django/MyFirstWebPoll/polls&gt; mkdir templates/polls  C:/python-Django/MyFirstWebPoll/polls&gt; cd templates/polls이 폴더 내에서 index.html을 아래처럼 작성합니다.&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt;    &lt;meta charset=\"UTF-8\"&gt;    &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    {% if latest_question_list %}        &lt;ul&gt;        {% for question in latest_question_list %}            &lt;li&gt;&lt;a href=\"/polls/{{ question.id }}/\"&gt;{{ question.question_text }}&lt;/a&gt;&lt;/li&gt;        {% endfor %}        &lt;/ul&gt;    {% else %}        &lt;p&gt;No Polls are available&lt;/p&gt;    {% endif %}&lt;/body&gt;&lt;/html&gt;여기서 주의해서 보셔야 하는 건 latest_question_list 입니다. View 함수인 index()에서넘겨주는 인자입니다. 코드로 유추해 보건대 설문에 대한 번호와 질문내용을 가지고 있는 Question객체로 구성된 list 일 듯 합니다.사실 구현할 때는 역으로 생각하셔야 합니다. 즉, Template을 만들면서 어떤 데이터를 넘겨줘야Template이 잘 표현될지를 생각해서 이 데이터를 View 함수에서 context 변수로 정의한 후 Template으로 넘겨줘야 하기 때문입니다.View 작성C:/python-Django/MyFirstWebPoll/polls 폴더 하단에 있는 view.py을 다음과 같이 수정합니다.from django.shortcuts import renderfrom polls.models import Questiondef index(request):    latest_question_list = Question.objects.all().order_by('-pub_date')[:5]    context = {'latest_question_list': latest_question_list}    return render(request, 'polls/index.html', context)기억해야 할 사항은 다음과 같습니다.      render() : 단축함수 중 하나로 Template 코드를 로딩한 후 context 변수를 적용하고그 결과를 HttpResponse 객체에 담아 반환하는 작업을 수행합니다. 이런 복잡한 과정을 Django에서는 render() 내장함수로 제공하고 있습니다.        Question : Question Table에 access하기 위해 polls.models.Question class를 사용합니다.        View 함수를 정의한 후 Template에게 넘겨줄 데이터를 생성합니다.        Template에게 넘겨줄 때는 dict 형태로 넘겨주며 context 객체를 생성해서 render()함수에전달합니다.        index() 함수는 최종적으로 클라이언트에게 응답할 데이터인 HttpResponse 객체를 반환합니다.        한가지 의문이 드는것은 render() 함수에서 Template 파일을 어떻게 찾느냐 하는 것입니다. Django에서 Template 파일을 찾을 때 settings.py 파일에 정의된 TEMPLATES 그리고INSTALLED_APPS에서 지정된 디렉토리를 검색하게 됩니다.  지금까지의 작업 확인지금까지 작성한 내용으로 서버를 기동시켜서 /polls/로 접속하려 합니다. 하지만 아직 작성하지않은 파일들이 존재하기 때문에 바로 동작되지는 않을테고 아직 미구현인 부분들은 주석처리 후서버를 기동시켜서 접속을 해보도록 하죠당연히 No Polls are available가 출력되게 됩니다. 아직 어떠한 질문도 등록하지 않았거든요.그럼 Admin site로 접속한 후 데이터를 입력하고 다시 접속해 보도록 하겠습니다. 질문은 3개만 등록하도록 하겠습니다.  취미가 무엇인가요?  가장 좋아하는 선수는 누구인가요?  어디에 살고 있나요?이제 화면이 정상적으로 보이나요?End.Python 강좌는 아래의 책과 사이트를 참조했습니다.    조금 더 자세한 사항을 알고 싶으시면 해당 사이트를 방문하세요!!    Python Official HomePage    점프 투 파이썬 - 이지스 퍼블리싱    전문가를 위한 파이썬(Fluent Python) - 한빛미디어    파이썬 웹 프로그래밍 - 한빛미디어    이미지 출처 : Designed by rawpixel.com / Freepik",
        "url": "/python-lecture-python-django-poll-project-3"
    }
    ,
    
    "python-lecture-python-django-poll-project-2": {
        "title": "Python Django 웹 프레임워크(3) - Poll project 개발(2)",
            "author": "moon9342",
            "category": "",
            "content": "Python 기초강의는 여러 절로 구성되어 있습니다.     Python 기초강의(1) - Introduction    Python 기초강의(2) - Python 기본    Python 기초강의(3) - Python 제어문    Python 기초강의(4) - Python function    Python 기초강의(5) - Python 연습문제(1)    Python 기초강의(6) - Python 객체지향    Python 기초강의(7) - Python Magic Function    Python 기초강의(8) - Python First Class    Python 기초강의(9) - Python Closure    Python 기초강의(10) - Python Decorator    Python 기초강의(11) - Python Generator    Python 기초강의(12) - Python Module    Python 기초강의(13) - Python Exception &amp; File    Python 기초강의(14) - Python 연습문제(2)    Python Django 웹 프레임워크(1) - introduction    Python Django 웹 프레임워크(2) - Poll project 개발(1)    Python Django 웹 프레임워크(3) - Poll project 개발(2)    Python Django 웹 프레임워크(4) - Poll project 개발(3)    Python Django 웹 프레임워크(5) - Poll project 개발(4)    Python Django 웹 프레임워크(6) - Poll project 개발(5)    Python Django 웹 프레임워크(7) - Django의 개발방식    Python Django 웹 프레임워크(8) - Blog project 개발    ModelModel 작업은 우리가 사용하는 Database에 Table을 생성하는 작업입니다.우리의 polls application은 Questions와 Choice 두 개의 테이블이 필요합니다.Table은 models.py 파일에 정의합니다.C:/python-Django/MyFirstWebPoll/polls 폴더에 존재하는 models.py 파일의 내용을다음과 같이 수정합니다.from django.db import modelsclass Question(models.Model):    question_text = models.CharField(max_length=200)    pub_date = models.DateTimeField('date published')    def __str__(self):        return self.question_textclass Choice(models.Model):    question = models.ForeignKey(Question, on_delete=models.CASCADE)    choice_text = models.CharField(max_length=200)    votes = models.IntegerField(default=0)    def __str__(self):        return self.choice_textDjango에서는 Table을 하나의 class로 정의합니다. 또한 Table의 column은 class의속성으로 mapping합니다.위에서 표현이 안된 부분이 있는데 바로 Table의 id column입니다. Table의 id column은 Primary key로 지정되며 정수(integer)형태입니다. 또한 Django가 자동으로 생성해주기 때문에 class 정의에서는 표현되지 않았습니다.참고로 PK(primary key)는 Not Null 속성을 가지며 Autoincrement로 지정됩니다.조심해야 될 점은 Choice class의 FK로 지정되어 있는 question 입니다. FK이기 때문에어떤 reference할 class만 명시하면 되고 실제 Table이 생성될 때 _id 접미어가 붙어서column이 생성됩니다. 즉, column명이 question 이 아닌 question_id 가 되게 됩니다.Admin site에 테이블 반영이전에 살펴본 Admin site에는 Users와 Groups Table만 존재합니다. 방금 models.py 에서정의한 Table도 Admin site에서 보이도록 등록해야 할 듯 합니다.admin.py 파일을 아래의 내용으로 수정합니다.from django.contrib import adminfrom polls.models import Question, Choiceadmin.site.register(Question)admin.site.register(Choice)Database 변경 사항 반영당연한 말이지만 Database에 변경사항이 있으면 이를 반영해 주어야 합니다. 아직까지는class로 Table만 정의한 단계이니 실제로 Database에 반영을 시켜줍니다.  C:/python-Django/MyFirstWebPoll&gt; python manage.py makemigrations  C:/python-Django/MyFirstWebPoll&gt; python manage.py migrateAdmin site에서 변경사항 확인지금까지 작업한 내용이 잘 적용되었나를 Admin site에서 확인해보도록 하겠습니다.서버를 기동하고 Admin site에 접속합니다.이번 절에서는 Model을 생성하는 방법에 대해서 알아보았습니다. 그럼 다음에는 View와 Template에대해서 알아보면서 우리의 간단한 Web Project를 완성해 보도록 하죠.End.Python 강좌는 아래의 책과 사이트를 참조했습니다.    조금 더 자세한 사항을 알고 싶으시면 해당 사이트를 방문하세요!!    Python Official HomePage    점프 투 파이썬 - 이지스 퍼블리싱    전문가를 위한 파이썬(Fluent Python) - 한빛미디어    파이썬 웹 프로그래밍 - 한빛미디어    이미지 출처 : Designed by rawpixel.com / Freepik",
        "url": "/python-lecture-python-django-poll-project-2"
    }
    ,
    
    "python-lecture-python-django-poll-project-1": {
        "title": "Python Django 웹 프레임워크(2) - Poll project 개발(1)",
            "author": "moon9342",
            "category": "",
            "content": "Python 기초강의는 여러 절로 구성되어 있습니다.     Python 기초강의(1) - Introduction    Python 기초강의(2) - Python 기본    Python 기초강의(3) - Python 제어문    Python 기초강의(4) - Python function    Python 기초강의(5) - Python 연습문제(1)    Python 기초강의(6) - Python 객체지향    Python 기초강의(7) - Python Magic Function    Python 기초강의(8) - Python First Class    Python 기초강의(9) - Python Closure    Python 기초강의(10) - Python Decorator    Python 기초강의(11) - Python Generator    Python 기초강의(12) - Python Module    Python 기초강의(13) - Python Exception &amp; File    Python 기초강의(14) - Python 연습문제(2)    Python Django 웹 프레임워크(1) - introduction    Python Django 웹 프레임워크(2) - Poll project 개발(1)    Python Django 웹 프레임워크(3) - Poll project 개발(2)    Python Django 웹 프레임워크(4) - Poll project 개발(3)    Python Django 웹 프레임워크(5) - Poll project 개발(4)    Python Django 웹 프레임워크(6) - Poll project 개발(5)    Python Django 웹 프레임워크(7) - Django의 개발방식    Python Django 웹 프레임워크(8) - Blog project 개발    Project Setup시작은 프로젝트의 뼈대를 만드는 일부터 시작합니다. 프로젝트에 필요한디렉토리 및 파일을 구성하고 설정 파일을 세팅하도록 하겠습니다.간단하게 C:/python-Django 폴더를 하나 생성한 후 command창을 열어서다음과 같이 입력해서 프로젝트를 시작합니다.  C:/Users/moon9342&gt; cd C:/python-Django  C:/python-Django&gt; django-admin startproject mysite생성된 폴더 구조를 보면 C:/python-Django/mysite 가 생성되고 그 아래에 다시C:/python-Django/mysite/mysite 폴더가 생성되게 됩니다.여기서 상위 폴더인 C:/python-Django/mysite 폴더는 단순히 프로젝트 관련파일과폴더를 모아놓은 폴더이기 때문에 다른 이름으로 변경할 것입니다. 하위 폴더인C:/python-Django/mysite/mysite 폴더가 우리의 프로젝트 디렉토리 입니다.  C:/python-Django&gt; move mysite MyFirstWebPoll이름을 변경한 후 해당 폴더로 이동합니다. 그리고 그 안에 polls라는 application을생성하는 명령을 입력합니다.  C:/python-Django&gt; cd C:/python-Django/MyFirstWebPoll  C:/python-Django/MyFirstWebPoll&gt; python manage.py startapp polls이 과정을 거치면 polls라는 이름의 application 디렉토리와 그 하위에 필요한 파일들을자동으로 생성해 줍니다. 파일 이름은 Django가 알아서 설정하게 되는데 이렇게 개발에 반드시필요한 파일들은 Django가 알아서 생성해주고 개발자는 그 내용을 채워넣는 식으로 진행됩니다.Project 설정파일 변경프로젝트에 필요한 설정값은 settings.py 파일에 지정합니다.지금부터는 PyCharm을 이용하기로 하죠.  ALLOWED_HOSTS : Django는 DEBUG=True이면 개발모드로 False이면 운영모드로인식합니다. 운영 모드인 경우 ALLOWED_HOSTS에는 반드시 서버의 IP나 Domain을 지정해야 합니다.개발모드인 경우에는 값을 지정하지 않으면 ['localhost','127.0.0.1']로 간주됩니다.지금은 개발모드 이기 때문에 ['localhost','127.0.0.1']로 설정합니다.ALLOWED_HOSTS = ['localhost', '127.0.0.1']  INSTALLED_APPS : 프로젝트에 포함되는 application들은 모두 설정 파일에 등록되어야 합니다.따라서 우리가 개발하고 있는 polls application도 등록해야 되겠죠. 일반적으로 application의설정 클래스로 등록하게 됩니다.  polls application의 설정 클래스는 자동으로 생성된 apps.py파일안에 PollsConfig라고 정의되어 있습니다. 이 부분을 INSTALLED_APPS에 추가합니다.INSTALLED_APPS = [    'django.contrib.admin',    'django.contrib.auth',    'django.contrib.contenttypes',    'django.contrib.sessions',    'django.contrib.messages',    'django.contrib.staticfiles',    'polls.apps.PollsConfig']  DATABASES : 프로젝트에 사용할 데이터베이스 엔진입니다. Django는 default로SQLite3 데이터 베이스 엔진을 사용하도록 설정되어 있습니다. 이번에는 SQLite3를 사용하고다음 예제에서는 MariaDB를 사용하도록 하겠습니다. 따라서 이번에는 설정을 변경하지 않겠습니다.DATABASES = {    'default': {        'ENGINE': 'django.db.backends.sqlite3',        'NAME': os.path.join(BASE_DIR, 'db.sqlite3'),    }}  TIME_ZONE : 마지막은 타임존 지정입니다. UTC(세계표준시)로 되어 있는 부분을한국 시간으로 변경합니다.TIME_ZONE = 'Asia/Seoul'기본 테이블 생성기본 테이블을 생성하기 위해서 다음의 명령을 실행합니다.  C:/python-Django/MyFirstWebPoll&gt; python manage.py migratemigrate 명령은 데이터베이스에 변경 사항이 있을 때 이를 반영해 주는 명령어 입니다.Django는 모든 웹 프로젝트 개발 시 반드시 사용자와 그룹 테이블 등이 필요하다는 가정하에설계되었습니다. 따라서 우리가 현 시점에서 Database를 전혀 사용하지 않는다 할지라도 사용자 및 그룹 테이블등을 만들어 주어야 합니다.정상적으로 실행되면 db.slqite3 파일이 생성되게 됩니다.서버 기동기본적인 작업을 수행했으니 이제 제공된 테스트용 웹 서버를 이용해서 우리 프로젝트를deploy해 보겠습니다.  C:/python-Django/MyFirstWebPoll&gt; python manage.py runserver만약 IP와 Port를 지정하지 않으면 default로 127.0.0.1:8000으로 실행됩니다. IP와 Port를 지정하시려면 다음과 같이 수행하면 됩니다.  C:/python-Django/MyFirstWebPoll&gt; python manage.py runserver 0.0.0.0:8888서버를 기동하고 웹 브라우져로 접속해보죠. 화면이 잘 나오나요??Admin site 접속Django에서 제공하는 기본적인 Admin site에 접속해서 Table이 생성된 것을 확인해 보도록하겠습니다. 사용할 url은 http://127.0.0.1:8000/admin 입니다.로그인을 하려면 Username, Password를 입력해야 하는데 아직 생성하지 않았습니다. Adminsite에 로그인하기 위해 관리자계정을 하나 생성합니다.  C:/python-Django/MyFirstWebPoll&gt; python manage.py createsuperuser이렇게 생성된 Username, Password를 이용하여 admin site에 접속해서 현재 생성되어 있는Groups, Users 테이블을 확인합니다. 사실 이 테이블이 존재하는 이유는 settings.py에django.contrib.auth application이 등록되어 있기 때문입니다. Django에서 기본적으로 제공하는application에 Users와 Groups Table이 미리 정의되어 있었다는 얘기입니다.기본적인 프로젝트의 뼈대를 세우고 환경설정파일을 살짝 수정한 후 테스트 웹서버를 이용해서우리 웹 프로젝트를 deploy까지 진행해봤습니다. 이제 Poll Application을 하나씩 순차적으로 작성해 보도록 하겠습니다.End.Python 강좌는 아래의 책과 사이트를 참조했습니다.    조금 더 자세한 사항을 알고 싶으시면 해당 사이트를 방문하세요!!    Python Official HomePage    점프 투 파이썬 - 이지스 퍼블리싱    전문가를 위한 파이썬(Fluent Python) - 한빛미디어    파이썬 웹 프로그래밍 - 한빛미디어    이미지 출처 : Designed by rawpixel.com / Freepik",
        "url": "/python-lecture-python-django-poll-project-1"
    }
    ,
    
    "python-lecture-python-django-introduction": {
        "title": "Python Django 웹 프레임워크(1) - introduction",
            "author": "moon9342",
            "category": "",
            "content": "Python 기초강의는 여러 절로 구성되어 있습니다.     Python 기초강의(1) - Introduction    Python 기초강의(2) - Python 기본    Python 기초강의(3) - Python 제어문    Python 기초강의(4) - Python function    Python 기초강의(5) - Python 연습문제(1)    Python 기초강의(6) - Python 객체지향    Python 기초강의(7) - Python Magic Function    Python 기초강의(8) - Python First Class    Python 기초강의(9) - Python Closure    Python 기초강의(10) - Python Decorator    Python 기초강의(11) - Python Generator    Python 기초강의(12) - Python Module    Python 기초강의(13) - Python Exception &amp; File    Python 기초강의(14) - Python 연습문제(2)    Python Django 웹 프레임워크(1) - introduction    Python Django 웹 프레임워크(2) - Poll project 개발(1)    Python Django 웹 프레임워크(3) - Poll project 개발(2)    Python Django 웹 프레임워크(4) - Poll project 개발(3)    Python Django 웹 프레임워크(5) - Poll project 개발(4)    Python Django 웹 프레임워크(6) - Poll project 개발(5)    Python Django 웹 프레임워크(7) - Django의 개발방식    Python Django 웹 프레임워크(8) - Blog project 개발    Django introductionDjango는 Python으로 만들어진 무료 오픈소스 웹 애플리케이션 프레임워크(web application framework)입니다.우리는 Web Application을 개발할 때 굉장히 빈번하게 반복적인 문제를 해결해야 될 때가 많습니다. 사용자들의 회원가입, 로그인, 로그아웃 등의 사용자 인증 및 관리에 대한 구현 혹은 게시판과 같이 사용자들이 커뮤니케이션을 할 수 있는 공간과 파일 업로드, 다운로드를 할 수 있도록 하는 기능 구현등이 이에 해당합니다.우리가 아는 거의 모든 웹 페이지들은 이러한 기능들을 기본적으로 제공합니다. 이러한 기능들을 구현할 때 편리한 개발환경을 만들어 놓은 것이 바로 프레임워크 이라고 생각하시면 됩니다.Django 특징  MVC pattern 기반의 MVT  ORM(Object Relational Mapping - 객체관계매핑)  자동으로 구성되는 관리자 화면  Elegant URL  자체 Template 시스템  Cache 시스템Django 설치Windows 10을 기준으로 다음과 같이 pip(python install package)를 이용하여PyPI(Python Package Index)에 있는 SW package를 설치하면 됩니다.  pip install Django원래는 Django의 Application개발 방식에 대한 설명을 해야 합니다. MVT 방식에 대한 이해라던지URLConf 처리 순서, Model, View, Template의 동작원리와 동작순서같은 것들 말이죠. 하지만처음 Django를 접하거나 아예 웹 프로그래밍을 접해보지 않은 사람들에게는 너무 어려운 설명일 듯합니다.조금 쉽게 풀어가기 위해 간단한 Application을 하나 만들어 가면서 부가적으로 설명을 곁들이는방식으로 진행하겠습니다.우리의 첫번째 Project는 파이썬 웹 프로그래밍(한빛미디어) 책에서 소개된 Poll project입니다.그럼 다음 절에서 천천히 시작해 보도록 하죠.End.Python 강좌는 아래의 책과 사이트를 참조했습니다.    조금 더 자세한 사항을 알고 싶으시면 해당 사이트를 방문하세요!!    Python Official HomePage    점프 투 파이썬 - 이지스 퍼블리싱    전문가를 위한 파이썬(Fluent Python) - 한빛미디어    파이썬 웹 프로그래밍 - 한빛미디어    이미지 출처 : Designed by rawpixel.com / Freepik",
        "url": "/python-lecture-python-django-introduction"
    }
    ,
    
    "data-science-lecture-python-pandas-dataframe-exercise": {
        "title": "Python 데이터분석 라이브러리(10) - Pandas(Exercise)",
            "author": "moon9342",
            "category": "",
            "content": "Data-Science 강의는 여러 절로 구성되어 있습니다.     Python 데이터분석 라이브러리(1) - NumPy    Python 데이터분석 라이브러리(2) - NumPy(Exercise)    Python 데이터분석 라이브러리(3) - Pandas(Series)    Python 데이터분석 라이브러리(4) - Pandas(DataFrame 생성)    Python 데이터분석 라이브러리(5) - Pandas(DataFrame indexing)    Python 데이터분석 라이브러리(6) - Pandas(DataFrame functions)    Python 데이터분석 라이브러리(7) - Pandas(DataFrame merge)    Python 데이터분석 라이브러리(8) - Pandas(DataFrame 제어)    Python 데이터분석 라이브러리(9) - Pandas(DataFrame Grouping)    Python 데이터분석 라이브러리(10) - Pandas(Exercise)Pandas Exercise - 1Group Lens(미네소타 대학 컴퓨터과의 research lab)에서 수집한 영화 데이터를 이용해데이터 분석을 해 보자.영화의 선호 정보를 1~5사이의 점수로 표현 (5에 가까울수록 선호)Group Lens 사이트사용할 데이터 파일  pandas를 사용하여 다음의 문제를 해결합니다. 동률이 있을 경우 오름차순으로 정렬하여 출력합니다.1. 사용자가 평가한 모든 영화의 전체 평균 평점을 출력하세요.2. 각 사용자별 평균 평점을 구하세요. 출력시 정렬은 userId로 오름차순 정렬합니다.3. 각 영화별 평균 평점을 구하세요. 출력시 정렬은 movieId로 오름차순 정렬합니다. 4. 평균 평점이 가장 높은 영화의 제목을 출력하세요.   단, 동률이 있을 경우 모두 출력하고 title을 기준으로 오름차순 정렬하세요.5. Comedy영화 중 가장 평점이 낮은 영화의 제목을 출력하세요.   단, 동률이 있을 경우 모두 출력하고 title을 기준으로 오름차순 정렬하세요.6. 2015년도에 평가된 모든 Romance 영화의 평균 평점은?예상되는 정답.1. 사용자가 평가한 모든 영화의 전체 평균 평점을 출력하세요.   =&gt; 3.5015569836169622. 각 사용자별 평균 평점을 구하세요. 출력시 정렬은 userId로 오름차순 정렬합니다.   =&gt; userId      1      4.366379      2      3.948276      3      2.435897      4      3.555556      5      3.636364               ...         606    3.657399      607    3.786096      608    3.134176      609    3.270270      610    3.688556      Name: rating, Length: 610, dtype: float643. 각 영화별 평균 평점을 구하세요. 출력시 정렬은 movieId로 오름차순 정렬합니다.   =&gt; \tmovieId\ttitle\trating      0\t1\tToy Story (1995)\t3.920930      1\t2\tJumanji (1995)\t3.431818      2\t3\tGrumpier Old Men (1995)\t3.259615      3\t4\tWaiting to Exhale (1995)\t2.357143      4\t5\tFather of the Bride Part II (1995)\t3.071429      ...\t...\t...\t...      9737\t193581\tBlack Butler: Book of the Atlantic (2017)\t4.000000      9738\t193583\tNo Game No Life: Zero (2017)\t3.500000      9739\t193585\tFlint (2017)\t3.500000      9740\t193587\tBungo Stray Dogs: Dead Apple (2018)\t3.500000      9741\t193609\tAndrew Dice Clay: Dice Rules (1991)\t4.000000      9742 rows × 3 columns4. 평균 평점이 가장 높은 영화의 제목을 출력하세요.   단, 동률이 있을 경우 모두 출력하고 title을 기준으로 오름차순 정렬하세요.   =&gt; \tmovieId\ttitle\trating      5690\t27751\t'Salem's Lot (2004)\t5.0      7332\t77846\t12 Angry Men (1997)\t5.0      9046\t141816\t12 Chairs (1976)\t5.0      3893\t5468\t20 Million Miles to Earth (1957)\t5.0      5639\t27373\t61* (2001)\t5.0      ...\t...\t...\t...      9711\t187717\tWon't You Be My Neighbor? (2018)\t5.0      8355\t108795\tWonder Woman (2009)\t5.0      9289\t158398\tWorld of Glory (1991)\t5.0      9560\t173351\tWow! A Talking Fish! (1983)\t5.0      7521\t84273\tZeitgeist: Moving Forward (2011)\t5.0      296 rows × 3 columns5. Comedy영화 중 가장 평점이 낮은 영화의 제목을 출력하세요.   단, 동률이 있을 경우 모두 출력하고 title을 기준으로 오름차순 정렬하세요.   =&gt; \tmovieId\ttitle\tgenres      8893\t134528\tAloha (2015)\tComedy|Drama|Romance      5777\t31422\tAre We There Yet? (2005)\tChildren|Comedy      7762\t91414\tArthur Christmas (2011)\tAnimation|Children|Comedy|Drama      9419\t165645\tBad Santa 2 (2016)\tComedy      4439\t6557\tBorn to Be Wild (1995)\tAdventure|Children|Comedy|Drama      5409\t25782\tBoudu Saved From Drowning (Boudu sauvé des eau...\tComedy      6554\t54934\tBrothers Solomon, The (2007)\tComedy      5453\t26095\tCarabineers, The (Carabiniers, Les) (1963)\tComedy|Drama|War      6545\t54768\tDaddy Day Camp (2007)\tChildren|Comedy      4881\t7312\tFollow Me, Boys! (1966)\tComedy|Drama      7553\t85334\tHard Ticket to Hawaii (1987)\tAction|Comedy      8417\t110773\tHaunted House 2, A (2014)\tComedy|Horror      5662\t27595\tJesus Christ Vampire Hunter (2001)\tAction|Comedy|Horror|Musical      8984\t138798\tJoe Dirt 2: Beautiful Loser (2015)\tComedy      7820\t92681\tJourney 2: The Mysterious Island (2012)\tAction|Adventure|Comedy|Sci-Fi|IMAX      6160\t44243\tLeprechaun 4: In Space (1997)\tComedy|Fantasy|Horror|Sci-Fi      8248\t104644\tMaria Bamford: The Special Special Special! (2...\tComedy      7201\t72696\tOld Dogs (2009)\tComedy      9056\t141994\tSaving Christmas (2014)\tChildren|Comedy      5258\t8632\tSecret Society (2002)\tComedy      9590\t175475\tThe Emoji Movie (2017)\tAnimation|Children|Comedy      8908\t135216\tThe Star Wars Holiday Special (1978)\tAdventure|Children|Comedy|Sci-Fi      8676\t122246\tTooth Fairy 2 (2012)\tChildren|Comedy      5795\t31692\tUncle Nino (2003)\tComedy      6784\t60363\tZombie Strippers! (2008)\tComedy|Horror6. 2015년도에 평가된 모든 Romance 영화의 평균 평점은?   =&gt; 3.396375098502758Pandas Exercise - 2R에서 데이터 분석에 사용되는 mpg data set을 이용하여 pandas로 기술분석을진행합니다.mpg data set 파일은 아래 링크에서 다운로드 할 수 있습니다.사용할 mpg 데이터 파일만약 R이 설치되어 있다면 다음의 코드로 데이터파일을 생성할 수 있습니다.## mpg data set 파일 저장library(ggplot2)df &lt;- as.data.frame(mpg)write.csv(df,          file=\"C:/notebook_dir/mpg.txt\",          row.names = F,          quote = F,          fileEncoding = \"UTF-8\")기본적인 column에 대한 설명은 아래와 같고 더 자세한 설명은 아래에 링크된사이트로 이동하시면 상세한 설명을 보실 수 있습니다.R mpg data set Documentation# 주요컬럼 설명# manufacturer : 제조회사# displ : 배기량# cyl : 실린더 개수# drv : 구동 방식# hwy : 고속도로 연비# class : 자동차 종류# model : 자동차 모델명# year : 생산연도# trans : 변속기 종류# cty : 도시 연비# fl : 연료 종류  pandas를 사용하여 다음의 문제를 해결합니다.1. displ(배기량)이 4 이하인 자동차와 5 이상인 자동차 중    어떤 자동차의 hwy(고속도로 연비)가 평균적으로 더 높은지 확인하세요.2. 자동차 제조 회사에 따라 도시 연비가 다른지 알아보려고 한다.    \"audi\"와 \"toyota\" 중 어느 manufacturer(제조회사)의 cty(도시 연비)가    평균적으로 더 높은지 확인하세요.3. \"chevrolet\", \"ford\", \"honda\" 자동차의 고속도로 연비 평균을 알아보려고 한다.    이 회사들의 데이터를 추출한 후 hwy(고속도로 연비) 평균을 구하세요.4. \"audi\"에서 생산한 자동차 중에 어떤 자동차 모델의 hwy(고속도로 연비)가    높은지 알아보려고 한다.    \"audi\"에서 생산한 자동차 중 hwy가 1~5위에 해당하는 자동차의 데이터를 출력하세요.5. mpg 데이터는 연비를 나타내는 변수가 2개입니다.    두 변수를 각각 활용하는 대신 하나의 통합 연비 변수를 만들어 사용하려 합니다.    평균 연비 변수는 두 연비(고속도로와 도시)의 평균을 이용합니다.    회사별로 \"suv\" 자동차의 평균 연비를 구한후 내림차순으로 정렬한 후 1~5위까지 데이터를 출력하세요.6. mpg 데이터의 class는 \"suv\", \"compact\" 등 자동차의 특징에 따라    일곱 종류로 분류한 변수입니다. 어떤 차종의 도시 연비가 높은지 비교하려 합니다.    class별 cty 평균을 구하고 cty 평균이 높은 순으로 정렬해 출력하세요.7. 어떤 회사 자동차의 hwy(고속도로 연비)가 가장 높은지 알아보려 합니다.    hwy(고속도로 연비) 평균이 가장 높은 회사 세 곳을 출력하세요.8. 어떤 회사에서 \"compact\" 차종을 가장 많이 생산하는지 알아보려고 합니다.    각 회사별 \"compact\" 차종 수를 내림차순으로 정렬해 출력하세요.예상되는 정답.1. displ(배기량)이 4 이하인 자동차와 5 이상인 자동차 중    어떤 자동차의 hwy(고속도로 연비)가 평균적으로 더 높은지 확인하세요.   =&gt; 배기량 4이하인자동차 : 25.96319018404908      배기량 5이상인자동차 : 18.078947368421052. 자동차 제조 회사에 따라 도시 연비가 다른지 알아보려고 한다.    \"audi\"와 \"toyota\" 중 어느 manufacturer(제조회사)의 cty(도시 연비)가    평균적으로 더 높은지 확인하세요.    =&gt; audi의도시연비평균 : 17.61111111111111       toyota의도시연비평균 : 18.529411764705884 3. \"chevrolet\", \"ford\", \"honda\" 자동차의 고속도로 연비 평균을 알아보려고 한다.    이 회사들의 데이터를 추출한 후 hwy(고속도로 연비) 평균을 구하세요.    =&gt; hwy(고속도로 연비) 평균 : 22.509433962264154. \"audi\"에서 생산한 자동차 중에 어떤 자동차 모델의 hwy(고속도로 연비)가    높은지 알아보려고 한다. \"audi\"에서 생산한 자동차 중 hwy가 1~5위에 해당하는    자동차의 데이터를 출력하세요.    =&gt; manufacturer\tmodel\tdispl\tyear\tcyl\ttrans\tdrv\tcty\thwy\tfl\tclass       2\taudi\ta4\t2.0\t2008\t4\tmanual(m6)\tf\t20\t31\tp\tcompact       3\taudi\ta4\t2.0\t2008\t4\tauto(av)\tf\t21\t30\tp\tcompact       0\taudi\ta4\t1.8\t1999\t4\tauto(l5)\tf\t18\t29\tp\tcompact       1\taudi\ta4\t1.8\t1999\t4\tmanual(m5)\tf\t21\t29\tp\tcompact       9\taudi\ta4 quattro\t2.0\t2008\t4\tmanual(m6)\t4\t20\t28\tp\tcompact5. mpg 데이터는 연비를 나타내는 변수가 2개입니다.    두 변수를 각각 활용하는 대신 하나의 통합 연비 변수를 만들어 사용하려 합니다.    평균 연비 변수는 두 연비(고속도로와 도시)의 평균을 이용합니다.    회사별로 \"suv\" 자동차의 평균 연비를 구한후 내림차순으로 정렬한 후 1~5위까지 데이터를 출력하세요.   =&gt; \t        avg_fuel_efficiency     manufacturer\t     subaru\t21.916667     toyota\t16.312500     nissan\t15.875000     mercury\t15.625000     jeep\t15.562500     ford\t15.333333     chevrolet\t14.888889     lincoln\t14.166667     land rover\t14.000000     dodge\t13.928571 6. mpg 데이터의 class는 \"suv\", \"compact\" 등 자동차의 특징에 따라    일곱 종류로 분류한 변수입니다. 어떤 차종의 도시 연비가 높은지 비교하려 합니다.    class별 cty 평균을 구하고 cty 평균이 높은 순으로 정렬해 출력하세요.   =&gt; class     subcompact    20.371429     compact       20.127660     midsize       18.756098     minivan       15.818182     2seater       15.400000     suv           13.500000     pickup        13.000000     Name: cty, dtype: float647. 어떤 회사 자동차의 hwy(고속도로 연비)가 가장 높은지 알아보려 합니다.    hwy(고속도로 연비) 평균이 가장 높은 회사 세 곳을 출력하세요.   =&gt; manufacturer     honda         32.555556     volkswagen    29.222222     hyundai       26.857143     Name: hwy, dtype: float648. 어떤 회사에서 \"compact\" 차종을 가장 많이 생산하는지 알아보려고 합니다.    각 회사별 \"compact\" 차종 수를 내림차순으로 정렬해 출력하세요.   =&gt; manufacturer     audi          15     volkswagen    14     toyota        12     subaru         4     nissan         2     Name: class, dtype: int64Pandas Exercise - 3본격적으로 데이터 분석 연습문제를 풀어겠습니다.실습데이터는 한국복지패널데이터를 이용합니다. 이 데이터는 한국보건사회연구원에서전국 7000여 가구를 선정해 2006년부터 매년 추적 조사한 자료로, 경제활동, 생활실태,복지욕구등 천여 개 변수로 구성되어 있습니다.해당 데이터에는 우리나라의 다양한 삶에 대한 데이터가 들어있고 이를 분석하면 대한민국사람들이 어떻게 살아가고 있는가를 분석할 수 있습니다.사용할 한국복지패널데이터 데이터 파일# 한국복지패널데이터를 이용한 데이터 분석 연습# 데이터 준비# 제공된 파일의 압축을 풀면 파일이 2개 있습니다. # Koweps_hpc10_2015_beta1.sav : SPSS 데이터 파일 (128M)# Koweps_Codebook.xlsx : 우리가 사용할 column에 대한 설명# 총 7개의 column만을 이용합니다. # 데이터 파일인 Koweps_hpc10_2015_beta1.sav 파일은 # 상용 통계분석 소프트웨어인 SPSS 전용파일입니다. # 해당 데이터 파일은 SPSS 전용파일이기 때문에 pandas에서 사용하기 # 위해서 다음의 코드를 이용해서 DataFrame으로 변환해야 합니다.# pip install savReaderWriter import pandasimport savReaderWriterwith savReaderWriter.SavReader('./data/Koweps_hpc10_2015_beta1.sav', ioUtf8 = True) as reader:    df = pandas.DataFrame(reader.all(), columns = [s for s in reader.header])print(df.shape)      # # (16664, 957)df['h10_g3'].head()  # 성별df['h10_g4'].head()  # 태어난 연도  준비된 데이터를 이용하여 데이터 분석을 진행합니다.1. 성별에 따른 월급 차이   과거에 비해 여성의 사회 진출이 활발하지만 직장에서의   위상에서는 여전히 차별이 존재하고 있는것이 사실.   실제로 그러한지 월급의 차이를 이용하여 사실을 확인해보자2. 나이와 월급의 관계   평균적으로 몇 살 때 월급을 가장 많이 받을까? 또 그때의 평균 월급은 얼마인가?3. 연령대에 따른 월급 차이   30세 미만을 초년(young),    30~59세 : 중년(middle),    60세 이상 : 노년(old)   위의 범주로 연령대에 따른 월급의 차이를 알아보자4. 연령대 및 성별 월급 차이   성별 월급 차이는 연령대에 따라 다른 양상을 보일 수 있습니다.   성별 월급 차이가 연령대에 따라 다른지 분석해보자   기존에는 3그룹(초년,중년,노년)이었지만 이젠 6그룹으로   그룹핑을 해야 한다.(초년남성,초년여성,..)5. 직업별 월급 차이   어떤 직업이 월급을 가장 많이 받을까?   직업별 월급을 분석해 보자   직업코드는 제공된 Koweps_Codebook.xlsx을 이용하면    편하게 코드값을 이용 할 수 있습니다.6. 성별 직업 빈도   성별로 어떤 직업이 가장 많을까?7. 종교 유무에 따른 이혼율   종교가 있는 사람들이 이혼을 덜 할까??   종교있는 사람과 종교가 없는 사람들의 총원이 다르기 때문에   각 파트의 이혼률을 구해서 비교하면 될 듯 합니다.    8. 지역별 연령대 비율   노년층이 많은 지역은 어디일까?   노년층의 수가 많은 지역이 어디인지를 알아내는 문제입니다. 각 지역마다 노년층의   인구수를 구해서 가장 많은 노년층 인구가 있는 지역을 출력하시면 됩니다.예상되는 정답.1. 성별에 따른 월급 차이   과거에 비해 여성의 사회 진출이 활발하지만 직장에서의   위상에서는 여전히 차별이 존재하고 있는것이 사실.   실제로 그러한지 월급의 차이를 이용하여 사실을 확인해보자    ==&gt; # 결과        # 남성 평균 월급 : 312.2932        # 여성 평균 월급 : 163.2471        # 남성이 여성보다 월급이 약 150만원 많다.2. 나이와 월급의 관계   평균적으로 몇 살 때 월급을 가장 많이 받을까? 또 그때의 평균 월급은 얼마인가?   ==&gt; 월급을 가장 많이 받는 나이는 : 53살, 월급 : 318.6777   3. 연령대에 따른 월급 차이   30세 미만을 초년(young),    30~59세 : 중년(middle),    60세 이상 : 노년(old)   위의 범주로 연령대에 따른 월급의 차이를 알아보자   ==&gt; # 초년(young) : 163.5953       # 중년(middle) : 281.8871       # 노년(old) : 125.32954. 연령대 및 성별 월급 차이   성별 월급 차이는 연령대에 따라 다른 양상을 보일 수 있습니다.   성별 월급 차이가 연령대에 따라 다른지 분석해보자   기존에는 3그룹(초년,중년,노년)이었지만 이젠 6그룹으로   그룹핑을 해야 한다.(초년남성,초년여성,..)   ==&gt; # 초년 남성 : 170.81737       # 초년 여성 : 159.50518       # 중년 남성 : 353.07574       # 중년 여성 : 187.97552       # 노년 남성 : 173.85558       # 노년 여성 : 81.529175. 직업별 월급 차이   어떤 직업이 월급을 가장 많이 받을까?   직업별 월급을 분석해 보자   직업코드는 제공된 Koweps_Codebook.xlsx을 이용하면    편하게 코드값을 이용 할 수 있습니다. 6. 성별 직업 빈도   성별로 어떤 직업이 가장 많을까?7. 종교 유무에 따른 이혼율   종교가 있는 사람들이 이혼을 덜 할까??8. 지역별 연령대 비율   노년층이 많은 지역은 어디일까?End.Data-Science 강좌는 아래의 책과 사이트를 참조했습니다.    조금 더 자세한 사항을 알고 싶으시면 해당 사이트를 방문하세요!!",
        "url": "/data-science-lecture-python-pandas-dataframe-exercise"
    }
    ,
    
    "data-science-lecture-python-pandas-dataframe-group": {
        "title": "Python 데이터분석 라이브러리(9) - Pandas(DataFrame Grouping)",
            "author": "moon9342",
            "category": "",
            "content": "Data-Science 강의는 여러 절로 구성되어 있습니다.     Python 데이터분석 라이브러리(1) - NumPy    Python 데이터분석 라이브러리(2) - NumPy(Exercise)    Python 데이터분석 라이브러리(3) - Pandas(Series)    Python 데이터분석 라이브러리(4) - Pandas(DataFrame 생성)    Python 데이터분석 라이브러리(5) - Pandas(DataFrame indexing)    Python 데이터분석 라이브러리(6) - Pandas(DataFrame functions)    Python 데이터분석 라이브러리(7) - Pandas(DataFrame merge)    Python 데이터분석 라이브러리(8) - Pandas(DataFrame 제어)    Python 데이터분석 라이브러리(9) - Pandas(DataFrame Grouping)    Python 데이터분석 라이브러리(10) - Pandas(Exercise)Series Grouping# Series Groupingimport numpy as npimport pandas as pddf = pd.DataFrame({ \"학과\" : [\"컴퓨터\",\"체육교육과\",\"컴퓨터\",\"체육교육과\",\"컴퓨터\"],                    \"학년\" : [1, 2, 3, 2, 3],                    \"이름\" : [\"홍길동\",\"김연아\",\"최길동\",\"아이유\",\"신사임당\"],                    \"학점\" : [1.5, 4.4, 3.7, 4.5, 3.8]})display(df)# 학과에 학년에 중복된 값이 있다.# 학과를 기준으로 grouping작업dept = df[\"학점\"].groupby(df[\"학과\"])  display(dept)    # &lt;pandas.core.groupby.generic.SeriesGroupBy object at ~ &gt;# 그룹 안에 데이터를 확인하고 싶은 경우에는 get_group() 사용print(dept.get_group('컴퓨터'))   # Series로 리턴# 각 그룹의 사이즈를 확인하고 싶은 경우에는 size() 사용print(dept.size())  # Series로 리턴             # 각 그룹의 평균을 알고 싶은 경우print(dept.mean())print(\"=\"*30)# 2단계 groupingdept_year = df[\"학점\"].groupby([df[\"학과\"],df[\"학년\"]])print(dept_year.mean())# unstack을 이용하여 최하위 index를 column으로 설정display(dept_year.mean().unstack())DataFrame Grouping# DataFrame Groupingimport numpy as npimport pandas as pddf = pd.DataFrame({ \"학과\" : [\"컴퓨터\",\"체육교육과\",\"컴퓨터\",\"체육교육과\",\"컴퓨터\"],                    \"학년\" : [1, 2, 3, 2, 3],                    \"이름\" : [\"홍길동\",\"김연아\",\"최길동\",\"아이유\",\"신사임당\"],                    \"학점\" : [1.5, 4.4, 3.7, 4.5, 3.8]})display(df)# 학과에 학년에 중복된 값이 있다.# 학과를 기준으로 grouping작업df_group_dept = df.groupby(df[\"학과\"])  display(df_group_dept)    # &lt;pandas.core.groupby.generic.DataFrameGroupBy object at ~ &gt;# 그룹 안에 데이터를 확인하고 싶은 경우에는 get_group() 사용display(df_group_dept.get_group('컴퓨터'))   # DataFrame으로 리턴# 각 그룹의 사이즈를 확인하고 싶은 경우에는 size() 사용print(df_group_dept.size())  # Series로 리턴             # 각 그룹의 평균을 알고 싶은 경우display(df_group_dept.mean())print(\"=\"*30)# 2단계 groupingdf_dept_year = df.groupby([\"학과\",\"학년\"])display(df_dept_year.mean())# unstack을 이용하여 최하위 index를 column으로 설정display(df_dept_year.mean().unstack())DataFrame 다양한 Grouping# DataFrame 다양한 Groupingimport numpy as npimport pandas as pddf = pd.DataFrame({ \"학과\" : [\"컴퓨터\",\"체육교육과\",\"컴퓨터\",\"체육교육과\",\"컴퓨터\"],                    \"학년\" : [1,2,3,2,3],                    \"이름\" : [\"홍길동\",\"김연아\",\"최길동\",\"아이유\",\"신사임당\"],                    \"학점\" : [1.5, 4.4, 3.7, 4.5, 3.8]})display(df)# 학과별 평균학점은?# print(df[\"학점\"].groupby(df[\"학과\"]).mean())# 학과별 평균학점의 다른 표현# print(df.groupby(df[\"학과\"])[\"학점\"].mean())# 학과, 학년별 평균 학점은?# display(df.groupby([df[\"학과\"],df[\"학년\"]]).mean())# display(df.groupby([\"학과\",\"학년\"]).mean())# 학과별 몇명이 존재하는가?# print(df.groupby(df[\"학과\"])[\"이름\"].count())DataFrame Grouping과 반복문import numpy as npimport pandas as pddf = pd.DataFrame({ \"학과\" : [\"컴퓨터\",\"체육교육과\",\"컴퓨터\",\"체육교육과\",\"컴퓨터\"],                    \"학년\" : [1,2,3,2,3],                    \"이름\" : [\"홍길동\",\"김연아\",\"최길동\",\"아이유\",\"신사임당\"],                    \"학점\" : [1.5, 4.4, 3.7, 4.5, 3.8]})display(df)# 학과로 그룹핑한 후 for문을 이용한 반복 처리for dept, group in df.groupby(df[\"학과\"]):    print(\"=\"*30)    print(dept)    display(group)    # 학과와 학년으로 Grouping한 후 for문을 이용한 반복 처리for (dept, year), group in df.groupby([\"학과\",\"학년\"]):    print(\"=\"*30)    print(dept)    print(year)    display(group)DataFrame Grouping 후 데이터 변환import numpy as npimport pandas as pddf = pd.DataFrame({ \"학과\" : [\"컴퓨터\",\"체육교육과\",\"컴퓨터\",\"체육교육과\",\"컴퓨터\"],                    \"학년\" : [1,2,3,2,3],                    \"이름\" : [\"홍길동\",\"김연아\",\"최길동\",\"아이유\",\"신사임당\"],                    \"학점\" : [1.5, 4.4, 3.7, 4.5, 3.8]})display(df)# grouping한 내용을 list로 변환myList = list(df.groupby(df[\"학과\"]))  # tuple형태의 list가 생성(group명,DataFrame)print(type(myList[0])) # &lt;class 'tuple'&gt;print(myList[0][0]) # 체육교육과print(type(myList[0][1])) # &lt;class 'pandas.core.frame.DataFrame'&gt;###my_list = [('홍길동',20), ('김길동',30), ('최길동',50)]my_dict = dict(my_list)print(my_dict)  # {'홍길동': 20, '김길동': 30, '최길동': 50}myDict = dict(myList) print(myDict)display(myDict[\"컴퓨터\"])End.Data-Science 강좌는 아래의 책과 사이트를 참조했습니다.    조금 더 자세한 사항을 알고 싶으시면 해당 사이트를 방문하세요!!",
        "url": "/data-science-lecture-python-pandas-dataframe-group"
    }
    ,
    
    "data-science-lecture-python-pandas-dataframe-transform": {
        "title": "Python 데이터분석 라이브러리(8) - Pandas(DataFrame 제어)",
            "author": "moon9342",
            "category": "",
            "content": "Data-Science 강의는 여러 절로 구성되어 있습니다.     Python 데이터분석 라이브러리(1) - NumPy    Python 데이터분석 라이브러리(2) - NumPy(Exercise)    Python 데이터분석 라이브러리(3) - Pandas(Series)    Python 데이터분석 라이브러리(4) - Pandas(DataFrame 생성)    Python 데이터분석 라이브러리(5) - Pandas(DataFrame indexing)    Python 데이터분석 라이브러리(6) - Pandas(DataFrame functions)    Python 데이터분석 라이브러리(7) - Pandas(DataFrame merge)    Python 데이터분석 라이브러리(8) - Pandas(DataFrame 제어)    Python 데이터분석 라이브러리(9) - Pandas(DataFrame Grouping)    Python 데이터분석 라이브러리(10) - Pandas(Exercise)DataFrame 조작 (DataFrame 생성)# DataFrame 조작 (DataFrame 생성)# random seed 고정# [0,10) 사이의 정수형 난수를 균등분포로 추출해서 # 6행 4열 DataFrame 생성# cloumn과 index는 따로 지정하지 않는다. (column도 숫자로 표현)import numpy as npimport pandas as pdnp.random.seed(1)df = pd.DataFrame(np.random.randint(0,10,(6,4)))display(df)DataFrame 조작 (index와 column 재정의)# DataFrame 조작 (index와 column 재정의)# column : \"A\", \"B\", \"C\", \"D\"# index : 날짜를 이용, 2020-01-01부터 1일씩 증가import numpy as npimport pandas as pdnp.random.seed(1)df = pd.DataFrame(np.random.randint(0,10,(6,4)))df.columns = [\"A\", \"B\", \"C\", \"D\"]df.index = pd.date_range(\"20200101\", periods=6)# df.index = pd.date_range(\"20200101\", \"20200106\")display(df)DataFrame 조작 (새로운 column 추가)# DataFrame 조작 (새로운 column 추가)# NaN값을 포함하는 \"E\" column 추가# \"E\" column의 데이터 : [7, np.nan, 4, np.nan, 2, np.nan]import numpy as npimport pandas as pdnp.random.seed(1)df = pd.DataFrame(np.random.randint(0,10,(6,4)))df.columns = [\"A\", \"B\", \"C\", \"D\"]df.index = pd.date_range(\"20200101\", periods=6)df[\"E\"] = [7, np.nan, 4, np.nan, 2, np.nan]# NaN은 float로 간주display(df)DataFrame 조작 (결측값 제거)# DataFrame 조작 (결측값 제거)# NaN값 제거import numpy as npimport pandas as pdnp.random.seed(1)df = pd.DataFrame(np.random.randint(0,10,(6,4)))df.columns = [\"A\", \"B\", \"C\", \"D\"]df.index = pd.date_range(\"20200101\", periods=6)df[\"E\"] = [7, np.nan, 4, np.nan, 2, np.nan] # NaN은 float로 간주new_df = df.dropna(how=\"any\")                            # (how=\"any\") =&gt; NaN이 하나라도 포함되어 있는 행 삭제                        # (how=\"all\") =&gt; 모든 column의 값이 NaN인 행 삭제                            # 결과 DataFrame을 return, 원본 변경 X                        # inplace=True인 경우 원본 변경.            display(new_df)DataFrame 조작 (결측값 대체)# DataFrame 조작 (결측값 대체)# NaN값을 다른값으로 대체import numpy as npimport pandas as pdnp.random.seed(1)df = pd.DataFrame(np.random.randint(0,10,(6,4)))df.columns = [\"A\", \"B\", \"C\", \"D\"]df.index = pd.date_range(\"20200101\", periods=6)df[\"E\"] = [7, np.nan, 4, np.nan, 2, np.nan] # NaN은 float로 간주new_df = df.fillna(value=0)                        # 결과 DataFrame을 return, 원본 변경 X                        # inplace=True인 경우 원본 변경.display(new_df)DataFrame 조작 (결측값 boolean mask 활용)# DataFrame 조작 (결측값 boolean mask 활용)# NaN에 대한 boolean mask활용# \"E\" column의 값이 NaN인 행들을 찾아 해당 행의 모든 column 출력import numpy as npimport pandas as pdnp.random.seed(1)df = pd.DataFrame(np.random.randint(0,10,(6,4)))df.columns = [\"A\", \"B\", \"C\", \"D\"]df.index = pd.date_range(\"20200101\", periods=6)df[\"E\"] = [7, np.nan, 4, np.nan, 2, np.nan] # NaN은 float로 간주display(df.isnull())  # NaN에 대한 boolean maskdisplay(df.loc[df.isnull()[\"E\"],:])DataFrame 변형 - 중복행 제거import numpy as npimport pandas as pddf=pd.DataFrame({ \"k1\" : [\"one\"] * 3 + [\"two\"] * 4,                  \"k2\" : [1,1,2,3,3,4,4] })display(df)print(df.duplicated())              # Series형태의 boolean maskdisplay(df.loc[df.duplicated(),:])  # 중복행 알아내기display(df.drop_duplicates())       # 중복행 제거#########df=pd.DataFrame({ \"k1\" : [\"one\"] * 3 + [\"two\"] * 4,                  \"k2\" : [1,1,2,3,3,4,4] })df[\"k3\"] = np.arange(7)display(df)display(df.drop_duplicates())             # 삭제되는 행이 없다.display(df.drop_duplicates([\"k1\"]))       # 특정열을 기준으로 중복삭제display(df.drop_duplicates([\"k1\",\"k2\"]))  # keep=\"first\"# df.drop_duplicates([\"k1\",\"k2\"], keep=\"last\")  # 중복된 마지막 행을 남긴다.DataFrame 변형 - replaceimport numpy as npimport pandas as pds = pd.Series([1,-999,2,-999,-1000,3.0])# 이상치를 찾아서 치환new_s = s.replace(-999, np.nan)print(new_s)new_s = new_s.replace(np.nan,0)  # new_s.fillna(0)print(new_s)######np.random.seed(1)df = pd.DataFrame(np.random.randint(0,10,(6,4)))df.columns = [\"A\", \"B\", \"C\", \"D\"]df.index = pd.date_range(\"20200101\", periods=6)df[\"E\"] = [7, np.nan, 4, np.nan, 2, np.nan] # NaN은 float로 간주display(df)display(df.replace(np.nan,-100))DataFrame 변형 - category# Categories 데이터형import numpy as npimport pandas as pddf = pd.DataFrame( {\"id\" : [1,2,3,4,5,6],                    \"raw_grade\" : [\"a\",\"b\",\"b\",\"a\",\"a\",\"e\"]})df[\"grade\"] = df[\"raw_grade\"].astype(\"category\")display(df)print(df[\"grade\"])print(df[\"grade\"].cat.categories)   # category 확인df[\"grade\"].cat.categories = [\"good\",\"normal\",\"bad\"]  # category 이름 변경display(df)# 새로운 category를 정의 ( category의 수를 증감 )# df[\"grade\"] = df[\"grade\"].cat.set_categories([\"very good\", \"good\",\"normal\",\"bad\", \"very bad\"])# display(df)# category는 정의된 순서에 따라서 대소관계를 가진다.df.sort_values(by=\"grade\")DataFrame 변형 - 숫자데이터의 category# 숫자데이터의 category화import numpy as npimport pandas as pdages = [20,22,25,27,21,23,37,31,61,45,41,32]bins = [18,25,35,60,100]   # 숫자값 구분(총 4개의 구간, 초과~이하)cats = pd.cut(ages,bins)print(cats.categories) # 생성된 category 확인print(cats.codes)  # category의 숫자화 ( 각 성분의 위치 )print(cats.value_counts())  # 각 category의 count# 각 category의 이름을 지정group_names = [\"young\",\"youngAdult\",\"middleAge\",\"Senior\"]cats = pd.cut(ages,bins, labels=group_names)print(cats)End.Data-Science 강좌는 아래의 책과 사이트를 참조했습니다.    조금 더 자세한 사항을 알고 싶으시면 해당 사이트를 방문하세요!!",
        "url": "/data-science-lecture-python-pandas-dataframe-transform"
    }
    ,
    
    "data-science-lecture-python-pandas-dataframe-merge": {
        "title": "Python 데이터분석 라이브러리(7) - Pandas(DataFrame merge)",
            "author": "moon9342",
            "category": "",
            "content": "Data-Science 강의는 여러 절로 구성되어 있습니다.     Python 데이터분석 라이브러리(1) - NumPy    Python 데이터분석 라이브러리(2) - NumPy(Exercise)    Python 데이터분석 라이브러리(3) - Pandas(Series)    Python 데이터분석 라이브러리(4) - Pandas(DataFrame 생성)    Python 데이터분석 라이브러리(5) - Pandas(DataFrame indexing)    Python 데이터분석 라이브러리(6) - Pandas(DataFrame functions)    Python 데이터분석 라이브러리(7) - Pandas(DataFrame merge)    Python 데이터분석 라이브러리(8) - Pandas(DataFrame 제어)    Python 데이터분석 라이브러리(9) - Pandas(DataFrame Grouping)    Python 데이터분석 라이브러리(10) - Pandas(Exercise)DataFrame merge - inner join# DataFrame merge# inner join의 효과import numpy as npimport pandas as pddata1 = { \"학번\" : [1,2,3,4],          \"이름\" : [\"이지안\",\"박동훈\",\"이순신\",\"강감찬\"],          \"학년\" : [2,4,1,3]}data2 = { \"학번\" : [1,2,4,5],          \"학과\" : [\"CS\",\"MATH\",\"MATH\",\"CS\"],          \"학점\" : [3.4,2.9,4.5,1.2]}df1 = pd.DataFrame(data1)df2 = pd.DataFrame(data2)display(df1)display(df2)display(pd.merge(df1, df2, on=\"학번\", how=\"inner\"))DataFrame merge - outer,left,right join# DataFrame merge# full outer join, left outer join, right outer joinimport numpy as npimport pandas as pddata1 = { \"학번\" : [1,2,3,4],          \"이름\" : [\"이지안\",\"박동훈\",\"이순신\",\"강감찬\"],          \"학년\" : [2,4,1,3]}data2 = { \"학번\" : [1,2,4,5],          \"학과\" : [\"CS\",\"MATH\",\"MATH\",\"CS\"],          \"학점\" : [3.4,2.9,4.5,1.2]}df1 = pd.DataFrame(data1)df2 = pd.DataFrame(data2)display(df1)display(df2)display(pd.merge(df1, df2, on=\"학번\", how=\"outer\"))display(pd.merge(df1, df2, on=\"학번\", how=\"left\"))display(pd.merge(df1, df2, on=\"학번\", how=\"right\"))DataFrame merge - 컬럼명이 다른 경우# DataFrame merge# 컬럼명이 다른 경우의 mergeimport numpy as npimport pandas as pddata1 = { \"학번\" : [1,2,3,4],          \"이름\" : [\"이지안\",\"박동훈\",\"이순신\",\"강감찬\"],          \"학년\" : [2,4,1,3]}data2 = { \"학생학번\" : [1,2,4,5],          \"학과\" : [\"CS\",\"MATH\",\"MATH\",\"CS\"],          \"학점\" : [3.4,2.9,4.5,1.2]}df1 = pd.DataFrame(data1)df2 = pd.DataFrame(data2)# DataFrame의 column명이 다른 경우pd.merge(df1, df2, left_on=\"학번\", right_on=\"학생학번\", how=\"inner\")DataFrame merge - column과 index를 이용한 mergeindex를 이용한 merge는 결과로 만들어지는 DataFrame의 index에 주의해야 합니다.DataFrame을 생성한 후 index부분을 살펴보면 이해하실 수 있습니다.# DataFrame merge# DataFrame의 column과 index를 이용한 mergeimport numpy as npimport pandas as pddata1 = { \"학번\" : [1,2,3,4],          \"이름\" : [\"이지안\",\"박동훈\",\"이순신\",\"강감찬\"],          \"학년\" : [2,4,1,3]}data2 = { \"학과\" : [\"CS\",\"MATH\",\"MATH\",\"CS\"],          \"학점\" : [3.4,2.9,4.5,1.2]}df1 = pd.DataFrame(data1)df2 = pd.DataFrame(data2, index=[1,2,4,5]) # 학번이 index로 사용display(df1)display(df2)result = pd.merge(df1, df2,                   left_on=\"학번\",                   right_index=True,                   how=\"inner\")display(result)result.loc[2] # Errorresult.loc[3] # OKresult.iloc[2] # OKresult.iloc[3] # ErrorDataFrame merge - index를 이용한 merge# DataFrame merge# DataFrame의 index를 이용한 mergeimport numpy as npimport pandas as pddata1 = { \"이름\" : [\"이지안\",\"박동훈\",\"이순신\",\"강감찬\"],          \"학년\" : [2,4,1,3]}data2 = { \"학과\" : [\"CS\",\"MATH\",\"MATH\",\"CS\"],          \"학점\" : [3.4,2.9,4.5,1.2]}df1 = pd.DataFrame(data1, index=[1,2,3,4]) # 학번이 index로 사용df2 = pd.DataFrame(data2, index=[1,2,4,5]) # 학번이 index로 사용display(df1)display(df2)result = pd.merge(df1, df2,                   left_index=True,                   right_index=True,                   how=\"inner\")display(result)result.iloc[2]  # OK, 강감찬result.loc[2]  # OK, 박동훈# result.loc[3]   # ErrorDataFrame concatenation-Series 연결# DataFrame concatenation# Series를 1차원, 2차원으로 연결import numpy as npimport pandas as pds1 = pd.Series([0,1], index=[\"a\",\"c\"])s2 = pd.Series([4,3,2], index=[\"b\",\"c\",\"e\"])s3 = pd.Series([5,6], index=[\"f\",\"g\"])# Series를 1차원으로 연결display(pd.concat([s1,s2,s3], axis=0))# Series를 2차원으로 연결 =&gt; DataFrame생성# 중복된 index처리에 주의result = pd.concat([s1,s2,s3],                    axis=1,                    sort=True)  # index 정렬display(result)# Series를 2차원으로 연결 후 columns명 설정result = pd.concat([s1,s2,s3],                    axis=1,                    sort=True,                    keys=[\"one\",\"two\",\"three\"])display(result)DataFrame concatenation-DataFrame 연결# DataFrame concatenation# DataFrame을 열과 행 방향으로 연결import numpy as npimport pandas as pddf1 = pd.DataFrame(np.arange(6).reshape(3,2),                   index=[\"a\",\"c\",\"b\"], columns=[\"one\",\"two\"])df2 = pd.DataFrame(5 + np.arange(4).reshape(2,2),                   index=[\"a\",\"b\"], columns=[\"three\",\"four\"])display(df1)display(df2)# DataFrame의 concatenateresult = pd.concat([df1, df2],                    axis=1,                    sort=True)  # index 정렬display(result)# DataFrame의 concatenate ( index를 새로 설정 )result = pd.concat([df1, df2],                    axis=0,                    ignore_index=False,                    sort=False) # column 정렬display(result)End.Data-Science 강좌는 아래의 책과 사이트를 참조했습니다.    조금 더 자세한 사항을 알고 싶으시면 해당 사이트를 방문하세요!!",
        "url": "/data-science-lecture-python-pandas-dataframe-merge"
    }
    ,
    
    "data-science-lecture-python-pandas-dataframe-functions": {
        "title": "Python 데이터분석 라이브러리(6) - Pandas(DataFrame functions)",
            "author": "moon9342",
            "category": "",
            "content": "Data-Science 강의는 여러 절로 구성되어 있습니다.     Python 데이터분석 라이브러리(1) - NumPy    Python 데이터분석 라이브러리(2) - NumPy(Exercise)    Python 데이터분석 라이브러리(3) - Pandas(Series)    Python 데이터분석 라이브러리(4) - Pandas(DataFrame 생성)    Python 데이터분석 라이브러리(5) - Pandas(DataFrame indexing)    Python 데이터분석 라이브러리(6) - Pandas(DataFrame functions)    Python 데이터분석 라이브러리(7) - Pandas(DataFrame merge)    Python 데이터분석 라이브러리(8) - Pandas(DataFrame 제어)    Python 데이터분석 라이브러리(9) - Pandas(DataFrame Grouping)    Python 데이터분석 라이브러리(10) - Pandas(Exercise)DataFrame 분석용 함수## 기댓값(expected value) : 어떤 확률을 가진 사건을 무한히 반복했을 경우 ##                         얻을 수 있는 값의 평균으로서 기대할 수 있는 값# 주사위 1개를 던지는 사건을 무한히 반복했을 경우 기댓값은?# import numpy as np# result = np.random.randint(1,7,(100000,))# print(result.mean())## 편차( deviation ) : 확률변수 X와 평균값(기댓값)의 차이. ## 국민개개인의 소득을 이용하여 국민평균 소득을 산출한 후 ## 편차의 관점에서 데이터를 바라보면 얼마나 양극화가 진행됬는지## 대략 가늠할 수 있다.## 데이터의 흩어진 정도를 알기 위해 편차의 평균을 이용하면 될 듯 하다. ## 하지만 편차의 합계는 0이기 때문에 평균을 구할 수 없고## 결국 데이터의 흩어진 정도를 수치화 하기 힘들다.## 분산 ( variance ) : 데이터의 흩어진 정도를 알기 위해 사용하는 편차의 제곱의 평균.## 하지만 제곱한 값이기 때문에 사용하기 애매하다.## 표준편차 ( standard deviation ) : 분산의 제곱근## 데이터가 얼마나 흩어져 있는지, 얼마나 차이가 심한지를 알 수 있음.# 평균, 편차, 분산, 표준편차import numpy as nparr = np.array([4,6,1,3,8,8], dtype=np.int32)print(arr)print(\"합계 : {}\".format(arr.sum()))print(\"평균 : {}\".format(arr.mean()))print(\"분산 : {}\".format(arr.var()))print(\"표준편차 : {}\".format(arr.std()))DataFrame 분석용 함수 - 공분산## 공분산 ( covariance ) : 두 개의 확률변수의 관계를 보여주는 값## 확률변수 X(독립변수)와 Y(종속변수)에 대해 X가 변할 때 Y가 변하는 정도를 나타내는 값## 공분산은 두 확률변수 편차의 곱에 대한 평균으로 이 역시## 데이터가 평균으로 부터 얼마나 떨어져 있는가를 나타낸 값.## 그래프를 이용하여 공분산의 의미를 이해해보자.import numpy as npimport pandas as pdimport matplotlib.pyplot as plt# 독립변수 X에 대해 종속변수 Y의 값을 랜덤하게 구해보자np.random.seed(2)x = np.random.randint(-20,20,(10,))y = np.random.randint(-10,10,(10,))x_mean = x.mean()y_mean = y.mean()# 이렇게 구한 값을 산점도로 표현해보자plt.scatter(x,y,color=\"red\")plt.scatter(x_mean,y_mean,color=\"blue\")plt.show()# x가 변할 때 y가 어떻게 변하는지를 확인할 수 있다.# 평균을 기준으로 1,3 사분면에 있는 점들은 x가 증가할 때 y가 증가하거나#                                          x가 감소할 때 y가 감소# 평균을 기준으로 2,4 사분면에 있는 점들은 x가 증가할 때 y가 감소하거나#                                          x가 감소할 때 y가 증가# 공분산은 이런 데이터의 변화량에 대한 총합# 따라서 공분산이 양수인지 음수인지에 따라 데이터의 방향성을 알 수 있다.# 다만, 단위의 문제 때문에 실제 어느정도의 연관성을 가지는지에 대한 내용은# 알 수 없다.## 모공분산은 두 확률변수 각각의 편차의 곱에 대한 평균으로 표현되고## 표준공분산은 두 확률변수 각각의 편차의 곱에 대한 합을 n-1로 나눠 계산한다.## 표준공분산이 n-1로 나누는 이유는 이렇게 해야 더 좋은 추정량이 되기 때문이다.    ## 만약 확률변수 X와 Y가 서로 아무 관련이 없는 독립이면 공분산은 0으로 수렴된다.## 방향성이 없이 랜덤하게 무수하게 많은 샘플에 대해 값을 계산하게 되면 결국 양수,음수가## 번갈아 나오게 되서 최종적으로 0과 가까워진다.## 일반적으로 역은 성립하지 않는다. 즉, X와 Y가 독립이 아니더라도## 공분산은 0이 될 수 있다.      ## 표준공분산의 공식을 이용하여 프로그램으로 두 확률변수간의 공분산을 계산해보자import numpy as npimport pandas as pdnp.random.seed(2)sampleNum = 100x = np.random.randint(0,10,(sampleNum,))y = np.random.randint(-10,20,(sampleNum,))x_mean = x.mean()   # x의 평균y_mean = y.mean()   # y의 평균x_deviation = x-x_mean; y_deviation = y-y_mean; result = 0;for i in range(sampleNum):    result += (x_deviation[i] * y_deviation[i])    result_covariance = result / (sampleNum-1);  # 표준공분산(n-1)print(result_covariance)print(np.cov(x,y))   # numpy의 함수를 이용하여 계산      ## 2개의 확률 변수 중 하나의 값이 상승하는 경향을 보일 때, ## 다른 값도 상승하는 경향의 관계에 있다면, 공분산의 값은 양수. ## ( 그렇지 않은 경우 음수 )   ## 하지만 가장 큰 단점은 측정단위에 따라서 값이 달라진다는 것. ## 즉, 두 변수가 얼마나 연관되었는지 그 강도(strength)를 잘 보여주지 못하는 경향이 있다.    ## 측정 단위에 상관없이 두 변수 사이의 관계를 보여주는 값으로는 상관계수를 사용DataFrame 분석용 함수 - 공분산(예제)2018년 주식데이터 JSON# 공분산이 양수인 경우 ( KOSPI 지수와 삼성전자 주가 )# 2020년 2월 기준 코스피200 지수 내 삼성전자의 비중은 33.24%import numpy as npimport pandas as pdimport pandas_datareader.data as pdr # 설치필요from  datetime import datetimestart = datetime(2018,1,1) # 특정날짜 객체 생성end = datetime(2018,12,31)# YAHOO에서 제공하는 KOSPI 지수df_KOSPI = pdr.DataReader(\"^KS11\", \"yahoo\", start, end)df_KOSPI.to_json(\"./data/KOSPI.json\")# json 파일의 날짜값은 timestamp를 이용한다.from datetime import datetimetimestamp = 1514937600000datetime_obj = datetime.fromtimestamp(timestamp/1000)print(datetime_obj) # 2018-01-03 09:00:00# YAHOO에서 제공하는 삼성전자 주가df_SE = pdr.DataReader(\"005930.KS\", \"yahoo\", start, end)df_SE.to_json(\"./data/SE.json\")# YAHOO에서 제공하는 부산산업 지수df_BUSAN = pdr.DataReader(\"011390.KS\", \"yahoo\", start, end)df_BUSAN.to_json(\"./data/부산산업.json\")# YAHOO에서 제공하는 LIG넥스원 주가df_LIG = pdr.DataReader(\"079550.KS\", \"yahoo\", start, end)df_LIG.to_json(\"./data/LIG넥스원.json\")df_close_KOSPI = df_KOSPI[\"Close\"] # 종가데이터df_close_SE = df_SE[\"Close\"]print(np.cov(df_close_KOSPI.values,df_close_SE.values))  # 공분산# 0행 0열 : KOSPI의 공분산# 0행 1열 : KOSPI와 SE의 공분산# 1행 0열 : SE와 KOSPI의 공분산# 1행 1열 : SE의 공분산df_close_BUSAN = df_BUSAN[\"Close\"] # 종가데이터df_close_LIG = df_LIG[\"Close\"]print(np.cov(df_close_BUSAN,df_close_LIG))  # 공분산DataFrame 분석용 함수 - 상관계수## 상관관계 (Correlation) : 두 대상이 서로 연관성이 있다고 추측되는 관계## 성적과 자존감## 온라인 게임과 폭력성## 상관계수 (Correlation Coefficient) : -1과 1사이의 실수.## 일반적으로 피어슨 상관계수를 의미하며 다른 상관계수도 존재한다.## 공분산을 각 변수의 표준편차의 곱으로 나눈값 ## 하나의 변수가 변화할 때 다른 변수가 변화하는 정도를 의미## 양수일 경우 정적 상관관계, 음수일 경우 부적상관관계## 0에 가까울수록 관련성이 없음. 절대값이 1에 가까울수록 관련성이 높음.## 성적과 자존감의 상관계수가 0.8이면 성적이 높을수록 자존감이 높다고 추측   ## 단, 상관관계로 인과관계를 설명할 수 없음 (오류의 여지가 많음 )## 성적이 높기때문에 자존감이 높다 ??## 온라인게임을 많이하면 폭력적이된다 ??## 인과관계와 같이 한 변수가 다른 변수에 주는 영향력을 알아보기 위해서는## 회귀 분석(regression analysis)를 사용한다.## Network연결이 가능한 환경이라면 아래의 참고 코드를 이용하여 ## 특정 종목의 종목코드를 알아와서 pandas_datareader를 이용하여## 특정기간의 주가를 알아와서 상관계수를 구할 수 있다.## 만약 Network연결이 안되는 환경이라면 제공된 JSON파일을## 읽어들여서 DataFrame을 생성한 후 상관계수를 구해보자.import numpy as npimport pandas as pdimport jsonfile_KOSPI = open(\"C:/notebook_dir/data/KOSPI.json\",\"r\")series_KOSPI = pd.DataFrame(json.load(file_KOSPI))[\"Close\"]  # Seriesfile_SE = open(\"C:/notebook_dir/data/SE.json\",\"r\")series_SE = pd.DataFrame(json.load(file_SE))[\"Close\"] # Seriesfile_LIG = open(\"C:/notebook_dir/data/LIG넥스원.json\",\"r\")series_LIG = pd.DataFrame(json.load(file_LIG))[\"Close\"] # Seriesfile_PUSAN = open(\"C:/notebook_dir/data/부산산업.json\",\"r\")series_PUSAN = pd.DataFrame(json.load(file_PUSAN))[\"Close\"] # Series# NumPy 함수로 상관계수를 구해보자.np.corrcoef(series_KOSPI,series_SE)# 위에서 구한 Series를 이용해 DataFrame을 생성myDict = { \"KOSPI\" : series_KOSPI,           \"SE\" : series_SE,           \"LIG넥스원\" : series_LIG,           \"부산산업\" : series_PUSAN}df = pd.DataFrame(myDict)display(df.corr())   # DataFrame을 이용한 상관계수 계산###################################### 참고코드# 외부 API를 이용해 KOSPI 전체 종목코드를 읽어온 후# 종목명으로 종목코드를 검색하는 코드.import numpy as npimport pandas as pd# 전체 종목코드를 읽어온다.(네트워크 연결가능할 경우)df = pd.read_html(\"http://kind.krx.co.kr/corpgeneral/corpList.do\" + \\                  \"?method=download&amp;searchType=13\",                   header=0)[0]# JSON 파일로 저장with open('./data/전체종목코드.json', 'w', encoding='utf-8') as file:    df.to_json(file, force_ascii=False, orient=\"columns\") # 종목명으로 종목코드 검색title = \"LG화학\"  # 종목명code = \"종목코드\"   # 종목코드df = df.loc[:,[\"회사명\",\"종목코드\"]] # 회사명과 종목코드만 추출# map() : Series에서만 사용, 사용자 정의함수 호출df[\"종목코드\"] = df[\"종목코드\"].map('{:06d}'.format) # 종목코드 6자리로 변환code = df.loc[df[\"회사명\"] == title,\"종목코드\"].values[0]print(\"종목명 : {}, 종목코드 : {}\".format(title,code))DataFrame 분석용 함수 - 상관계수 실습# 주식데이터 생성# 공분산과 상관계수(피어슨 상관계수 공식이용)import numpy as npimport pandas as pdimport pandas_datareader.data as pdr # 설치필요import datetimestart = datetime.datetime(2018,1,1) # 특정날짜 객체 생성end = datetime.datetime(2018,12,31)# YAHOO에서 제공하는 LG전자 주가 데이터 중 종가LG = pdr.DataReader(\"066570.KS\", \"yahoo\", start, end)[\"Close\"]# YAHOO에서 제공하는 롯데쇼핑 주가 데이터 중 종가LOTTE = pdr.DataReader(\"023530.KS\", \"yahoo\", start, end)[\"Close\"]# YAHOO에서 제공하는 삼성전자 주가 데이터 중 종가SE = pdr.DataReader(\"005930.KS\", \"yahoo\", start, end)[\"Close\"]df = pd.DataFrame({ \"LG\" : LG , \"LOTTE\" : LOTTE, \"SE\" : SE })print(\"LG전자와 삼성전자의 공분산 : {}\".format(df[\"LG\"].cov(df[\"SE\"])))print(\"LG전자와 삼성전자의 상관계수 : {}\".format(df[\"LG\"].corr(df[\"SE\"])))print(\"LG전자와 롯데쇼핑의 상관계수 : {}\".format(df[\"LG\"].corr(df[\"LOTTE\"])))display(df.cov())    # DataFrame안의 모든 컬럼에 대한 공분산display(df.corr())   # DataFrame안의 모든 컬럼에 대한 상관계수DataFrame 분석용 함수 - sum, mean# DataFrame 분석용 함수 (Sample DataFrame 생성)import numpy as npimport pandas as pddata = [[2, np.nan],        [7, -3],        [np.nan, np.nan],        [1, -2]       ]df = pd.DataFrame(data,                   columns=[\"one\",\"two\"],                  index=[\"a\",\"b\",\"c\",\"d\"])display(df)print(df.sum())   # df.sum(axis=0)                  # skipna=True (default) =&gt; NaN은 제외                  # Series return                  print(df.sum(axis=1))print(df[\"two\"].sum())    # 특정 열에 대한 합print(df.loc[\"b\"].sum())  # 특정 행에 대한 합 skipna=False, NaN을 연산에 포함(실수처리)print(df.mean(axis=0, skipna=False))             #  skipna=True, NaN을 연산에서 배제    print(df.mean(axis=1, skipna=True))                                                    # \"one\" column의 결측값은 \"one\" column의 평균으로# \"two\" column의 결측값은 \"two\" column의 최소값으로 대체one_avg = df[\"one\"].mean() # df.mean(axis=0)[\"one\"]two_min = df[\"two\"].min()  # df.min(axis=0)[\"two\"]df[\"one\"] = df[\"one\"].fillna(value=one_avg)df[\"two\"] = df[\"two\"].fillna(value=two_min)display(df)       DataFrame 분석용 함수 - sort# DataFrame index와 column 재 설정import numpy as npimport pandas as pdnp.random.seed(1)df = pd.DataFrame(np.random.randint(0,10,(6,4)))display(df)   # 숫자 index사용, column명도 숫자 index처리df.columns = [\"A\", \"B\", \"C\", \"D\"]df.index = pd.date_range(\"20200101\", periods=6)display(df)# 순열 랜덤 치환random_date = np.random.permutation(df.index)  print(random_date)# np.random.shuffle(df.index)# shuffle()을 못쓰는 이유는 Index는 mutable opertion을 지원하지 않기때문.# index와 column이 재 설정된 DataFrame 생성df2 = df.reindex(index=random_date, columns=[\"B\",\"A\",\"D\",\"C\"])display(df2)## axis 기준으로 정렬display(df2.sort_index(axis=1, ascending=True))# axis=0 : 행(row) 기준 정렬# axis=1 : 열(column) 기준 정렬# ascending=Flase : 내림차순 정렬## 특정 column의 값으로 행 정렬display(df2.sort_values(by=\"B\"))# \"B\"값이 같을 때 \"A\"로 정렬(2차정렬)display(df2.sort_values(by=[\"B\",\"A\"]))   DataFrame 분석용 함수 - unique, value_counts, isin# DataFrame 유용한 함수들# unique(), value_counts(), isin()import numpy as npimport pandas as pdnp.random.seed(1)df = pd.DataFrame(np.random.randint(0,10,(6,4)))df.columns = [\"A\", \"B\", \"C\", \"D\"]df.index = pd.date_range(\"20200101\", periods=6)df[\"E\"] = [\"AA\",\"BB\",\"CC\",\"CC\",\"AA\",\"CC\"]display(df)print(df[\"E\"].unique())          # 중복제거(ndarray)print(df[\"E\"].value_counts())    # 각 값들의 개수 return(Series)print(df[\"E\"].isin([\"AA\",\"BB\"])) # boolean indexing(Series) DataFrame 분석용 함수 (lambda 함수)# DataFrame 유용한 함수들# python에서 배운 lambda 함수를 DataFrame의 행, 열에 apply()를 통해 적용# 각 행의 column에 대해 최대값 - 최소값을 구해 새로운 column을 추가# 각 column안에서 최대값 - 최소값을 구해 출력import numpy as npimport pandas as pdnp.random.seed(1)df = pd.DataFrame(np.random.randint(0,10,(6,4)))df.columns = [\"A\", \"B\", \"C\", \"D\"]df.index = pd.date_range(\"20200101\", periods=6)display(df)func = lambda x: x.max() - x.min()df[\"최대-최소\"] = df.apply(func, axis=1)display(df)display(df.apply(func, axis=0))  # Series returnEnd.Data-Science 강좌는 아래의 책과 사이트를 참조했습니다.    조금 더 자세한 사항을 알고 싶으시면 해당 사이트를 방문하세요!!",
        "url": "/data-science-lecture-python-pandas-dataframe-functions"
    }
    ,
    
    "data-science-lecture-python-pandas-dataframe-indexing": {
        "title": "Python 데이터분석 라이브러리(5) - Pandas(DataFrame indexing)",
            "author": "moon9342",
            "category": "",
            "content": "Data-Science 강의는 여러 절로 구성되어 있습니다.     Python 데이터분석 라이브러리(1) - NumPy    Python 데이터분석 라이브러리(2) - NumPy(Exercise)    Python 데이터분석 라이브러리(3) - Pandas(Series)    Python 데이터분석 라이브러리(4) - Pandas(DataFrame 생성)    Python 데이터분석 라이브러리(5) - Pandas(DataFrame indexing)    Python 데이터분석 라이브러리(6) - Pandas(DataFrame functions)    Python 데이터분석 라이브러리(7) - Pandas(DataFrame merge)    Python 데이터분석 라이브러리(8) - Pandas(DataFrame 제어)    Python 데이터분석 라이브러리(9) - Pandas(DataFrame Grouping)    Python 데이터분석 라이브러리(10) - Pandas(Exercise)DataFrame의 특정 column 추출 (1)# DataFrame에서 특정 column을 추출할 수 있다.# 하나의 column을 추출한 경우 Series로 returnimport numpy as npimport pandas as pddata = {\"이름\" : [\"이지은\", \"박동훈\", \"홍길동\", \"강감찬\", \"오혜영\"],        \"학과\" : [\"컴퓨터\", \"기계\", \"철학\", \"컴퓨터\", \"철학\"],        \"학년\" : [1, 2, 2, 4, 3],        \"학점\" : [1.5, 2.0, 3.1, 1.1, 2.7]}df = pd.DataFrame(data,                   columns=[\"학과\",\"이름\",\"학점\",\"학년\",\"등급\"],                  index = [\"one\",\"two\",\"three\",\"four\",\"five\"])print(df[\"이름\"])       print(type(df[\"이름\"])) # 결과는 Series로 returnprint(df.이름)  # df[\"이름\"] 방식을 더 많이 사용.DataFrame의 특정 column 추출 (2)# DataFrame에서 특정 column을 추출한 후 # 데이터를 변경하면 원본 DataFrame에도 영향을 미친다.# python에서 warning message를 on,off할 수 있다.import warningsimport numpy as npimport pandas as pdwarnings.filterwarnings(action='ignore')   # warning off# warnings.filterwarnings(action='default') # warning ondata = {\"이름\" : [\"이지은\", \"박동훈\", \"홍길동\", \"강감찬\", \"오혜영\"],        \"학과\" : [\"컴퓨터\", \"기계\", \"철학\", \"컴퓨터\", \"철학\"],        \"학년\" : [1, 2, 2, 4, 3],        \"학점\" : [1.5, 2.0, 3.1, 1.1, 2.7]}df = pd.DataFrame(data,                   columns=[\"학과\",\"이름\",\"학점\",\"학년\",\"등급\"],                  index = [\"one\",\"two\",\"three\",\"four\",\"five\"])year = df[\"학년\"]    # View가 아닌 복사본을 생성하려면 df[\"학년\"].copy() 이용year[\"one\"] = 1000   # Series의 내용을 변경(View의 내용변경)print(df[\"학년\"])display(df)          # DataFrame의 내용도 변경DataFrame에서 2개 이상의 column 추출# DataFrame에서 두개 이상의 column을 추출할 수 있다.# Fancy Indexing을 사용.# 두개 이상의 column을 추출한 경우 Series가 아닌# DataFrame으로 결과 returnimport numpy as npimport pandas as pddata = {\"이름\" : [\"이지은\", \"박동훈\", \"홍길동\", \"강감찬\", \"오혜영\"],        \"학과\" : [\"컴퓨터\", \"기계\", \"철학\", \"컴퓨터\", \"철학\"],        \"학년\" : [1, 2, 2, 4, 3],        \"학점\" : [1.5, 2.0, 3.1, 1.1, 2.7]}df = pd.DataFrame(data,                   columns=[\"학과\",\"이름\",\"학점\",\"학년\",\"등급\"],                  index = [\"one\",\"two\",\"three\",\"four\",\"five\"])# print(df[\"names\",\"year\"])     # Errordisplay(df[[\"이름\",\"학점\"]])  # Fancy IndexingDataFrame에서 특정 column 값 수정# DataFrame에서 특정 column의 값 수정# 단일값 혹은 numpy array 혹은 list를 이용하여 수정import numpy as npimport pandas as pddata = {\"이름\" : [\"이지은\", \"박동훈\", \"홍길동\", \"강감찬\", \"오혜영\"],        \"학과\" : [\"컴퓨터\", \"기계\", \"철학\", \"컴퓨터\", \"철학\"],        \"학년\" : [1, 2, 2, 4, 3],        \"학점\" : [1.5, 2.0, 3.1, 1.1, 2.7]}df = pd.DataFrame(data,                   columns=[\"학과\",\"이름\",\"학점\",\"학년\",\"등급\"],                  index = [\"one\",\"two\",\"three\",\"four\",\"five\"])display(df)df[\"등급\"] = \"A\"   # df[\"등급\"] = [\"A\",\"B\",\"D\",\"B\",\"A\"] # df[\"등급\"] = np.array([\"A\",\"B\",\"D\",\"C\",\"C\"])display(df)DataFrame에서 두 개 이상의 특정 column 값 수정# DataFrame에서 두개 이상의 특정 column 값 수정# 단일값 혹은 numnpy array 혹은 list를 이용하여 수정# 참고# DataFrame의 column을 Fancy Indexing한 후 value들만# ndarray로 추출하려면 to_numpy() 함수 사용.# df[[\"grade\",\"names\"]].to_numpy() # numpy array로 변환import numpy as npimport pandas as pddata = {\"이름\" : [\"이지은\", \"박동훈\", \"홍길동\", \"강감찬\", \"오혜영\"],        \"학과\" : [\"컴퓨터\", \"기계\", \"철학\", \"컴퓨터\", \"철학\"],        \"학년\" : [1, 2, 2, 4, 3],        \"학점\" : [1.5, 2.0, 3.1, 1.1, 2.7]}df = pd.DataFrame(data,                   columns=[\"학과\",\"이름\",\"학점\",\"학년\",\"등급\"],                  index = [\"one\",\"two\",\"three\",\"four\",\"five\"])display(df)df[[\"등급\",\"이름\"]] = \"A\"   # df[[\"등급\",\"이름\"]] = [[\"A\",\"최길동\"],#                        [\"B\",\"이길동\"],#                        [\"D\",\"박길동\"],#                        [\"B\",\"박길동\"],#                        [\"A\",\"문길동\"]#                       ]display(df)print(df[[\"학년\",\"학점\"]].to_numpy())DataFrame column 추가# 기존에 생성된 DataFrame에 column을 추가할 수 있다. # scalar, numpy array, list, Series 등을 이용해 추가# Series로 추가할 경우 index를 기반으로 추가!!import numpy as npimport pandas as pddata = {\"이름\" : [\"이지은\", \"박동훈\", \"홍길동\", \"강감찬\", \"오혜영\"],        \"학과\" : [\"컴퓨터\", \"기계\", \"철학\", \"컴퓨터\", \"철학\"],        \"학년\" : [1, 2, 2, 4, 3],        \"학점\" : [1.5, 2.0, 3.1, 1.1, 2.7]}df = pd.DataFrame(data,                   columns=[\"학과\",\"이름\",\"학점\",\"학년\",\"등급\"],                  index = [\"one\",\"two\",\"three\",\"four\",\"five\"])df[\"등급\"] = np.arange(1,10,2)df[\"나이\"] = [20,21,25,24,22]# df[\"나이\"] = [20,21,25,24] # Error(개수가 맞지 않음)# age = pd.Series([20,21,25,24,22])# df[\"나이\"] = age    # 추가되는 내용 없음 (index 기반)# age = pd.Series([20,21,25], index=[\"one\",\"two\",\"three\"])# df[\"나이\"] = age  # matching되지 못한 index는 NaNdisplay(df)DataFrame에서 연산을 통한 column 추가# 기존에 생성된 DataFrame에 연산을 통해 column을 추가할 수 있다. import numpy as npimport pandas as pddata = {\"이름\" : [\"이지은\", \"박동훈\", \"홍길동\", \"강감찬\", \"오혜영\"],        \"학과\" : [\"컴퓨터\", \"기계\", \"철학\", \"컴퓨터\", \"철학\"],        \"학년\" : [1, 2, 2, 4, 3],        \"학점\" : [1.5, 2.0, 3.1, 1.1, 2.7]}df = pd.DataFrame(data,                   columns=[\"학과\",\"이름\",\"학점\",\"학년\",\"등급\"],                  index = [\"one\",\"two\",\"three\",\"four\",\"five\"])df[\"학점\"] = df[\"학점\"] * 2df[\"장학여부\"] = df[\"학점\"] &gt; 3.0display(df)DataFrame에서 column 삭제# DataFrame에서 특정 column 삭제# drop() 이용import numpy as npimport pandas as pddata = {\"이름\" : [\"이지은\", \"박동훈\", \"홍길동\", \"강감찬\", \"오혜영\"],        \"학과\" : [\"컴퓨터\", \"기계\", \"철학\", \"컴퓨터\", \"철학\"],        \"학년\" : [1, 2, 2, 4, 3],        \"학점\" : [1.5, 2.0, 3.1, 1.1, 2.7]}df = pd.DataFrame(data,                   columns=[\"학과\",\"이름\",\"학점\",\"학년\",\"등급\"],                  index = [\"one\",\"two\",\"three\",\"four\",\"five\"])display(df)new_df = df.drop(\"등급\", axis=1, inplace=False) # inplace=True 원본 변경                                                 # return None                                                 # inplace=False 원본 변경 X                                                 # 삭제된 DataFrame return  display(new_df)display(df)DataFrame row indexing (1)# DataFrame의 Row(행) Indexing# 숫자 index 이용import numpy as npimport pandas as pddata = {\"이름\" : [\"이지은\", \"박동훈\", \"홍길동\", \"강감찬\", \"오혜영\"],        \"학과\" : [\"컴퓨터\", \"기계\", \"철학\", \"컴퓨터\", \"철학\"],        \"학년\" : [1, 2, 2, 4, 3],        \"학점\" : [1.5, 2.0, 3.1, 1.1, 2.7]}df = pd.DataFrame(data,                   columns=[\"학과\",\"이름\",\"학점\",\"학년\",\"등급\"],                  index = [\"one\",\"two\",\"three\",\"four\",\"five\"])# Column indexing# df[\"이름\"]           # OK. Series return# df[\"이름\":\"학년\"]    # Error. Slicing 불가능# df[[\"이름\",\"학점\"]]  # OK. Fancy indexing 가능                       # 참고로 Boolean Indexing은 Row Indexing 처리# Row indexing(index 숫자사용)   # df[1]               # Error. 단일 indexing이 안된다.# df[1:3]             # OK. slicing 가능 - slicing한 결과는 View# df[2:]              # OK. 일반적인 slicing가능(row)# df[[1,3]]           # Error. row에 대한 index숫자를 이용한 Fancy indexing은 안됨.DataFrame row indexing (2)# DataFrame의 row indexing# 지정한 index 이용import numpy as npimport pandas as pddata = {\"이름\" : [\"이지은\", \"박동훈\", \"홍길동\", \"강감찬\", \"오혜영\"],        \"학과\" : [\"컴퓨터\", \"기계\", \"철학\", \"컴퓨터\", \"철학\"],        \"학년\" : [1, 2, 2, 4, 3],        \"학점\" : [1.5, 2.0, 3.1, 1.1, 2.7]}df = pd.DataFrame(data,                   columns=[\"학과\",\"이름\",\"학점\",\"학년\",\"등급\"],                  index = [\"one\",\"two\",\"three\",\"four\",\"five\"])# df[\"one\"]           # Error. index를 이용해서 단일 row 추출 안됨# df[\"one\":\"three\"]   # OK. index를 이용한 row slicing가능# df[\"one\":]          # OK. 일반적인 slicing이기 때문에 가능  # df[\"two\":-1]        # Error. 숫자 index와 index를 혼합사용한 slicing안됨. # df[[\"one\",\"two\"]]   # Error. DataFrame row indexing (3)# DataFrame의 row indexing# loc[]를 이용 (일반적인 row indexing 방법)import numpy as npimport pandas as pddata = {\"이름\" : [\"이지은\", \"박동훈\", \"홍길동\", \"강감찬\", \"오혜영\"],        \"학과\" : [\"컴퓨터\", \"기계\", \"철학\", \"컴퓨터\", \"철학\"],        \"학년\" : [1, 2, 2, 4, 3],        \"학점\" : [1.5, 2.0, 3.1, 1.1, 2.7]}df = pd.DataFrame(data,                   columns=[\"학과\",\"이름\",\"학점\",\"학년\",\"등급\"],                  index = [\"one\",\"two\",\"three\",\"four\",\"five\"])# df.loc[\"one\"]           # OK. loc와 index를 이용하면 단일 row 추출 가능.                           # 결과는 Series# df.loc[\"one\":\"three\"]   # OK. loc를 index를 이용하면 row slicing가능.# df.loc[\"one\":]          # OK. loc를 index를 이용하면 row slicing가능.# df.loc[\"one\":-1]        # Error. index 혼합 사용은 안됨.# df.loc[[\"one\",\"three\"]] # OK. loc와 index를 이용한 fancy indexing 가능.# loc와 숫자 index를 이용하는 방법은 모두 Error# 숫자 index를 이용할때는 iloc를 이용# df.loc[0]               # Error. loc와 숫자 index를 이용한 단일 row 추출 안됨.# df.loc[0:3]             # Error. loc와 숫자 index를 이용한 slicing 안됨.# df.loc[[0,3]]           # Error. loc와 숫자 index를 이용한 fancy indexing 안됨.DataFrame row indexing (4)# DataFrame의 row indexing# loc[]를 이용, 특정 행과 열 slicingimport numpy as npimport pandas as pddata = {\"이름\" : [\"이지은\", \"박동훈\", \"홍길동\", \"강감찬\", \"오혜영\"],        \"학과\" : [\"컴퓨터\", \"기계\", \"철학\", \"컴퓨터\", \"철학\"],        \"학년\" : [1, 2, 2, 4, 3],        \"학점\" : [1.5, 2.0, 3.1, 1.1, 2.7]}df = pd.DataFrame(data,                   columns=[\"학과\",\"이름\",\"학점\",\"학년\",\"등급\"],                  index = [\"one\",\"two\",\"three\",\"four\",\"five\"])# df.loc[\"one\":\"three\"]                   # OK. row slicing# df.loc[\"one\":\"three\",\"이름\"]            # OK. row slicing + column 선택 =&gt; Series 리턴# df.loc[\"one\":\"three\",\"이름\":\"학년\"]     # OK. row slicing + column slicing# df.loc[\"one\":\"three\",:]                 # OK. row slicing + column slicing# df.loc[\"one\":\"three\",[\"이름\",\"학점\"]]   # OK. row slicing + column fancy slicingDataFrame boolean indexing# DataFrame에서 boolean mask 생성 후 # loc를 이용한 boolean indexing 처리import numpy as npimport pandas as pddata = {\"이름\" : [\"이지은\", \"박동훈\", \"홍길동\", \"강감찬\", \"오혜영\"],        \"학과\" : [\"컴퓨터\", \"기계\", \"철학\", \"컴퓨터\", \"철학\"],        \"학년\" : [1, 2, 2, 4, 3],        \"학점\" : [1.5, 2.0, 3.1, 1.1, 2.7]}df = pd.DataFrame(data,                   columns=[\"학과\",\"이름\",\"학점\",\"학년\",\"등급\"],                  index = [\"one\",\"two\",\"three\",\"four\",\"five\"])# 학점이 1.5점을 초과하는 학생의 이름과 학점을 DataFrame으로 출력!print(df[\"학점\"] &gt; 1.5)     # boolean MASK, Series로 returndisplay(df.loc[df[\"학점\"] &gt; 1.5, [\"이름\",\"학점\"]]) DataFrame boolean indexing 응용# DataFrame boolean indexing 응용import numpy as npimport pandas as pddata = {\"이름\" : [\"이지은\", \"박동훈\", \"홍길동\", \"강감찬\", \"오혜영\"],        \"학과\" : [\"컴퓨터\", \"기계\", \"철학\", \"컴퓨터\", \"철학\"],        \"학년\" : [1, 2, 2, 4, 3],        \"학점\" : [1.5, 2.0, 3.1, 1.1, 2.7]}df = pd.DataFrame(data,                   columns=[\"학과\",\"이름\",\"학점\",\"학년\",\"등급\"],                  index = [\"one\",\"two\",\"three\",\"four\",\"five\"])# 이름이 \"박동훈\"인 사람을 찾아 이름과 학점을 DataFrame으로 출력display(df.loc[df[\"이름\"] == \"박동훈\", [\"이름\",\"학점\"]])# 학점이 (1.5,2.5)인 사람을 찾아 학과,이름,학점을 DataFrame으로 출력display(df.loc[(df[\"학점\"] &gt; 1.5) &amp; (df[\"학점\"] &lt; 2.5) , \"학과\":\"학점\"])# 학점이 3.0을 초과하는 사람을 찾아 등급을 \"A\"로 설정하세요.df.loc[df[\"학점\"] &gt; 3.0, \"등급\"] = \"A\"display(df)DataFrame iloc를 이용한 row indexing# DataFrame iloc를 이용한 row indexingimport numpy as npimport pandas as pddata = {\"이름\" : [\"이지은\", \"박동훈\", \"홍길동\", \"강감찬\", \"오혜영\"],        \"학과\" : [\"컴퓨터\", \"기계\", \"철학\", \"컴퓨터\", \"철학\"],        \"학년\" : [1, 2, 2, 4, 3],        \"학점\" : [1.5, 2.0, 3.1, 1.1, 2.7]}df = pd.DataFrame(data,                   columns=[\"학과\",\"이름\",\"학점\",\"학년\",\"등급\"],                  index = [\"one\",\"two\",\"three\",\"four\",\"five\"])# df.iloc[1]           # OK. index 숫자를 이용해 단일 행 선택가능.# df.iloc[1:4]         # OK. index 숫자를 이용해 row slicing가능# df.iloc[1:4,0:2]     # OK. index 숫자를 이용해 row slicing + column slicing가능# df.iloc[1:4,[0,2]]   # OK. index 숫자를 이용해 row slicing + column fancy indexing가능# df.iloc[[1,4],[0,2]] # OK. index 숫자를 이용해 row fancy indexing +                       #     column fancy indexing가능# df.iloc[0,0]         # OK. 특정 위치의 값 도출DataFrame row 추가# loc를 이용한 DataFrame의 row 추가import numpy as npimport pandas as pddata = {\"이름\" : [\"이지은\", \"박동훈\", \"홍길동\", \"강감찬\", \"오혜영\"],        \"학과\" : [\"컴퓨터\", \"기계\", \"철학\", \"컴퓨터\", \"철학\"],        \"학년\" : [1, 2, 2, 4, 3],        \"학점\" : [1.5, 2.0, 3.1, 1.1, 2.7]}df = pd.DataFrame(data,                   columns=[\"학과\",\"이름\",\"학점\",\"학년\",\"등급\"],                  index = [\"one\",\"two\",\"three\",\"four\",\"five\"])df.loc[\"six\",:] = [\"컴퓨터\",\"최길동\",3.1,3,\"A\"] # index에 없기때문에 adddisplay(df)df.loc[\"seven\",\"이름\":\"학점\"] = [\"박길동\",3.1] # index에 없기때문에 add# df.loc[\"seven\",[\"이름\",\"등급\"]] = [\"박길동\",\"A\"] # Fancy indexing도 가능df.loc[\"seven\",\"이름\":] = [\"이길동\",3.1,1,\"A\"]  # index에 존재하면 replacedisplay(df)DataFrame row 삭제# DataFrame row 삭제import numpy as npimport pandas as pddata = {\"이름\" : [\"이지은\", \"박동훈\", \"홍길동\", \"강감찬\", \"오혜영\"],        \"학과\" : [\"컴퓨터\", \"기계\", \"철학\", \"컴퓨터\", \"철학\"],        \"학년\" : [1, 2, 2, 4, 3],        \"학점\" : [1.5, 2.0, 3.1, 1.1, 2.7]}df = pd.DataFrame(data,                   columns=[\"학과\",\"이름\",\"학점\",\"학년\",\"등급\"],                  index = [\"one\",\"two\",\"three\",\"four\",\"five\"])new_df = df.drop(\"학년\", axis=1) # inplace=False, 열 삭제, 원본 변경 Xdisplay(new_df)new_df = df.drop(\"one\") # inplace=False, 행 삭제(axis=0), 원본 변경 X                        # df.drop(\"one123\") key를 못 찾으면 Errordisplay(new_df)# Fancy indexing 사용 가능new_df = df.drop([\"one\",\"three\"]) # inplace=False, 행 삭제(axis=0), 원본 변경 Xdisplay(new_df)# slicing으로는 삭제 안됨.# new_df = df.drop(\"one\":\"three\") # slicing 삭제는 ErrorEnd.Data-Science 강좌는 아래의 책과 사이트를 참조했습니다.    조금 더 자세한 사항을 알고 싶으시면 해당 사이트를 방문하세요!!",
        "url": "/data-science-lecture-python-pandas-dataframe-indexing"
    }
    ,
    
    "data-science-lecture-python-pandas-dataframe-basic": {
        "title": "Python 데이터분석 라이브러리(4) - Pandas(DataFrame 생성)",
            "author": "moon9342",
            "category": "",
            "content": "Data-Science 강의는 여러 절로 구성되어 있습니다.     Python 데이터분석 라이브러리(1) - NumPy    Python 데이터분석 라이브러리(2) - NumPy(Exercise)    Python 데이터분석 라이브러리(3) - Pandas(Series)    Python 데이터분석 라이브러리(4) - Pandas(DataFrame 생성)    Python 데이터분석 라이브러리(5) - Pandas(DataFrame indexing)    Python 데이터분석 라이브러리(6) - Pandas(DataFrame functions)    Python 데이터분석 라이브러리(7) - Pandas(DataFrame merge)    Python 데이터분석 라이브러리(8) - Pandas(DataFrame 제어)    Python 데이터분석 라이브러리(9) - Pandas(DataFrame Grouping)    Python 데이터분석 라이브러리(10) - Pandas(Exercise)DataFrame 생성# pandas DataFrame 생성 (Dictionary이용)# 데이터의 개수가 맞지 않으면 DataFrame생성 시 Error# dictionary의 key가 DataFrame의 column명으로 사용# DataFrame은 Series의 집합으로 구성(Series가 DataFrame의 각각의 column에 해당)import numpy as npimport pandas as pddata = {\"names\" : [ \"아이유\", \"김연아\", \"홍길동\", \"강감찬\", \"이순신\"],        \"year\" : [2015, 2016, 2015, 2017, 2016],        \"point\" : [1.5, 2.0, 3.1, 1.1, 2.7] }df = pd.DataFrame(data)print(\"shape : {}\".format(df.shape)) # shape : (5, 3)print(\"size : {}\".format(df.size)) # size : 15print(\"ndim : {}\".format(df.ndim)) # dimension : 2display(df) # print(df)보다는 display(df)를 사용DataFrame의 index, columns, values# DataFrame의 index, columns, valuesimport numpy as npimport pandas as pddata = {\"names\" : [ \"아이유\", \"김연아\", \"홍길동\", \"강감찬\", \"이순신\"],        \"year\" : [2015, 2016, 2015, 2017, 2016],        \"point\" : [1.5, 2.0, 3.1, 1.1, 2.7] }df = pd.DataFrame(data)display(df)print(\"index : {}\".format(df.index))     # RangeIndex(start=0, stop=5, step=1)print(\"index type : {}\".format(type(df.index)))  #  &lt;class 'pandas.core.indexes.range.RangeIndex'&gt;print(\"columns : {}\".format(df.columns)) # Index(['names', 'year', 'point'], dtype='object')print(\"columns type : {}\".format(type(df.columns))) # &lt;class 'pandas.core.indexes.base.Index'&gt;print(df.values)     # 2차원 numpy arrayprint(type(df.values)) # &lt;class 'numpy.ndarray'&gt;DataFrame의 index와 column에 이름 지정# DataFrame의 index와 column에 이름 지정import numpy as npimport pandas as pddata = {\"names\" : [ \"아이유\", \"김연아\", \"홍길동\", \"강감찬\", \"이순신\"],        \"year\" : [2015, 2016, 2015, 2017, 2016],        \"point\" : [1.5, 2.0, 3.1, 1.1, 2.7] }df = pd.DataFrame(data)df.index.name = \"sNum\"df.columns.name = \"sInfo\"display(df)CSV 파일을 이용한 DataFrame 생성 (1)# CSV 파일을 이용한 DataFrame 생성# \",\"로 구분된 CSV파일을 이용하여 DataFrame을 생성# 파일의 1행의 내용으로 column 설정# student.csv\"\"\"이름,입학연도,성적아이유,2015,1.5김연아,2016,2.0홍길동,2015,3.1강감찬,2017,1.1이순신,2016,2.7\"\"\"import numpy as npimport pandas as pddf = pd.read_csv(\"./data/student.csv\")display(df)CSV 파일을 이용한 DataFrame 생성 (2)실습 CSV 파일(movies.csv)# CSV 파일을 이용한 DataFrame 생성# 제공된 MovieLens Data Set의 movies.csv파일을 읽어 DataFrame으로 생성# pandas는 문자열처리 시 numpy보다 효율적인 방법을 제공import numpy as npimport pandas as pddf = pd.read_csv(\"./data/movies.csv\")display(df.head())   # 상위 5개의 행을 출력print(df.shape)Database에서 data를 읽어와 DataFrame으로 생성실습 SQL 파일(BookTableDump.zip)MySQL 5.6버전 64-bit ZIP Archive 다운로드# MySQL Database에서 data를 읽어와 DataFrame으로 생성# MySQL 5.6버전 다운로드 후 데이터베이스 설정# 제공된 Script를 이용하여 Database 구축(Table 생성)  import pymysql.cursorsimport numpy as npimport pandas as pd# 데이터베이스 connectionconn = pymysql.connect(host=\"localhost\",                       user=\"data\",                       password=\"data\",                       db=\"library\",                       charset=\"utf8\")# 데이터 selectionkeyword = \"java\"sql = \"SELECT bisbn,btitle,bauthor,bprice FROM book WHERE btitle like '%{}%'\".format(keyword)try:    df = pd.read_sql(sql, con=conn)    display(df)except Exception as err:    print(err)finally:    conn.close()DataFrame을 JSON 파일로 저장# DataFrame을 JSON 파일로 저장# Database에서 data를 읽어와 DataFrame으로 생성 한 후# 생성된 DataFrame을 JSON형태로 파일에 저장import pymysql.cursorsimport numpy as npimport pandas as pd# 데이터베이스 connectionconn = pymysql.connect(host=\"localhost\",                       user=\"data\",                       password=\"data\",                       db=\"library\",                       charset=\"utf8\")keyword = \"여행\"sql = \"SELECT bisbn,btitle,bauthor,bprice FROM book WHERE btitle like '%{}%'\".format(keyword)df = pd.read_sql(sql, con=conn)conn.close()# DataFrame을 json형식으로 파일에 저장# 총 4가지 각기 다른 형식으로 저장이 가능.# Unicode로 파일을 생성한 후 저장해야 한글이 정상 처리됨.# 저장할 폴더까지는 생성이 되어 있어야 함.with open('./data/json/books_orient_columns.json', 'w', encoding='utf-8') as file:    df.to_json(file, force_ascii=False, orient=\"columns\") # default    # json이 생성되고 column명이 json의 key값with open('./data/json/books_orient_record.json', 'w', encoding='utf-8') as file:    df.to_json(file, force_ascii=False, orient=\"records\")     # json배열이 생성되고 배열의 요소가 json    # 각 행이 배열 요소의 json으로 생성with open('./data/json/books_orient_index.json', 'w', encoding='utf-8') as file:    df.to_json(file, force_ascii=False, orient=\"index\")     # json이 생성되고 각 행의 index가 key값, 각 행의 데이터가 value값.with open('./data/json/books_orient_values.json', 'w', encoding='utf-8') as file:    df.to_json(file, force_ascii=False, orient=\"values\")     # json 배열이 생성되고 배열의 요소가 다시 각 행의 value로 구성된 json 배열    JSON 파일을 읽어 DataFrame 생성# JSON 파일을 읽어서 DataFrame 생성import numpy as npimport pandas as pdimport json# 기본적인 파일처리# file = open(\"./data/json/books_orient_columns.json\",\"r\", encoding='utf-8')# dict_books = json.load(file)# file.close()with open(\"./data/json/books_orient_columns.json\",\"r\", encoding='utf-8') as file:    dict_books = json.load(file)   # json을 읽어서 python의 dictionary 생성print(type(dict_books))  # &lt;class 'dict'&gt;print(dict_books)df = pd.DataFrame.from_dict(dict_books, orient='columns') # orient=index                                                          # orient=columns(default)display(df)Open API(JSON)를 이용한 DataFrame 생성# 결과를 JSON으로 return하는 open API를 이용한 DataFrame 생성import numpy as npimport pandas as pdimport jsonimport urllib# 영화진흥위원회 일일 Box Office 순위 Open API 이용movie_url = \"http://www.kobis.or.kr/kobisopenapi/webservice/rest/boxoffice/searchDailyBoxOfficeList.json?key=430156241533f1d058c603178cc3ca0e&amp;targetDt=20120101\"load_page = urllib.request.urlopen(movie_url)print(load_page)  # &lt;http.client.HTTPResponse object at 0x00000209A35AED48&gt;json_page = json.loads(load_page.read())print(type(json_page)) # &lt;class 'dict'&gt;print(json_page)  movie_data = dict()rank_list = list(); title_list = list(); sales_list = list()for tmp_dict in json_page[\"boxOfficeResult\"][\"dailyBoxOfficeList\"]:    rank_list.append(tmp_dict[\"rank\"])    title_list.append(tmp_dict[\"movieNm\"])    sales_list.append(tmp_dict[\"salesAmt\"])        movie_data[\"제목\"] = title_listmovie_data[\"당일매출액\"] = sales_listdf = pd.DataFrame(movie_data)df.index = rank_listdf.index.name=\"순위\"display(df)DataFrame 생성 시 index와 column 지정# DataFrame을 생성하는 시점에 column과 index를 지정할 수 있다.# index의 개수와 데이터의 개수가 일치하지 않은 경우 Error# column의 경우 dictionary의 key와 일치하지 않는 경우# NaN(Not a Number)로 설정, NaN은 연산가능# 참고(R언어와 비교)# R에서 NA는 결치값으로 잘못된 값을 의미, NULL은 존재하지 않는 객체를 지정할 때 사용# R에서 NaN은 Not Available Number의 의미로 수학적 연산이 불가능한 수를 의미# Pandas에서는 NaN은 missing data in pandas의 의미(즉, R의 NA의 의미)# python에서 R의 NULL을 None으로 표현한다.(None의 비교는 is 연산자 이용)# NaN의 literal -&gt; np.nan으로 표현import numpy as npimport pandas as pddata = {\"이름\" : [\"이지은\", \"박동훈\", \"홍길동\", \"강감찬\", \"오혜영\"],        \"학과\" : [\"컴퓨터\", \"기계\", \"철학\", \"컴퓨터\", \"철학\"],        \"학년\" : [1, 2, 2, 4, 3],        \"학점\" : [1.5, 2.0, 3.1, 1.1, 2.7]}df = pd.DataFrame(data,                   columns=[\"학과\",\"이름\",\"평균학점\",\"학년\",\"등급\"],                  index = [\"one\",\"two\",\"three\",\"four\",\"five\"])display(df)DataFrame의 기본 분석 함수# DataFrame은 기본 분석 함수를 제공# count, mean, std, min, 25%, 50%, 75%, max 제공import numpy as npimport pandas as pddata = {\"이름\" : [\"이지은\", \"박동훈\", \"홍길동\", \"강감찬\", \"오혜영\"],        \"학과\" : [\"컴퓨터\", \"기계\", \"철학\", \"컴퓨터\", \"철학\"],        \"학년\" : [1, 2, 2, 4, 3],        \"학점\" : [1.5, 2.0, 3.1, 1.1, 2.7]}df = pd.DataFrame(data,                   columns=[\"학과\",\"이름\",\"학점\",\"학년\",\"등급\"],                  index = [\"one\",\"two\",\"three\",\"four\",\"five\"])display(df.describe())  # 수치연산이 가능한 column에 대해 통계치를 출력import numpy as nparr = np.arange(1,8)  # [1 2 3 4 5 6 7]print(np.percentile(arr,[50]))   # 2사분위      arr = np.arange(1,10)  # [1 2 3 4 5 6 7 8 9]print(np.percentile(arr,[50, 75])) # 1,3 사분위End.Data-Science 강좌는 아래의 책과 사이트를 참조했습니다.    조금 더 자세한 사항을 알고 싶으시면 해당 사이트를 방문하세요!!",
        "url": "/data-science-lecture-python-pandas-dataframe-basic"
    }
    ,
    
    "data-science-lecture-python-pandas-series": {
        "title": "Python 데이터분석 라이브러리(3) - Pandas(Series)",
            "author": "moon9342",
            "category": "",
            "content": "Data-Science 강의는 여러 절로 구성되어 있습니다.     Python 데이터분석 라이브러리(1) - NumPy    Python 데이터분석 라이브러리(2) - NumPy(Exercise)    Python 데이터분석 라이브러리(3) - Pandas(Series)    Python 데이터분석 라이브러리(4) - Pandas(DataFrame 생성)    Python 데이터분석 라이브러리(5) - Pandas(DataFrame indexing)    Python 데이터분석 라이브러리(6) - Pandas(DataFrame functions)    Python 데이터분석 라이브러리(7) - Pandas(DataFrame merge)    Python 데이터분석 라이브러리(8) - Pandas(DataFrame 제어)    Python 데이터분석 라이브러리(9) - Pandas(DataFrame Grouping)    Python 데이터분석 라이브러리(10) - Pandas(Exercise)Pandas이번에는 Pandas에 대해서 알아보겠습니다.Pandas는 고유하게 정의한 Series와 DataFrame이라는 자료구조를 사용합니다.      Series : 동일한 데이터 타입의 복수개의 성분으로 구성됩니다.        DataFrame : 서로 같거나 다른 여러 데이터 타입에 대해 Table형식으로 구성됩니다. R의DataFrame과 같은 형태입니다.  Pandas를 사용하기 위해서는 conda 명령어나 pip를 이용하여 먼저 Pandas module을 설치해야 합니다.  conda install pandasSeries 생성# Series 생성# numpy array와 비교해서 확인import numpy as npimport pandas as pd# ndarray (dtype=np.float64)arr = np.array([-1,5,10,99], dtype=np.float64)print(arr)print(arr.dtype)# ndarray (dtype=np.object)arr = np.array([-1,5,3.14,\"hello\"], dtype=np.object)print(arr)print(arr.dtype)###########################s = pd.Series([-1,5,10,99], dtype=\"float64\") # dtype=np.float64print(s)         # Series 출력(index와 value를 같이 출력)print(\"Series의 value : {}\".format(s.values))  # [-1.  5. 10. 99.]print(\"Series의 value type : {}\".format(type(s.values))) # &lt;class 'numpy.ndarray'&gt;print(\"Series의 value data type : {}\".format(s.dtype)) # float64   print(\"Series의 index data : {}\".format(s.index))  # RangeIndex(start=0, stop=4, step=1)print(\"Series의 index type : {}\".format(type(s.index))) # &lt;class 'pandas.core.indexes.range.RangeIndex'&gt;Series index 지정# Series 생성 시 index를 지정 가능 # 숫자인덱스는 기본으로 사용가능import numpy as npimport pandas as pds = pd.Series([1,5,-8,10],              dtype=np.int32,              index=['c','b','a','k'])print(s)print(\"s[1] : {}\".format(s[1]))       # 5print(\"s['c'] : {}\".format(s['c']))   # 1print(\"type(s['c']) : {}\".format(type(s['c'])))   # &lt;class 'numpy.int32'&gt;############################################s = pd.Series([1,5,-8,10],              dtype=np.int32,              index=['c','b','c','k'])   # index가 같아도 되는가? (된다.)             print(s)print(\"s['c'] : {}\".format(s['c']))    # c 1                                       # c -8# 만약 같은 index가 존재하고 해당 index로 값을 조회하면# Series 형태로 returnprint(\"type(s['c']) : {}\".format(type(s['c'])))  # &lt;class 'pandas.core.series.Series'&gt;############################################s = pd.Series([1,5,-8,10],              dtype=np.int32,              index=['c','b','a','k'])print(s)# Slicingprint(\"s[0:3]\\n{}\".format(s[0:3])) # Seriesprint(\"s['c':'k']\\n{}\".format(s['c':'k'])) # Series# s['c':'k'] 으로 slicing할 경우 'c'부터 'k'(포함)까지 slicing# Fancy Indexing &amp; Boolean Indexingprint(\"s[[0,2]]\\n{}\".format(s[[0,2]])) # Series(Fancy Indexing이용)print(\"s[s%2==0]\\n{}\".format(s[s%2==0])) # Series(Boolean Indexing이용)result = 0;for x in range(len(s)):    result += s[x]print(\"for문을 이용한 합계 : {}\".format(result)) print(\"sum() 함수를 이용한 합계 : {}\".format(s.sum()))Series 연습# A 공장의 2019-01-01부터 10일간 생산량을 Series로 저장# 생산량은 평균이 50이고 표준편차가 5인 정규분포에서 random하게 생성(정수)# 형식) 2019-01-01 52# B 공장의 2019-01-01부터 10일간 생산량을 Series로 저장# 생산량은 평균이 70이고 표준편차가 8인 정규분포에서 random하게 생성(정수)# 날짜별로 모든 공장의 생산량 합계를 구하세요!import numpy as npimport pandas as pdfrom datetime import date, datetime, timedeltafrom dateutil.parser import parsestart_day = datetime(2019,1,1)factory_A = pd.Series([int(x) for x in np.random.normal(50,5,(10,))],                     index=[start_day + timedelta(days=x) for x in range(10)]) start_day = parse(\"2019-01-01\")factory_B = pd.Series([int(x) for x in np.random.normal(70,8,(10,))],                     index=[start_day + timedelta(days=x) for x in range(10)]) # print(factory_A)# print(factory_B)print(factory_A + factory_B)## 생각해볼 문제 - 만약 서로 날짜가 다르면 어떻게 될까?## index가 같지 않을 경우 연산의 결과는 NaN## 어떻게 하면 NaN이 나오지 않고 정상적으로 처리할 수 있을까?## index를 맞춰보아요!start_day = datetime(2019,1,5)factory_A = pd.Series([int(x) for x in np.random.normal(50,5,(10,))],                     index=[start_day + timedelta(days=x) for x in range(10)]) index_a = set(factory_A.index)index_b = set(factory_B.index)index_a_b = index_a - index_b  # Factory B에 추가index_b_a = index_b - index_a  # Factory A에 추가 for i in index_a_b:    factory_B[i] = 0;    for i in index_b_a:    factory_A[i] = 0;print(factory_A + factory_B)    #################################### 딕셔너리와 동일하게 추가할 key에 값을 대입해서 Series에 데이터를 추가# drop(key)을 이용하여 키와 값을 삭제. (삭제된 Series return)s = pd.Series([1,2,3,4])print(s)s[4] = 5        # 추가할 key와 value값을 대입해서 Series에 데이터 추가print(s)s = s.drop(2)   # index 2가 삭제print(s)Dictionary로 Series 생성# Dictionary를 이용하여 Series 생성# Dictionary의 key가 index로 사용된다.# Series 자체의 이름과 index의 이름을 지정할 수 있다.# Python의 list 혹은 numpy array를 이용해서 index 변경import numpy as npimport pandas as pdmy_dict = { \"서울\" : 1000, \"부산\" : 2000, \"인천\": 3000 }s = pd.Series(my_dict)s.name = \"지역별 가격데이터\"s.index.name = \"지역명\"print(s)s.index = [\"SEOUL\", \"BUSAN\", \"INCHON\"]s.index.name = \"REGION\"print(s)End.Data-Science 강좌는 아래의 책과 사이트를 참조했습니다.    조금 더 자세한 사항을 알고 싶으시면 해당 사이트를 방문하세요!!",
        "url": "/data-science-lecture-python-pandas-series"
    }
    ,
    
    "data-science-lecture-python-numpy-exercise": {
        "title": "Python 데이터분석 라이브러리(2) - NumPy(Exercise)",
            "author": "moon9342",
            "category": "",
            "content": "Data-Science 강의는 여러 절로 구성되어 있습니다.     Python 데이터분석 라이브러리(1) - NumPy    Python 데이터분석 라이브러리(2) - NumPy(Exercise)    Python 데이터분석 라이브러리(3) - Pandas(Series)    Python 데이터분석 라이브러리(4) - Pandas(DataFrame 생성)    Python 데이터분석 라이브러리(5) - Pandas(DataFrame indexing)    Python 데이터분석 라이브러리(6) - Pandas(DataFrame functions)    Python 데이터분석 라이브러리(7) - Pandas(DataFrame merge)    Python 데이터분석 라이브러리(8) - Pandas(DataFrame 제어)    Python 데이터분석 라이브러리(9) - Pandas(DataFrame Grouping)    Python 데이터분석 라이브러리(10) - Pandas(Exercise)NumPy Exercise - 1NumPy의 기능을 숙지하기 위해 기상자료개방포털 홈페이지에서 기상관련 데이터를 제공받아 데이터 분석을 하는 실습을 진행합니다.기상자료개방포털CSV 파일 다운로드  기후통계분석 &gt; 통계분석 &gt; 기온분석위의 메뉴로 들어가서 기간을 설정하고(1904년1월1일~최근) 지역은 서울을설정합니다. (아래의 문제를 풀기 위해서 대구 지역의 파일도 받아야 합니다.)검색버튼을 누르고 잠시 기다리면 그래프가 출력됩니다. 그 후CSV 다운로드 버튼을 클릭해 데이터 파일을 다운로드 받습니다.다운로드한 CSV 파일다운로드한 후 CSV 파일을 Notepad++ 같은 에디트 프로그램으로 열고 1~7행을 삭제합니다.NumPy를 이용하여 다음의 내용을 구합니다. 데이터에 결측치가 포함되어 있을 수 있습니다.주의하세요!!(중복된 내용이 있으면 모두 출력하며 오름차순으로 정렬하여 출력합니다.)      기상 관측 이래, 서울의 최고 기온이 가장 높았던 날은 언제였고, 몇도인가요?        역사적으로 일교차가 가장 큰 날짜는 몇년 몇월 몇일 인가요?        1년 중 평균적으로 일교차가 가장 큰 날짜는 몇월 몇일 인가요?        가장 덥다고 알려진 대구보다 서울이 더 더운날이 가장 많은 연도는 언제인가요?  End.Data-Science 강좌는 아래의 책과 사이트를 참조했습니다.    조금 더 자세한 사항을 알고 싶으시면 해당 사이트를 방문하세요!!",
        "url": "/data-science-lecture-python-numpy-exercise"
    }
    ,
    
    "data-science-lecture-python-numpy": {
        "title": "Python 데이터분석 라이브러리(1) - NumPy",
            "author": "moon9342",
            "category": "",
            "content": "Data-Science 강의는 여러 절로 구성되어 있습니다.     Python 데이터분석 라이브러리(1) - NumPy    Python 데이터분석 라이브러리(2) - NumPy(Exercise)    Python 데이터분석 라이브러리(3) - Pandas(Series)    Python 데이터분석 라이브러리(4) - Pandas(DataFrame 생성)    Python 데이터분석 라이브러리(5) - Pandas(DataFrame indexing)    Python 데이터분석 라이브러리(6) - Pandas(DataFrame functions)    Python 데이터분석 라이브러리(7) - Pandas(DataFrame merge)    Python 데이터분석 라이브러리(8) - Pandas(DataFrame 제어)    Python 데이터분석 라이브러리(9) - Pandas(DataFrame Grouping)    Python 데이터분석 라이브러리(10) - Pandas(Exercise)NumPy이번에는 NumPy(Numerical Python)에 대해서 알아보겠습니다.NumPy module은 Vector 및 Matrix 연산에 있어 상당한 편의성을 제공합니다. 또한 Pandas와 matplotlib의 기반이 되는 module이며 Machine Learning, Deep Learning에서 많이 사용되기 때문에 잘 알아두어야 합니다.NumPy array는 ndarray라고 부르는 n차원의 배열(n-dimensional array)객체입니다.ndarray는 Python의 list와는 다르게 같은 데이터 타입만 저장 가능합니다. NumPy의 ndarray와 Python의 list는 거의 사용방법이 같지만 NumPy ndarray가 좀 더 효율적으로 메모리에 데이터를 저장하고 빠른 연산이 가능합니다.NumPy를 사용하기 위해서는 conda 명령어나 pip를 이용하여 먼저 NumPy module을 설치해야 합니다.  conda install numpy영상설명이번 영상은 Anaconda를 설치하고 NumPy와 Pandas를 학습하기 위한개발환경을 세팅하는 방법에 대한 영상입니다.Windows 10 환경으로 진행합니다.  NumPy &amp; Pandas - 01. Anaconda 환경설정 영상영상설명이번 영상은 NumPy의 ndarray 생성과 dtype 설정 및 확인에 대한 영상입니다.ndarray 생성 및 data type 확인다차원 ndarray와 data type 지정  NumPy &amp; Pandas - 02. ndarray 생성 및 특징ndarray 생성 및 type 확인# ndarray 생성 및 type 확인import numpy as npa = [1,2,3,4]print(\"list =&gt; {}\".format(a))       # [1,2,3,4]  print(\"type =&gt; {}\".format(type(a))) # &lt;class 'list'&gt;b = np.array([1,2,3,4])print(\"array =&gt; {}\".format(b))         # [1 2 3 4]print(\"type =&gt; {}\".format(type(b)))    # &lt;class 'numpy.ndarray'&gt;print(\"b.dtype =&gt; {}\".format(b.dtype)) # dtype : 배열 데이터 타입 속성                                       # int32print(\"b[0] type =&gt; {}\".format(type(b[0]))) # &lt;class 'numpy.int32'&gt;c = np.array([100,\"Hello\",3.141592])print(\"array =&gt; {}\".format(c))         # array =&gt; ['100' 'Hello' '3.141592'],  print(\"type =&gt; {}\".format(type(c)))    # type =&gt; &lt;class 'numpy.ndarray'&gt;  print(\"c.dtype =&gt; {}\".format(c.dtype)) # b.dtype =&gt; &lt;U11 print(\"c[0] type =&gt; {}\".format(type(c[0]))) # &lt;class 'numpy.str_'&gt;      다차원 ndarray와 data type 지정# 다차원 ndarray와 data type 지정import numpy as np my_list = [[1,2,3], [4,5,6]]arr = np.array(my_list)print(\"{}\".format(arr))  # [[1 2 3]                         #  [4 5 6]]    print(\"1행 2열의 값은 : {}\".format(arr[1,2])) # 1행 2열의 값은 : 6# ndarray 생성시 dtype 명시# ndarray 생성 시 명시적으로 타입을 지정하지 않으면# 데이터를 보고 적절한 타입을 알아서 지정# 혹은 ndarray 생성 시 data type을 지정할 수 있다.my_list = [[1,2,3], [4,5,6]]arr = np.array(my_list, dtype=np.float64)print(\"{}\".format(arr))  # [[1. 2. 3.]                         #  [4. 5. 6.]]영상설명이번 영상은 NumPy의 ndarray 주요 속성에 대한 영상입니다.ndarray의 차원 관련 속성 : ndim, shapendarray의 크기 속성과 shape 조절astype()을 이용한 ndarray data type 변경  NumPy &amp; Pandas - 03.ndarray 주요속성 및 데이터타입ndarray의 차원 관련 속성 : ndim, shape# ndarray의 차원 관련 속성 : ndim, shapeimport numpy as np# 1차원list = [1,2,3,4]arr = np.array(list)print(\"arr.ndim =&gt; {}\".format(arr.ndim))   # arr.ndim =&gt; 1print(\"arr.shape =&gt; {}\".format(arr.shape)) # arr.shape =&gt; (4,)# 2차원list = [[1,2],[3,4],[5,6],[7,8]]arr = np.array(list)print(\"arr.ndim =&gt; {}\".format(arr.ndim))   # arr.ndim =&gt; 2print(\"arr.shape =&gt; {}\".format(arr.shape)) # arr.shape =&gt; (4, 2)# 3차원 (2,2,3) 형태를 list로 만들어보자!list = [[[1,2,3],[4,5,6]],[[7,8,9],[10,11,12]]]arr = np.array(list)print(\"arr.ndim =&gt; {}\".format(arr.ndim))   # arr.ndim =&gt; 3print(\"arr.shape =&gt; {}\".format(arr.shape)) # arr.shape =&gt; (2, 2, 3)ndarray의 크기 속성과 shape 조절# ndarray의 크기 속성과 shape 조절import numpy as nplist = [1,2,3,4]arr = np.array(list)print(\"arr.shape =&gt; {}\".format(arr.shape))   # arr.shape =&gt; (4,)print(\"크기(size) : {}\".format(arr.size))    # 배열 요소의 수 : 4 print(\"크기(len) : {}\".format(len(arr)))     # 1차원배열길이 : 4arr.shape = 2,2    # shape 변경print(\"arr.shape =&gt; {}\".format(arr.shape))   # arr.shape =&gt; (2, 2)print(\"크기(size) : {}\".format(arr.size))    # 배열 요소의 수 : 4print(\"크기(len) : {}\".format(len(arr)))     # 1차원배열길이 : 2arr.shape = 4,1,1  # shape 변경print(\"arr.shape =&gt; {}\".format(arr.shape))   # arr.shape =&gt; (4, 1, 1)print(arr)astype()을 이용한 ndarray data type 변경 # astype()을 이용한 ndarray data type 변경import numpy as nparr = np.array([1.2, 2.5, 3.8, 4.2, 5.3])print(\"arr.dtype : {}\".format(arr.dtype))  # float64arr = arr.astype(np.int32)print(\"arr.dtype : {}\".format(arr.dtype))  # int32print(arr)  # [1 2 3 4 5]  소수점 이하 버림 처리영상설명이번 영상은 NumPy의 ndarray를 생성하는 다양한 생성함수에 대한 영상입니다.ndarray 다양한 생성 함수-zeros,ones,empty,fullndarray 다양한 생성 함수-arangendarray 다양한 생성 함수-linspace  NumPy &amp; Pandas - 04.ndarray를 만드는 다양한 생성함수ndarray 다양한 생성 함수-zeros,ones,empty,full# ndarray 다양한 생성 함수-zeros,ones,empty,fullimport numpy as nparr = np.zeros((3,4)) # shape을 지정                      # default data type은 float64print(arr)arr = np.ones((2,4), dtype=np.int32)print(arr)arr = np.empty((3,3)) # 공간만 할당, 초기화 하지 않는다. print(arr)arr = np.full((3,4), 7, dtype=np.float64)print(arr)   # 지정된 shape으로 array를 생성한 후             # parameter값으로 초기화arr = np.array([(1,2,3),(4,5,6)]) # 2 x 3 array# 지정된 배열과 shape이 같은 array를 생성.arr_like = np.ones_like(arr, dtype=np.float64)arr_like = np.zeros_like(arr, dtype=np.float64)arr_like = np.empty_like(arr, dtype=np.float64)arr_like = np.full_like(arr, 9, dtype=np.float64)print(arr_like)ndarray 다양한 생성 함수-arange# ndarray 다양한 생성 함수-arangeimport numpy as np# python의 range()와 유사# 주어진 범위 내에서 지정한 간격으로 # 연속적인 원소를 가진 배열을 생성# np.arange(시작,끝,간격)# 시작은 inclusive, 끝은 exclusive arr = np.arange(0,10,2)print(\"arr의 크기 : {}\".format(arr.size))print(\"arr : \",arr)    # [0 2 4 6 8]arr = np.arange(10)print(\"arr의 크기 : {}\".format(arr.size))print(\"arr : \",arr)    # [0 1 2 3 4 5 6 7 8 9]arr = np.arange(0.1,5.3)print(\"arr의 크기 : {}\".format(arr.size))print(\"arr : \",arr)    # [0.1 1.1 2.1 3.1 4.1 5.1]ndarray 다양한 생성 함수-linspace# ndarray 다양한 생성 함수-linspaceimport numpy as npimport matplotlib.pyplot as plt# np.linspace(start,stop,num)# start부터 stop의 범위에서 num개를 균일한 간격으로# 데이터를 생성하고 배열을 만드는 함수# 원소간 간격은 (stop-start)/(num - 1).# num의 default값은 50arr = np.linspace(0,10,11)print(\"arr의 크기 : {}\".format(arr.size))print(arr)plt.plot(arr,\"*\")   # plt.plot()은 선그래프를 그려준다.plt.show()arr = np.linspace(1,121,31)print(arr)plt.plot(arr,\"o\")plt.show()영상설명이번 영상은 NumPy의 ndarray를 생성하는 랜덤 기반의 함수와NumPy에서 제공하는 유용한 랜덤 관련 함수에 대한 영상입니다.ndarray 다양한 생성 함수-random 기반NumPy 난수관련 함수  NumPy &amp; Pandas - 05.ndarray를 만드는 난수기반 함수ndarray 다양한 생성 함수-random 기반# ndarray 다양한 생성 함수-random 기반# np.random.normal() : 정규분포 확률밀도에서 실수 표본추출# np.random.rand() : [0,1)의 균등분포 확률밀도에서 실수 표본추출# np.random.randn() : 표준정규분포(평균:0, 표준편차:1) 확률밀도에서 실수 표본추출# np.random.randint() : 주어진 범위에서 균등분포 확률밀도에서 정수 표본추출# np.random.random() : [0,1)의 균등분포 확률밀도에서 실수 표본추출import numpy as npimport matplotlib.pyplot as plt# np.random.normal(정규 분포의 평균,표준편차,shape)# 정규분포 확률밀도에서 실수 표본추출# 추출된 난수는 정규분포의 형상을 가진다.mean = 50std = 2arr = np.random.normal(mean,std,(10000,))plt.hist(arr,bins=100)plt.show()######################### np.random.rand(d0,d1,d2,...)# 난수[0,1) 균등분포 확률 밀도에서 표본을 추출# [](대괄호)는 이상, 이하의 의미, ()(소괄호)는 초과,미만의 의미# 추출된 난수는 균등분포의 형상을 가진다.arr = np.random.rand(10000)plt.hist(arr,bins=100)plt.show()######################### np.random.randn(d0,d1,d2,...)# 표준 정규 분포 확률 밀도에서 표본을 추출# 추출된 난수는 정규분포의 형상을 가진다.arr = np.random.randn(10000)plt.hist(arr,bins=100)plt.show()######################### np.random.randint(low,high,shape)# 균등 분포 확률 밀도에서 정수 표본을 추출# 추출된 정수 난수는 해당 범위에서 균등 분포의 형상을 가진다.arr = np.random.randint(-100,100,(1000,))plt.hist(arr,bins=100)plt.show()######################### np.random.random(shape)# [0,1) 균등 분포 확률 밀도에서 표본을 추출# 추출된 난수는 해당 범위에서 균등 분포의 형상을 가진다.arr = np.random.random((10000,))plt.hist(arr,bins=100)plt.show()NumPy 난수관련 함수# random 기반의 배열 생성의 재현성을 확보해보자!!# 난수는 특정 시작 숫자로부터 난수처럼 보이는 수열을 만드는# 알고리즘의 결과물# 시작점을 설정하면 같은 난수를 발생시킬 수 있다. ( 난수의 재현 )# np.random.seed(x) : 난수의 시작점을 설정하는 함수import numpy as npnp.random.seed(1)arr = np.random.randint(0,100,(10,))print(arr)# 반복실행을 해도 똑같은 난수가 발생################### 데이터의 순서를 바꾸려면 shuffle()을 이용합니다. arr = np.arange(10)np.random.shuffle(arr)   # arr의 데이터 순서를 변경print(arr)################### 데이터 집합에서 일부를 무작위로 선택하는 샘플링(sampling)을 # 수행하려면 choice()를 이용합니다. # numpy.random.choice(a, size=None, replace=True, p=None)# a : 배열 혹은 정수#     만약 정수면 arange(a) 명령으로 데이터 생성# size : 정수. 샘플 숫자# replace : True이면 한번 선택한 데이터를 다시 선택 할 수 있음.# p : ndarray. 각 데이터가 선택될 수 있는 확률을 명시.arr = np.random.choice(5, 3, replace=False)arr = np.random.choice(5, 10)arr = np.random.choice(5, 10, p=[0.1, 0, 0.3, 0.6, 0])print(arr)영상설명이번 영상은 NumPy의 ndarray shape을 변경하는 함수에 대한 영상입니다.ndarray shape 조절 함수 - reshapendarray shape 조절 함수 - ravelndarray shape 조절 함수 - resize  NumPy &amp; Pandas - 06.ndarray의 shape 조절 함수ndarray shape 조절 함수 - reshape# ndarray shape 조절 함수 - reshapeimport numpy as nparr = np.arange(0,12,1)print(arr)# 배열의 데이터는 공유하지만 shape이 다른 뷰(View)를 생성arr1 = arr.reshape(4,3)print(arr1)# 데이터가 공유되기 때문에 배열을 변경하면 다른 View에도# 영향을 미침# 데이터를 공유하는지 확인arr[4] = 100print(arr)print(arr1)######################## base 속성을 이용하면 현재의 View의 데이터가 어떤 객체의 # 데이터 인지를 알 수 있다.print(arr1.base)if arr1.base is arr:    print(\"데이터 공유!!\")    ######################## reshape()을 사용할 때 차원 하나를 -1로 설정하면 # 배열의 전체 원소 개수와 확정된 차원 크기로 부터 # 남은 차원의 크기를 추론하여 배열을 생성arr = np.arange(0,12,1)arr1 = arr.reshape(4,-1)print(arr1)######################## View를 생성하지 않으려면 copy()를 이용하여 새로운# array 생성arr2 = arr.reshape(4,3).copy()ndarray shape 조절 함수 - ravel# ndarray shape 조절 함수 - ravelimport numpy as np# ravel() : 배열의 모든 원소가 포함된 1차원 배열을 리턴# ravel() 역시 View를 returnarr = np.arange(0,100,1).reshape(5,-1).copy()print(arr)arr1 = arr.ravel() print(arr1)ndarray shape 조절 함수 - resize# ndarray shape 조절 함수 - resize# resize()는 reshape()과 유사한 기능을 수행.# 단, reshape()는 배열 요소 수를 변경하지 않는반면 resize()는# shape을 변경하는 과정에서 배열 요소 수가 변할 수 있다.import numpy as npnp.random.seed(1)arr = np.random.randint(0,10,(3,4))print(arr)# resize()를 호출하는 방식에 따라서 원본 변경 혹은# 결과 배열이 리턴된다.# resize()는 reshape()과는 다르게 View를 생성하지 않는다.print(np.resize(arr,(2,6))) # 새로운 배열 생성                            # View 생성이 아님print(arr)print(arr.resize(2,6)) # return 없음. 원본 변경print(arr)arr.resize(3,5)  # 요소수가 늘어나면 0으로 세팅print(arr)arr.resize(2,2)  # 요소수가 줄면 기존 데이터를 버린다.print(arr)영상설명이번 영상은 NumPy의 ndarray의 indexing과 slicing에 대한 영상입니다.ndarray indexing &amp; slicingndarray Boolean indexing &amp; Fancy indexing  NumPy &amp; Pandas - 07.ndarray의 indexing과 slicingndarray indexing &amp; slicing# ndarray indexing &amp; slicingimport numpy as nparr = np.arange(10,20,1)# ndarray는 python list처럼 indexing과 slicing이 가능for idx,data in enumerate(arr):    print(\"index : {}, data : {}\".format(idx,data))    # ndarray를 slicing한 결과는 View이기 때문에 # 원본 데이터가 변경되면 View의 데이터도 변경됨을 기억하자.arr = np.arange(0,5,1)print(arr)print(arr[0:2])print(arr[1:-1])print(arr[0::2])  # 첫번째 원소부터 2씩 건너띄며 원소를 슬라이싱print(arr[1:4:2])# 2차원 ndarray의 indexing &amp; slicingarr = np.array([[1,2,3,4],                [5,6,7,8],                [9,10,11,12],                [13,14,15,16]])print(arr[1,1])print(arr[2,:])     # 2차원 이상인 경우                     # \",\"를 기준으로 인덱싱을 해야 한다.print(arr[1:3,:]) print(arr[:,2])print(arr[1:3,:2])ndarray Boolean indexing &amp; Fancy indexing# ndarray Boolean indexing &amp; Fancy indexing# boolean indexing은 배열의 각 요소의 선택여부를 # True,False로 구성된 boolean mask를 이용하여 # 지정하는 방식으로 boolean mask의 True 요소에 해당하는 # index만을 조회.import numpy as npnp.random.seed(1)arr = np.random.randint(0,10,(10,))print(arr)print(arr % 2 == 0)       # mask 생성print(arr[arr % 2 == 0])  # boolean indexing################################### Fancy Indexing# 배열에 index 배열을 전달하여 배열요소를 참조하는 방식import numpy as nparr = np.arange(0,12,1).reshape(3,4).copy()print(arr)print(arr[2,2])       # indexing : 10print(arr[1:2,2])     # slicing : [6]print(arr[1:2,1:2])   # slicing : [[5]]print(arr[[0,2],2])   # fancy indexing : [2 10]print(arr[[0,2],2:3]) # [[ 2]                      #  [10]]print(arr[:,[0,2]])   # fancy indexing                        # [[ 0  2]                      #  [ 4  6]                      #  [ 8 10]]    print(arr[[0,2],[0,2]]) # ?? 생각처럼 나오지 않는다.                        # 슬라이싱처럼 fancy indexing 적용 안됨    # 방법 1# 행을 먼저 추출한 후 해당 행에 대해 fancy indexing을 적용print(arr[[0,2]][:,[0,2]])  # [[ 0  2]                            #  [ 8 10]]# 방법 2# numpy의 ix_() 함수를 이용print(arr[np.ix_([0,2],[0,2])]) # [[ 0  2]                                # [ 8 10]]영상설명이번 영상은 NumPy ndarray의 사칙연산과 행렬곱연산에 대한 영상입니다.ndarray 사칙연산과 행렬곱ndarray broadcasting  NumPy &amp; Pandas - 08.ndarray의 사칙연산과 행렬곱ndarray 사칙연산과 행렬곱# ndarray 사칙연산과 행렬곱import numpy as nparr1 = np.array([[1,2,3],[4,5,6]])            # 2 x 3 ndarrayarr2 = np.arange(10,16,1).reshape(2,3).copy() # 2 x 3 ndarrayarr3 = np.arange(10,16,1).reshape(3,2).copy() # 3 x 2 ndarray# 같은 크기의 배열 간의 연산은 # 같은 위치에 있는 원소 간의 연산으로 결과가 계산print(arr1 + arr2)  # np.add(arr1,arr2)print(arr1 - arr2)  # np.subtract(arr1,arr2)print(arr1 * arr2)  # np.multiply(arr1,arr2)print(arr1 / arr2)  # np.divide(arr1,arr2)# 두 행렬간의 행렬곱은 np.matmul() 혹은 np.dot()으로 수행가능# np.dot(A,B)에서 A 행렬의 열 vector와 B 행렬의 행 vector의 size가 같아야 한다.# 그렇지 않으면 이전에 배운 reshape이나 전치행렬을 이용하여 형 변환 후 크기를# 맞추고 연산을 수행해야 한다.print(\"행렬곱 : \", np.matmul(arr1,arr3))  # np.dot(arr1,arr3)# 이런 행렬곱을 왜 알아야 할까?# 행렬곱이 없다면 matrix연산은 무조건 같은 크기의 사칙연산만을 수행할 수 있다.# 하지만 행렬곱을 이용하면 # 행렬곱 조건을 만족하는 다양한 크기의 행렬을 이용하여 연속적으로# 행렬곱을 수행시킬 수 있기 때문.# 이러한 특성이 Machine Learning과 Image processing에서 자주 사용된다.# 예) 입력 : 32 x 32 matrix (image라고 가정)#     출력 : 32 x 10 matrix (다양한 처리가 적용된 image)#     행렬곱 : (32 x 32) dot (32 x 128) dot (128,64) dot (64 x 10) =&gt; 32 x 10# 위의 예처럼 행렬곱 특성을 이용하면 다양한 크기의 행렬을 이용하여 원본 데이터를# 변경시키는 것이 가능. 만약 행렬곱이 없고 사칙연산만 수행할 수 있다면# 32 x 32 형태의 크기를 가지는 특성(행렬)만 이용할 수 있기 때문에 # 다양한 특성을 가지는 필터 개발이 불가능하다.ndarray broadcasting# ndarray broadcasting# shape이 다른 경우 두 배열에 대한 이항연산은 두 배열간의 shape을# 맞추는 broadcasting과정을 거친 후 수행된다.# 가장 일반적인 경우는 배열과 scalar의 연산import numpy as nparr1 = np.array([[1,2,3],[4,5,6]])   # 2 x 3 ndarrayarr2 = np.array([7,8,9])             # 1차원 ndarray print(arr1)print(arr2)print(arr1 + arr2)  # arr2를 2차배열로 broadcastingarr1 = np.array([[1,2,3],[4,5,6]])arr2 = np.array([[1,2],[4,5]])# print(arr1 + arr2)  # broadcasting이 일어날 수 없다. Error 발생# 주의!!# 이런 ndarray의 broadcasting은 사칙연산에 한해서 일어나게 된다.# 즉, 행렬곱 연산에 대해서는 broadcasting이 발생하지 않는다.영상설명이번 영상은 NumPy ndarray의 전치행렬과 iterator에 대한 영상입니다.ndarray transposeNumPy iterator  NumPy &amp; Pandas - 09.ndarray의 전치행렬과 iteratorndarray transpose# ndarray transpose# 일반적으로 전치행렬이라고 불리는 transpose에 대해서 알아보자.# 전치행렬은 원본 행렬의 행은 열로, 열은 행으로 바꾼 행렬을 의미# 전치행렬의 수학적 표현은 윗첨자 T를 이용해서 표현한다. # ndarray의 T 속성을 이용하면 전치행렬을 구할 수 있다.(View)import numpy as nparr = np.array([[1,2,3],[4,5,6]])   # 2 x 3 ndarrayarr_transpose = arr.Tprint(arr)print(arr_transpose)arr[0,0] = 100print(arr)print(arr_transpose)   # 전치행렬 또한 View# Vector에 대한 transposearr = np.array([1, 2, 3, 4])arr_transpose = arr.T    print(arr)print(arr_transpose)   # vector에 대한 전치행렬은 의미없음.# 만약 전치행렬을 구하고 싶으면 2차원 matrix로 변환한 후 수행해야 한다.arr_transpose = arr.reshape(1,4).Tprint(arr_transpose)NumPy iterator# ndarray iterator# ndarray의 모든 원소를 access하는 경우에 일반적으로 iterator를 이용.# iternext()와 finished 속성을 이용하여 ndarray의 모든 요소들을 순차적으로# access 할 수 있다.import numpy as np# 1차원 ndarray에 대한 요소 출력arr = np.array([1, 2, 3, 4, 5])for tmp in arr:    print(tmp, end=' ')    ####################################    # 1차원 ndarray에 대한 iteratorarr = np.array([1, 2, 3, 4, 5])it = np.nditer(arr, flags=['c_index'])while not it.finished:        idx = it.index        print(arr[idx], end=' ')        it.iternext()##################################### 2차원 ndarray에 대한 요소 출력arr = np.array([[1,2,3], [4,5,6]])for tmp1 in range(arr.shape[0]):    for tmp2 in range(arr.shape[1]):        print(arr[tmp1,tmp2], end=' ')        ####################################    # 2차원 ndarray에 대한 iteratorarr = np.array([[1,2,3], [4,5,6]])it = np.nditer(arr, flags=['multi_index'])while not it.finished:        idx = it.multi_index        print(arr[idx], end=' ')        it.iternext()        영상설명이번 영상은 NumPy ndarray의 boolean mask의 활용과 집계함수에 대한 영상입니다.ndarray 비교연산NumPy 함수와 axisNumPy 집계 함수의 처리속도Boolean Mask 활용  NumPy &amp; Pandas - 10.ndarray의 boolean mask와 집계함수ndarray 비교연산# ndarray 비교연산# 사칙연산과 마찬가지로 비교연산도 같은 index의 # 요소들끼리 수행된다.import numpy as nparr1 = np.random.randint(0,10,(2,3))arr2 = np.random.randint(0,10,(2,3))print(arr1)print(arr2)print(arr1 == arr2) # 논리 연산의 결과는 booleanprint(arr1 &gt; arr2)######################## 2개의 ndarray 자체가 같은 데이터를 가지고 있는지# 비교할 때는 array_equal()을 사용한다.arr1 = np.arange(10)arr2 = np.arange(10)print(np.array_equal(arr1,arr2)) # 두 배열 전체 비교NumPy 함수와 axis# NumPy 함수와 axisimport numpy as npimport matplotlib.pyplot as pltarr = np.arange(1,7,1).reshape(2,3).copy()print(arr)print(np.sum(arr))        # 합, arr.sum()print(np.cumsum(arr))     # 누적합, arr.cumsum()print(np.mean(arr))       # 평균, arr.mean()print(np.max(arr))        # 최대값, arr.max() print(np.min(arr))        # 최소값, arr.min()print(np.argmax(arr))     # 최대값의 index =&gt; 5print(np.argmin(arr))     # 최소값의 index =&gt; 0print(np.std(arr))        # 표준편차, arr.std() print(np.sqrt(arr))       # 제곱근print(np.exp(arr))        # 자연상수의 제곱값 (자연상수 e = 2.7182...)print(np.log10(arr))      # 상용 log의 값print(np.log(arr))        # 자연 log의 값 (자연상수 e = 2.7182...)print(np.log10(100))      # 상용로그 print(np.log(2.7182))     # 자연로그 arr = np.arange(1,10000,1)arr1 = np.log10(arr)print(arr1)plt.plot(arr1)plt.show()# NumPy의 모든 집계함수는 axis를 기준으로 계산.# 만약 axis를 지정하지 않으면 axis는 None으로 간주하고# 대상범위를 전체 행렬로 지정import numpy as nparr1 = np.array([1,2,3,4,5])print(arr1.sum(axis=0)) # 1차원에서 axis=0은 열방향#print(arr1.sum(axis=1)) # 1차원에서 axis=1은 errorarr1 = np.array([[1,2,3],[4,5,6],[7,8,9]])print(arr1)print(arr1.sum()) # axis=None, 전체배열대상 =&gt; 45print(arr1.sum(axis=0)) # 2차원에서 axis=0은 행방향, np.sum(arr1,axis=0)print(arr1.sum(axis=1)) # 2차원에서 axis=1은 열방향, np.sum(arr1,axis=1)print(arr1.argmax(axis=1)) # 열방향으로 최대값의 index =&gt; [2 2 2]arr1 = np.random.randint(0,5,(2,2,3))print(arr1)print(arr1.sum(axis=0)) # 3차원에서 axis=0은 depth방향NumPy 집계 함수의 처리속도# NumPy 집계 함수의 처리속도import numpy as nparr = np.arange(10000000, dtype=np.float64)# 아래의 코드는 jupyter notebook의 cell을 나누어서 실행%%time# 해당 cell을 실행시키는데 걸리는 시간 출력출력result = 0.0for tmp in arr:    result += tmpprint(result)    ##########################%%timeprint(arr.sum())Boolean Mask 활용# Boolean Mask 활용import numpy as nparr = np.array([[1,2,3,4],                [5,6,7,8],                [9,10,11,12],                [13,14,15,16]])# ndarray arr안에 10보다 큰 수가 몇개있는지 알아보려면# 어떻게 해야 하는가?# 여러가지 방법이 있지만 가장 쉽고 빠른 방법은 # boolean indexing을 이용하는 방법# arr &gt; 10 =&gt; boolean mask# True는 1로, False는 0으로 간주된다는 것을 기억하자.(arr &gt; 10).sum()    # 조건을 만족하는 개수(True의 개수)영상설명이번 영상은 NumPy ndarray의 정렬, 연결, 삭제에 대한 영상입니다.ndarray 정렬NumPy concatenate() 함수ndarray delete() 함수ndarray loadtxt() 함수  NumPy &amp; Pandas - 11.ndarray의 정렬, 연결, 삭제ndarray 정렬# ndarray 정렬# NumPy의 array는 axis를 기준으로 정렬하는 sort() 제공# 만약 axis를 지정하지 않으면 -1, # -1의 의미는 마지막 axis# np.sort() : 정렬된 결과 배열을 return# arr.sort() : 원본배열을 정렬. None returnimport numpy as nparr = np.arange(10)np.random.shuffle(arr)      # shuffle 처리print(arr)print(np.sort(arr))         # 오름차순 정렬한 새로운 배열 returnprint(np.sort(arr)[::-1])   # 내림차순 정렬, 특수한 indexing이용print(arr)                  # 원본은 변함없음arr = np.random.randint(0,10,(3,3))print(arr)print(np.sort(arr, axis=0))################################## 2차원 배열 정렬import numpy as nparr = np.array([[10,2,12,4],                [15,16,3,8],                [9,1,11,7],                [13,14,5,6]])print(arr)print(np.sort(arr,axis=0))    # 행 방향 정렬print(np.sort(arr,axis=1))    # 열 방향 정렬# 표준정규분포에서 # 200개의 샘플을 추출한 후 # 내림차순으로 상위 5%까지의 결과만 출력하세요!!arr = np.random.randn(200)result = np.sort(arr)[::-1][:int(0.05 * len(arr))]print(result)NumPy concatenate() 함수# NumPy concatenate() 함수# ndarray에 row(s) 또는 column(s)을 추가하기 위한 함수import numpy as nparr = np.array([[1,2,3], [4,5,6]])new_row = np.array([7,8,9])result = np.concatenate((arr,new_row.reshape(1,3)), axis=0)print(result)######################################arr = np.array([[1,2,3], [4,5,6]])new_col = np.array([7,8,9,10])result = np.concatenate((arr,new_col.reshape(2,2)), axis=1)print(result)ndarray delete() 함수# ndarray delete() 함수# delete() 함수는 axis를 기준으로 행과 열을 삭제# axis를 지정하지 않으면 1차배열로 변환 후 삭제# 원본배열을 변경하지 않고 새로운 배열 returnimport numpy as nparr = np.random.randint(0,10,(3,4))print(arr)#####################result = np.delete(arr,1)  # 1차 배열로 변환 후 1번 index 삭제print(result)#####################result = np.delete(arr,1, axis=0)  # 1번 행 삭제print(result)#####################result = np.delete(arr,3, axis=1)  # 3번 행 삭제print(result)ndarray loadtxt() 함수# ndarray loadtxt() 함수# numpy.loadtxt(fname, dtype='float', delimiter=' ', #  \t\t\t    skiprows=0, usecols=None, unpack=False, ndmin=0, #               encoding='bytes', max_rows=None&gt;# 형식으로 사용됩니다. CSV 파일등으로부터 데이터를 읽어 ndarray를 생성하기 위한# 함수라고 보시면 됩니다.import numpy as nparr = np.loadtxt(\"./data/seoul.csv\", delimiter=\",\", dtype=np.object,                 skiprows=1)print(arr)End.Data-Science 강좌는 아래의 책과 사이트를 참조했습니다.    조금 더 자세한 사항을 알고 싶으시면 해당 사이트를 방문하세요!!",
        "url": "/data-science-lecture-python-numpy"
    }
    ,
    
    "python-lecture-python-oop-exercise": {
        "title": "Python 기초강좌(14) - Python 연습문제(2)",
            "author": "moon9342",
            "category": "",
            "content": "Python 기초강의는 여러 절로 구성되어 있습니다.     Python 기초강의(1) - Introduction    Python 기초강의(2) - Python 기본    Python 기초강의(3) - Python 제어문    Python 기초강의(4) - Python function    Python 기초강의(5) - Python 연습문제(1)    Python 기초강의(6) - Python 객체지향    Python 기초강의(7) - Python Magic Function    Python 기초강의(8) - Python First Class    Python 기초강의(9) - Python Closure    Python 기초강의(10) - Python Decorator    Python 기초강의(11) - Python Generator    Python 기초강의(12) - Python Module    Python 기초강의(13) - Python Exception &amp; File    Python 기초강의(14) - Python 연습문제(2)    Python Django 웹 프레임워크(1) - introduction    Python Django 웹 프레임워크(2) - Poll project 개발(1)    Python Django 웹 프레임워크(3) - Poll project 개발(2)    Python Django 웹 프레임워크(4) - Poll project 개발(3)    Python Django 웹 프레임워크(5) - Poll project 개발(4)    Python Django 웹 프레임워크(6) - Poll project 개발(5)    Python Django 웹 프레임워크(7) - Django의 개발방식    Python Django 웹 프레임워크(8) - Blog project 개발    Python Data 처리 연습문제R에서 데이터 분석에 사용했던 mpg data set을 이용하여 python에서 데이터 분석 처리를순수 프로그램으로 작성해보겠습니다.먼저 R의 mpg data set을 txt 파일로 저장합니다.## mpg data set 파일 저장install.packages(\"ggplot2\")library(ggplot2)df &lt;- as.data.frame(mpg)write.csv(df,          file=\"C:/Temp/mpg.txt\",          row.names = F,          quote = F,          fileEncoding = \"UTF-8\")여기를 클릭하면 mpg.txt을 다운받을 수 있습니다.또한 R Documents - mpg dataset를 클릭하면 mpg data set에 대한 자세한 명세를 보실 수 있습니다.이렇게 얻은 데이터 파일을 이용하여 python으로 다음의 문제를 해결합니다.# 1. displ(배기량)이 4 이하인 자동차와 5 이상인 자동차 중 # 어떤 자동차의 hwy(고속도로 연비)가 평균적으로 더 높은지 확인하세요.# 2. 자동차 제조 회사에 따라 도시 연비가 다른지 알아보려고 한다. # \"audi\"와 \"toyota\" 중 어느 manufacturer(제조회사)의 cty(도시 연비)가 # 평균적으로 더 높은지 확인하세요.# 3. \"chevrolet\", \"ford\", \"honda\" 자동차의 고속도로 연비 평균을 알아보려고 한다. # 이 회사들의 데이터를 추출한 후 hwy(고속도로 연비) 평균을 구하세요.# 4. \"audi\"에서 생산한 자동차 중에 어떤 자동차 모델의 hwy(고속도로 연비)가 # 높은지 알아보려고 한다. \"audi\"에서 생산한 자동차 중 hwy가 1~5위에 해당하는 # 자동차의 데이터를 출력하세요.# 5. mpg 데이터는 연비를 나타내는 변수가 2개입니다. # 두 변수를 각각 활용하는 대신 하나의 통합 연비 변수를 만들어 사용하려 합니다. # 평균 연비 변수는 두 연비(고속도로와 도시)의 평균을 이용합니다. # 회사별로 \"suv\" 자동차의 평균 연비를 구한후 내림차순으로 정렬한 후 1~5위까지 데이터를 출력하세요.# 6. mpg 데이터의 class는 \"suv\", \"compact\" 등 자동차의 특징에 따라 # 일곱 종류로 분류한 변수입니다. 어떤 차종의 도시 연비가 높은지 비교하려 합니다. # class별 cty 평균을 구하고 cty 평균이 높은 순으로 정렬해 출력하세요.# 7. 어떤 회사 자동차의 hwy(고속도로 연비)가 가장 높은지 알아보려 합니다. # hwy(고속도로 연비) 평균이 가장 높은 회사 세 곳을 출력하세요.# 8. 어떤 회사에서 \"compact\" 차종을 가장 많이 생산하는지 알아보려고 합니다. # 각 회사별 \"compact\" 차종 수를 내림차순으로 정렬해 출력하세요.End.Python 강좌는 아래의 책과 사이트를 참조했습니다.    조금 더 자세한 사항을 알고 싶으시면 해당 사이트를 방문하세요!!    Python Official HomePage    점프 투 파이썬 - 이지스 퍼블리싱    전문가를 위한 파이썬(Fluent Python) - 한빛미디어    파이썬 웹 프로그래밍 - 한빛미디어    이미지 출처 : Designed by rawpixel.com / Freepik",
        "url": "/python-lecture-python-oop-exercise"
    }
    ,
    
    "python-lecture-python-exception": {
        "title": "Python 기초강의(13) - Python Exception &amp; File",
            "author": "moon9342",
            "category": "",
            "content": "Python 기초강의는 여러 절로 구성되어 있습니다.     Python 기초강의(1) - Introduction    Python 기초강의(2) - Python 기본    Python 기초강의(3) - Python 제어문    Python 기초강의(4) - Python function    Python 기초강의(5) - Python 연습문제(1)    Python 기초강의(6) - Python 객체지향    Python 기초강의(7) - Python Magic Function    Python 기초강의(8) - Python First Class    Python 기초강의(9) - Python Closure    Python 기초강의(10) - Python Decorator    Python 기초강의(11) - Python Generator    Python 기초강의(12) - Python Module    Python 기초강의(13) - Python Exception &amp; File    Python 기초강의(14) - Python 연습문제(2)    Python Django 웹 프레임워크(1) - introduction    Python Django 웹 프레임워크(2) - Poll project 개발(1)    Python Django 웹 프레임워크(3) - Poll project 개발(2)    Python Django 웹 프레임워크(4) - Poll project 개발(3)    Python Django 웹 프레임워크(5) - Poll project 개발(4)    Python Django 웹 프레임워크(6) - Poll project 개발(5)    Python Django 웹 프레임워크(7) - Django의 개발방식    Python Django 웹 프레임워크(8) - Blog project 개발    Python ExceptionPython의 Exception처리는 try ~ except 구문을 사용합니다. Java언어의예외처리와 아주 흡사하게 동작하며 예제를 통해 다양한 처리를 살펴보도록 하겠습니다.# Python Exception\"\"\"try:    (예외 발생 가능) statementsexcept Exception:    예외가 발생했을 때 실행되는 문장else:    예외가 발생하지 않았을 때 실행되는 문장finally:    예외 발생 유무에 상관없이 실행되는 문장\"\"\"    def my_func(list_data):    sum = 0    try:        sum = list_data[0] + list_data[1] + list_data[2]        if sum &lt; 0:            raise Exception(\"User Define Exception\")    except ZeroDivisionError as err:        print(\"0으로 나눌수 없습니다.\" + str(err))    except Exception as err:        print(\"Exception 발생 : \" + str(err))             else:        print(\"Exception이 없습니다.\")    finally:        print(\"무조건 수행됩니다.\")# my_list = [1,2,3,4]    # my_func(my_list)       # Exception이 없습니다.#                        # 무조건 수행됩니다.# my_list = [1,2]    # my_func(my_list)       # Exception 발생 : list index out of range#                        # 무조건 수행됩니다.my_list = [1,2,-10]    my_func(my_list)       # Exception 발생 : User Define Exception                       # 무조건 수행됩니다.Python File 처리Python의 기본 파일 처리과정에 대해서 알아보겠습니다. 조금 더 자세한 파일처리 과정은 pandas에서살펴보도록 하겠습니다.file1 = open(\"student_score.txt\",\"r\")file2 = open(\"backup.txt\",\"w\")while True:    line = file1.readline()    print(\"읽어들인 라인 : {}\".format(line))    if not line:        break;    file2.write(line)file1.close()file2.close()with 구문일반적으로 file처리를 하거나 session처리를 할 때 기본적으로 다음과 같은 순서를 거치게 됩니다.  open() -&gt; CRUD -&gt; close()Python에서 with 구문을 이용하면 명시적으로 resouce를 close() 해 주지 않아도자동으로 close()를 해 줄 수 있습니다. with block을 벗어나는 순간 자동으로 close()처리가일어나게 됩니다.위에서 살펴본 파일 처리를 with 구문으로 바꾸어보면 다음과 같습니다.with open(\"student_score.txt\",\"r\") as file1, open(\"backup.txt\",\"w\") as file2:    while True:        line = file1.readline()        print(\"읽어들인 라인 : {}\".format(line))        if not line:            break;        file2.write(line)End.Python 강좌는 아래의 책과 사이트를 참조했습니다.    조금 더 자세한 사항을 알고 싶으시면 해당 사이트를 방문하세요!!    Python Official HomePage    점프 투 파이썬 - 이지스 퍼블리싱    전문가를 위한 파이썬(Fluent Python) - 한빛미디어    파이썬 웹 프로그래밍 - 한빛미디어    이미지 출처 : Designed by rawpixel.com / Freepik",
        "url": "/python-lecture-python-exception"
    }
    ,
    
    "python-lecture-python-module": {
        "title": "Python 기초강의(12) - Python Module",
            "author": "moon9342",
            "category": "",
            "content": "Python 기초강의는 여러 절로 구성되어 있습니다.     Python 기초강의(1) - Introduction    Python 기초강의(2) - Python 기본    Python 기초강의(3) - Python 제어문    Python 기초강의(4) - Python function    Python 기초강의(5) - Python 연습문제(1)    Python 기초강의(6) - Python 객체지향    Python 기초강의(7) - Python Magic Function    Python 기초강의(8) - Python First Class    Python 기초강의(9) - Python Closure    Python 기초강의(10) - Python Decorator    Python 기초강의(11) - Python Generator    Python 기초강의(12) - Python Module    Python 기초강의(13) - Python Exception &amp; File    Python 기초강의(14) - Python 연습문제(2)    Python Django 웹 프레임워크(1) - introduction    Python Django 웹 프레임워크(2) - Poll project 개발(1)    Python Django 웹 프레임워크(3) - Poll project 개발(2)    Python Django 웹 프레임워크(4) - Poll project 개발(3)    Python Django 웹 프레임워크(5) - Poll project 개발(4)    Python Django 웹 프레임워크(6) - Poll project 개발(5)    Python Django 웹 프레임워크(7) - Django의 개발방식    Python Django 웹 프레임워크(8) - Blog project 개발    영상설명이번 영상은 Python 언어의 module과 exception 처리 영상입니다.Python ModulePython PackagePython Exception  Python 기초강의 - Python module &amp; exceptionPython ModulePython의 Module은 함수나 변수 또는 class들을 모아 놓은 파일을 지칭합니다.즉, 다른 Python 프로그램에서 불러와 사용할 수 있도록 만들어진 Python 파일을 의미합니다.module을 사용해야 하는 이유는 간단합니다. 코드의 재활용성을 높이고 관리를 더 쉽게 하기 위해서입니다. Python의 스탠다드 라이브러리는 크게 두 가지로 구성됩니다.  C언어로 구현된 binary module  Python언어로 구현된 일반 module우리가 많이 사용하는 import keyword는 Python module을 사용할 수 있도록 만들어 주는 keyword입니다.여기서 한가지 기억하셔야 할 점은 Python의 module은 객체라는 것입니다.import syssys.path.append(\"C:/Python_Lib\");# 환경변수 PYTHONPATH에 모듈을 저장한 폴더를 설정해도# import 할 수 있다.# module1.py를 C:/Python_Lib에 작성하자!########################### module1.pydef sum(a,b):    return a+bmodule1_PI = 3.141592########################### import 모듈이름# import 모듈이름 as alias# from 모듈이름 import 모듈함수(모듈변수,모듈class)import module1print(module1.module1_PI)print(module1.sum(10,20))import module1 as m1print(m1.module1_PI)print(m1.sum(10,20))from module1 import module1_PIprint(module1_PI)from module1 import *print(sum(100,200))Python PackagePython에서 package는 .을 이용하여 Python module을 계층적으로 관리합니다. 단적으로 말하면 package는 module을 담고 있는 폴더를 지칭합니다.예를 들어, 만약 module명이 A.B인 경우 A는 package, B는 module을 의미합니다.특정 디렉토리에 __init__.py 파일이 존재하면 해당 디렉토리가 package임을 의미합니다. ( Python 3.3 이후부터는 __init__.py가 없어도 package로 인식됨 )import myFolder.myModule.module1print(myFolder.myModule.module1.sum(10,20))from myFolder.myModule import module1print(module1.module1_PI)from myFolder.myModule.module1 import sumprint(sum(100,200))from myFolder.myModule.module1 import *print(module1_PI)End.Python 강좌는 아래의 책과 사이트를 참조했습니다.    조금 더 자세한 사항을 알고 싶으시면 해당 사이트를 방문하세요!!    Python Official HomePage    점프 투 파이썬 - 이지스 퍼블리싱    전문가를 위한 파이썬(Fluent Python) - 한빛미디어    파이썬 웹 프로그래밍 - 한빛미디어    이미지 출처 : Designed by rawpixel.com / Freepik",
        "url": "/python-lecture-python-module"
    }
    ,
    
    "python-lecture-python-generator": {
        "title": "Python 기초강의(11) - Python Generator",
            "author": "moon9342",
            "category": "",
            "content": "Python 기초강의는 여러 절로 구성되어 있습니다.     Python 기초강의(1) - Introduction    Python 기초강의(2) - Python 기본    Python 기초강의(3) - Python 제어문    Python 기초강의(4) - Python function    Python 기초강의(5) - Python 연습문제(1)    Python 기초강의(6) - Python 객체지향    Python 기초강의(7) - Python Magic Function    Python 기초강의(8) - Python First Class    Python 기초강의(9) - Python Closure    Python 기초강의(10) - Python Decorator    Python 기초강의(11) - Python Generator    Python 기초강의(12) - Python Module    Python 기초강의(13) - Python Exception &amp; File    Python 기초강의(14) - Python 연습문제(2)    Python Django 웹 프레임워크(1) - introduction    Python Django 웹 프레임워크(2) - Poll project 개발(1)    Python Django 웹 프레임워크(3) - Poll project 개발(2)    Python Django 웹 프레임워크(4) - Poll project 개발(3)    Python Django 웹 프레임워크(5) - Poll project 개발(4)    Python Django 웹 프레임워크(6) - Poll project 개발(5)    Python Django 웹 프레임워크(7) - Django의 개발방식    Python Django 웹 프레임워크(8) - Blog project 개발    Generator이번에는 Generator에 대해서 알아보겠습니다.Generator에 대한 내용을 살펴보면 다음과 같습니다.  제너레이터는 루프의 작용을 컨트롤하기 위해 쓰여지는 특별한 함수 또는 루틴이다. 사실 모든 제너레이터는 반복자이다. 한번에 모든 값을 포함한 배열을 만들어서 리턴하는 대신에 yield 구문을 이용해 한 번 호출될 때마다 하나의 값만을 리턴하고 일반 반복자에 비해 아주 작은 메모리를 필요로 한다.우리가 일반적으로 사용하는 iterator(반복자)와 유사한 개념입니다. 빠른 속도와 적은 메모리사용으로 인해 더 좋은 성능을 낼 수 있습니다. 간단하게 예제를 보면서 알아보도록 하겠습니다.def my_func(data):    result = []    for tmp in data:        result.append(tmp * 2)    return resulttwice_list = my_func([1, 2, 3, 4, 5])print(\"처리된 결과는 : {}\".format(twice_list))   # 일반적인 for문을 이용한 처리                                                 # 처리된 결과는 : [2, 4, 6, 8, 10]위의 예제를 generator를 이용하는 예제로 변경해보도록 하겠습니다.def my_func(data):    for tmp in data:        yield tmp * 2twice_list = my_func([1, 2, 3])print(type(twice_list))   # &lt;class 'generator'&gt;print(\"첫번째 값 : {}\".format(next(twice_list)))   # 2print(\"두번째 값 : {}\".format(next(twice_list)))   # 4print(\"세번째 값 : {}\".format(next(twice_list)))   # 6print(\"네번째 값 : {}\".format(next(twice_list)))   # Error 발생마치 my_func 함수안의 for 구문이 일시정지 된 것처럼 보입니다. next()를 호출하는순간 하나의 값이 return 되고 다시 yield에 의해서 다음 next()가 호출될 때 까지 일시정지 됩니다.위의 코드는 다음과 같이 변경할 수 있습니다.def my_func(data):    for tmp in data:        yield tmp * 2twice_list = my_func([1, 2, 3])print(type(twice_list))   # &lt;class 'generator'&gt;for t in twice_list:      # generator는 일반적으로 for문과 같이 사용됩니다.     print(t)몇가지 generator 사용 용법을 알아보겠습니다. 가장 간단히 표현할 수 있는 방법은 list comprehension처럼사용하는 것입니다.my_list = [tmp * 2 for tmp in [1,2,3]]        # list 생성my_generator = (tmp * 2 for tmp in [1,2,3])   # generator 생성print(type(my_list))print(type(my_generator))for k in my_list:    print(\"리스트 안의 값은 : {}\".format(k))for k in my_generator:    print(\"generator로 부터 발생된 값은 : {}\".format(k))convert_list = list(my_generator)print(\"convert_list : {}\".format(convert_list))   # 결과가 어떻게 나올까?                                                   # [] : 위쪽 for문에서 이미 다 소모했기때문End.Python 강좌는 아래의 책과 사이트를 참조했습니다.    조금 더 자세한 사항을 알고 싶으시면 해당 사이트를 방문하세요!!    Python Official HomePage    점프 투 파이썬 - 이지스 퍼블리싱    전문가를 위한 파이썬(Fluent Python) - 한빛미디어    파이썬 웹 프로그래밍 - 한빛미디어    이미지 출처 : Designed by rawpixel.com / Freepik",
        "url": "/python-lecture-python-generator"
    }
    ,
    
    "python-lecture-python-decorator": {
        "title": "Python 기초강의(10) - Python Decorator",
            "author": "moon9342",
            "category": "",
            "content": "Python 기초강의는 여러 절로 구성되어 있습니다.     Python 기초강의(1) - Introduction    Python 기초강의(2) - Python 기본    Python 기초강의(3) - Python 제어문    Python 기초강의(4) - Python function    Python 기초강의(5) - Python 연습문제(1)    Python 기초강의(6) - Python 객체지향    Python 기초강의(7) - Python Magic Function    Python 기초강의(8) - Python First Class    Python 기초강의(9) - Python Closure    Python 기초강의(10) - Python Decorator    Python 기초강의(11) - Python Generator    Python 기초강의(12) - Python Module    Python 기초강의(13) - Python Exception &amp; File    Python 기초강의(14) - Python 연습문제(2)    Python Django 웹 프레임워크(1) - introduction    Python Django 웹 프레임워크(2) - Poll project 개발(1)    Python Django 웹 프레임워크(3) - Poll project 개발(2)    Python Django 웹 프레임워크(4) - Poll project 개발(3)    Python Django 웹 프레임워크(5) - Poll project 개발(4)    Python Django 웹 프레임워크(6) - Poll project 개발(5)    Python Django 웹 프레임워크(7) - Django의 개발방식    Python Django 웹 프레임워크(8) - Blog project 개발    DecoratorPython은 Decorator라는 것을 가지고 있습니다. 사전적의미는 아시는 것처럼장식가, 도배업자 라는 뜻을 가지고 있습니다. 장식가라는 의미처럼 Decorator는기존의 코드에 여러가지 기능을 추가하는 Python 구문이라고 생각하시면 일단 편합니다.객체지향에서는 decorator pattern이라는 디자인 패턴이 있을 정도로 활용도가 높은 형태입니다.Closure 기억하시나요? Closure는 함수의 결과값으로 다른 함수를 리턴하는 형태에서 free variable의 값을 바인딩하기 위해서 적용되는 기술을 의미했었습니다.Decorator는 약간 형태가 다릅니다. Decorator는 함수의 인자로 다른 함수를 전달하는 과정에서적용할 수 있는 기술을 의미합니다.아래의 예를 보면서 알아도보록 하겠습니다.def my_outer_function(func):     def my_inner_function():                  func()      return my_inner_function  def my_func():      print(\"my_func함수가 수행되었습니다.!!\")decorated_my_func = my_outer_function(my_func)my_func()              # my_func함수가 수행되었습니다.!!decorated_my_func()    # my_func함수가 수행되었습니다.!!my_func 함수를 그냥 이용하나 복잡하게 함수를 인자로 넘기고 결과로 함수를 다시 넘겨받아서 실행하나 결과는 똑같습니다.위의 예제를 조금만 수정해보도록 하죠import timedef my_outer_function(func):     def my_inner_function():                  print(\"{} 함수수행 시간을 계산합니다.\".format(func.__name__))        start = time.time()        func()          end = time.time() - start         print(\"{} 함수수행 시간은 {} 입니다.\".format(func.__name__,end))    return my_inner_function  def my_func():      print(\"my_func함수가 수행되었습니다.!!\")decorated_my_func = my_outer_function(my_func)my_func()              # my_func함수가 수행되었습니다.!!decorated_my_func()    # 추가적인 기능이 포함되어 있다.!!위의 코드를 보면 살짝 감이 오시나요? 기존의 함수에 추가적인 기능을 부여하는 역할을수행하고 있습니다. 만약 기존의 여러개의 함수에 동일한 추가 기능을 넣어야 한다면모든 함수를 다 일일이 수정하는 것보다는 당연히 decorator를 이용하여 처리하는 것이 훨씬좋은 방법이 될 것입니다.자 그럼 일반적으로 표현하는 식으로 다시 살펴보도록 하겠습니다. 위의 코드는 decorator의기능을 설명하기 위한 코드이고 실제는 아래와 같이 표현합니다.import timedef my_outer_function(func):     def my_inner_function():                  print(\"{} 함수수행 시간을 계산합니다.\".format(func.__name__))        start = time.time()        func()          end = time.time() - start         print(\"{} 함수수행 시간은 {} 입니다.\".format(func.__name__,end))    return my_inner_function  @my_outer_functiondef my_func():      print(\"my_func함수가 수행되었습니다.!!\")# decorated_my_func = my_outer_function(my_func) # 이 코드는 필요없습니다.my_func()              # 추가적인 기능이 포함된 my_func() 호출훨씬 간편하게 사용할 수 있게되었습니다. 이번에는 다른 함수를 추가하여동일하게 함수의 실행시간을 측정하는 코드를 추가하여 적용해 보도록 하겠습니다. 단, 추가하는 함수는 인자를 받아 들이는 함수입니다.import timedef my_outer_function(func):     def my_inner_function():                  print(\"{} 함수수행 시간을 계산합니다.\".format(func.__name__))        start = time.time()        func()          end = time.time() - start         print(\"{} 함수수행 시간은 {} 입니다.\".format(func.__name__,end))    return my_inner_function  @my_outer_functiondef my_func():      print(\"my_func함수가 수행되었습니다.!!\")@my_outer_functiondef my_adder(x,y):    print(\"두 수를 더한 결과는 {}\".format(x+y))    # decorated_my_func = my_outer_function(my_func) # 이 코드는 필요없습니다.my_func()              # 추가적인 기능이 포함된 my_func() 호출my_adder(10,20)        # Error 발생 (인자 처리가 안되어 있음)인자를 처리하기 위한 코드가 추가되어야 할 것 같습니다. 여기서 사용되어 지는것이 *args, **kwargs입니다. 일단 이 두놈부터 알아야 할 듯 하니 간단하게 알고 넘어가도록 하겠습니다.*args는 *argments의 줄임말입니다. 그리고 반드시 이 단어를 쓸 필요는 없습니다. 관용적으로 저렇게 표현합니다. 이 표현은 복수개의 인자를 함수로 받을 때 사용합니다. 그리고 이렇게 받은 복수개의 인자는 tuple로 함수에 전달되게 됩니다.def printUserName(*args):    for name in args:        print(\"입력된 사람은 : {}\".format(name))printUserName(\"홍길동\",\"신사임당\",\"강감찬\")kwargs는 keyword argments의 줄임말입니다. 만약 dictionary 형태로 함수에 인자가전달되면 그 내용을 이 **kwargs가 받을 수 있습니다. 다음의 예를 보죠.def printUserName(**kwargs):    if \"korea\" in kwargs:        print(\"서울의 인구는 : {}\".format(kwargs.get(\"korea\")))            if \"USA\" in kwargs:        print(\"미국의 인구는 : {}\".format(kwargs.get(\"USA\")))printUserName(korea=\"오천만\", USA=\"2억\")이러한 *args와 **kwargs를 이용하면 우리의 문제를 해결할 수 있습니다.import timedef my_outer_function(func):     def my_inner_function(*args, **kwargs):                  print(\"{} 함수수행 시간을 계산합니다.\".format(func.__name__))        start = time.time()        func(*args, **kwargs)          end = time.time() - start         print(\"{} 함수수행 시간은 {} 입니다.\".format(func.__name__,end))    return my_inner_function  @my_outer_functiondef my_func():      print(\"my_func함수가 수행되었습니다.!!\")@my_outer_functiondef my_adder(x,y):    print(\"두 수를 더한 결과는 {}\".format(x+y))    # decorated_my_func = my_outer_function(my_func) # 이 코드는 필요없습니다.my_func()              my_adder(10,20)         그러면 decorator는 한개만 적용가능한가? 라는 궁금증이 생길만도 한데 한번 알아보도록 하겠습니다. 위의 예에서 decorator함수를 2개로 분리했습니다. 하나는 어떠한 함수가실행되는지를 출력하는 decorator함수, 다른 하나는 실행시간을 출력하는 함수로분리했습니다. 잘못된 예를 먼저 보겠습니다.import timedef my_exec_function(func):     def my_inner_function(*args, **kwargs):                  print(\"{} 함수가 실행됩니다.\".format(func.__name__))        return func    return my_inner_function  def my_timer_function(func):     def my_inner_function(*args, **kwargs):                  print(\"{} 함수수행 시간을 계산합니다.\".format(func.__name__))        start = time.time()        func(*args, **kwargs)          end = time.time() - start         print(\"{} 함수수행 시간은 {} 입니다.\".format(func.__name__,end))    return my_inner_function  @my_exec_function@my_timer_function     # decorator 순서에 주의해야 한다. 아래쪽이 먼저 실행  def my_adder(x,y):    print(\"두 수를 더한 결과는 {}\".format(x+y))    my_adder(10,20)        # 결과가 이상합니다.!!왜 이런 결과가 나올까요? 이번에는 decorator의 순서를 바꾸어서 실행해보도록 하겠습니다.import timedef my_exec_function(func):     def my_inner_function(*args, **kwargs):                  print(\"{} 함수가 실행됩니다.\".format(func.__name__))        return func    return my_inner_function  def my_timer_function(func):     def my_inner_function(*args, **kwargs):                  print(\"{} 함수수행 시간을 계산합니다.\".format(func.__name__))        start = time.time()        func(*args, **kwargs)          end = time.time() - start         print(\"{} 함수수행 시간은 {} 입니다.\".format(func.__name__,end))    return my_inner_function  @my_timer_function     # decorator 순서에 주의해야 한다. 아래쪽이 먼저 실행  @my_exec_functiondef my_adder(x,y):    print(\"두 수를 더한 결과는 {}\".format(x+y))    my_adder(10,20)        # 정상수행아직 문제가 남아있습니다. 출력된 결과를 보니 my_adder 함수를 수행했음에도 불구하고내부에서 리턴되는 my_inner_function이라는 함수이름을 사용하고 있네요. 이 문제는python이 제공하는 functools 모듈의 wraps decorator를 이용하면 해결이 가능합니다.import timefrom functools import wrapsdef my_exec_function(func):     @wraps(func)    def my_inner_function(*args, **kwargs):                  print(\"{} 함수가 실행됩니다.\".format(func.__name__))        return func    return my_inner_function  def my_timer_function(func):     def my_inner_function(*args, **kwargs):                  print(\"{} 함수수행 시간을 계산합니다.\".format(func.__name__))        start = time.time()        func(*args, **kwargs)          end = time.time() - start         print(\"{} 함수수행 시간은 {} 입니다.\".format(func.__name__,end))    return my_inner_function  @my_timer_function     # decorator 순서에 주의해야 한다. 아래쪽이 먼저 실행  @my_exec_functiondef my_adder(x,y):    print(\"두 수를 더한 결과는 {}\".format(x+y))    my_adder(10,20)        # 정상수행decorator의 이야기는 여기까지 입니다. 형태만 보고 이거 Java언어의 annotation이랑 비슷한건가라고 생각하셨을 텐데 결론적으로는 아니었죠. 함수를 wrapping하는 기술이라고간단하게 정리할 수 도 있을 듯 합니다.이론적으로 더 파고들수는 있지만 이정도만 알고있어도 decorator가 무엇이고 우리의 코드에서 어떻게, 왜 적용해야 하는가에 대한 의문은 해결될 수 있다고생각됩니다.End.Python 강좌는 아래의 책과 사이트를 참조했습니다.    조금 더 자세한 사항을 알고 싶으시면 해당 사이트를 방문하세요!!    Python Official HomePage    점프 투 파이썬 - 이지스 퍼블리싱    전문가를 위한 파이썬(Fluent Python) - 한빛미디어    파이썬 웹 프로그래밍 - 한빛미디어    이미지 출처 : Designed by rawpixel.com / Freepik",
        "url": "/python-lecture-python-decorator"
    }
    ,
    
    "python-lecture-python-closure": {
        "title": "Python 기초강의(9) - Python Closure",
            "author": "moon9342",
            "category": "",
            "content": "Python 기초강의는 여러 절로 구성되어 있습니다.     Python 기초강의(1) - Introduction    Python 기초강의(2) - Python 기본    Python 기초강의(3) - Python 제어문    Python 기초강의(4) - Python function    Python 기초강의(5) - Python 연습문제(1)    Python 기초강의(6) - Python 객체지향    Python 기초강의(7) - Python Magic Function    Python 기초강의(8) - Python First Class    Python 기초강의(9) - Python Closure    Python 기초강의(10) - Python Decorator    Python 기초강의(11) - Python Generator    Python 기초강의(12) - Python Module    Python 기초강의(13) - Python Exception &amp; File    Python 기초강의(14) - Python 연습문제(2)    Python Django 웹 프레임워크(1) - introduction    Python Django 웹 프레임워크(2) - Poll project 개발(1)    Python Django 웹 프레임워크(3) - Poll project 개발(2)    Python Django 웹 프레임워크(4) - Poll project 개발(3)    Python Django 웹 프레임워크(5) - Poll project 개발(4)    Python Django 웹 프레임워크(6) - Poll project 개발(5)    Python Django 웹 프레임워크(7) - Django의 개발방식    Python Django 웹 프레임워크(8) - Blog project 개발    Closure다음은 Closure에 대한 위키피디아의 설명입니다.  컴퓨터 언어에서 클로저(Closure)는 일급 객체 함수(first-class functions)의 개념을 이용하여 스코프(scope)에 묶인 변수를 바인딩 하기 위한 일종의 기술이다. 기능상으로, 클로저는 함수를 저장한 레코드(record)이며, 스코프(scope)의 인수(Factor)들은 클로저가 만들어질 때 정의(define)되며, 스코프 내의 영역이 소멸(remove)되었어도 그에 대한 접근(access)은 독립된 복사본인 클로저를 통해 이루어질 수 있다.기존에 프로그래밍을 하신 분들이라면 위의 내용을 이해할 수 있겠지만 그렇지 않은 분들은이게 무슨 소리야?? 라는게 정상적인 반응입니다.이전에 first-class function에서 언급했듯이Closure는 함수가 다른 함수를 리턴값으로 사용할 때 이용되는 기술입니다.아주 간단한 예제를 통해서 알아보도록 하겠습니다.def my_outer_function(x):    tmp = x         def my_inner_function():        print(tmp *10)     # tmp : free variable    return my_inner_function()my_outer_function(10)     # 100위의 코드는 이해하기 어렵지 않습니다.  my_outer_function 함수는 자신이 가지고 있는내부 함수 my_inner_function를 실행해 그 결과값을 리턴하는 구조입니다.다음의 코드는 위의 코드를 살짝 수정한 것입니다.def my_outer_function(x):    tmp = x         def my_inner_function():        print(tmp *10)     # tmp : free variable    return my_inner_function     # 리턴값이 바뀌었다.my_outer_function(10)     my_outer_function 함수는 자신이 정의한 my_inner_function 함수 자체를 리턴합니다. 리턴값이 함수이기 때문에 다음과 같이 수행시키는 것이 가능할 것입니다.def my_outer_function(x):    tmp = x         def my_inner_function():        print(tmp *10)     # tmp : free variable    return my_inner_function     # 리턴값이 바뀌었다.my_outer_function(10)()     # 함수자체가 리턴되기 때문에 실행시키기 위해서 () 추가자 여기까지 이해했다고 해도 한가지 더 이상한 점이 남습니다. 바로 tmp라는 지역변수의값이 어떻게 유지되고 있냐는 것입니다.우리가 알다시피 지역변수는 함수가 호출될 때 스택영역에 생성되게 되고 함수가 끝나면해당 함수의 스택영역이 POP되기 때문에 그 안에 생성된 지역변수들은 당연히 사용할 수 없게됩니다. 이게 우리가 알고있는 지역변수의 scope 입니다.위의 예제를 다시 보면 tmp는 지역변수인데 함수의 호출이 끝나 내부의 함수가리턴된 후 그 내부함수를 실행(호출)했을 때 tmp의 값을 참조할 수 있습니다.이게 어떻게 가능할까? 라는 질문의 답이 바로 Closure 입니다.이를 알아보기 위해서 코드를 약간 수정해서 다시 살펴보도록 하겠습니다.def my_outer_function(x):    tmp = x         def my_inner_function():        print(tmp *10)     # tmp : free variable    return my_inner_function     # 리턴값이 바뀌었다.my_func = my_outer_function(10)# &lt;function my_outer_function.&lt;locals&gt;.my_inner_function at 0x7f94ddb43ea0&gt;print(my_func)                              # 함수가 가지고 있는 속성print(dir(my_func))                         print(type(my_func.__closure__))      # &lt;class 'tuple'&gt;      # 첫번째 인자의 type =&gt; class cellprint(type(my_func.__closure__[0]))         # class cell의 속성과 함수print(dir(my_func.__closure__[0]))          # cell_contents 속성안에 tmp값을 저장해놓음.print(my_func.__closure__[0].cell_contents) 위의 코드에서 주석으로 달아놓은 것처럼 리턴되는 함수는 내부에 자료구조를 생성하여free variable의 값을 저장해 놓고 있는 것을 알 수 있습니다. 여기서 free variable이란코드블럭안에서 사용은 되었지만 그 코드블럭안에서 정의되지 않은 변수를 의미합니다. 즉, 우리 예제에서는 tmp가 free variable입니다.자 이제 맨 처음 위키피디아의 정의를 다시 한번 읽어보도록 하죠. 아까보다는 약간 이해가 가지 않나요??End.Python 강좌는 아래의 책과 사이트를 참조했습니다.    조금 더 자세한 사항을 알고 싶으시면 해당 사이트를 방문하세요!!    Python Official HomePage    점프 투 파이썬 - 이지스 퍼블리싱    전문가를 위한 파이썬(Fluent Python) - 한빛미디어    파이썬 웹 프로그래밍 - 한빛미디어    이미지 출처 : Designed by rawpixel.com / Freepik",
        "url": "/python-lecture-python-closure"
    }
    ,
    
    "python-lecture-python-first-class": {
        "title": "Python 기초강의(8) - Python First Class",
            "author": "moon9342",
            "category": "",
            "content": "Python 기초강의는 여러 절로 구성되어 있습니다.     Python 기초강의(1) - Introduction    Python 기초강의(2) - Python 기본    Python 기초강의(3) - Python 제어문    Python 기초강의(4) - Python function    Python 기초강의(5) - Python 연습문제(1)    Python 기초강의(6) - Python 객체지향    Python 기초강의(7) - Python Magic Function    Python 기초강의(8) - Python First Class    Python 기초강의(9) - Python Closure    Python 기초강의(10) - Python Decorator    Python 기초강의(11) - Python Generator    Python 기초강의(12) - Python Module    Python 기초강의(13) - Python Exception &amp; File    Python 기초강의(14) - Python 연습문제(2)    Python Django 웹 프레임워크(1) - introduction    Python Django 웹 프레임워크(2) - Poll project 개발(1)    Python Django 웹 프레임워크(3) - Poll project 개발(2)    Python Django 웹 프레임워크(4) - Poll project 개발(3)    Python Django 웹 프레임워크(5) - Poll project 개발(4)    Python Django 웹 프레임워크(6) - Poll project 개발(5)    Python Django 웹 프레임워크(7) - Django의 개발방식    Python Django 웹 프레임워크(8) - Blog project 개발    First Classfirst-class citizen 이라는 개념에 대해서 알아보겠습니다. 프로그램 개체가 다음의 특성을 만족할 때 first-class citizen 이라고 정의됩니다.  변수나 데이터 구조의 속성으로 저장될 수 있다  함수의 인자로 전달될 수 있다.  함수의 결과로 리턴될 수 있다.아주 단순한 예로 우리가 프로그래밍에서 사용하는 숫자 타입의 데이터는 first-class citizen 입니다.앞서 객체지향에 대한 이야기도 했었는데 위의 특성을 만족하는 객체를 우리는 1급 객체라고도표현합니다.자 우리의 python으로 돌아와서 다시 생각해보도록 하죠.python의 함수는 first-class 특성을 가지는 객체입니다. 이런 함수를 first-class function이라고하는데 first-class function은 다음의 두가지 특성을 추가로 가집니다.  runtime으로 생성이 가능하다.  익명으로 생성이 가능하다.그러면 이런 first-class function의 이점은 무엇일까요? 단적으로 얘기하면 프로그램의 유연성이대폭 높아져서 효율적인 프로그래밍이 가능하게 합니다.first-class function이란 용어를 처음 접하는 분들은 솔직히 아직 감이 잘 안 올텐데 예제를 이용해서 하나씩 살펴보도록 하겠습니다.변수에 함수를 저장할 수 있어요def my_add(x,y):    return x + yprint(\"함수 호출 결과 : {}\".format(my_add(10,20)))print(my_add)        # my_add 라는 변수에 함수의 실행코드가 있는 메모리 시작 주소가 저장f = my_add           # 다른 변수에 함수의 시작 주소를 저장(변수에 함수를 저장)print(f)            print(f(20,30))      # 당연히 함수 호출이 가능Python은 first-class function을 지원하기 때문에 위의 예에서 본 것처럼 함수를변수에 저장(할당)할 수 있습니다.함수를 다른 함수의 인자로 전달할 수 있어요def my_add(x,y):    return x + ydef my_operation(func, arg_list):    result = []    for (tmp1,tmp2) in arg_list:        result.append(func(tmp1,tmp2))    return result        data = [(1,2), (3,4), (5,6)]my_result = my_operation(my_add,data)print(\"함수 호출 결과 : {}\".format(my_result))위의 예처럼 하나의 함수를 다른 함수의 인자로 전달할 수 있습니다. 오히려 더 복잡한거 아니냐? 라는생각이 들 수 있지만 아래의 예처럼 여러개의 함수를 만들어 놓고 내가 사용할 함수와 인자를 같이전달하는 방식을 이용하면 함수 자체의 기능을 수정하지 않고 여러 기능을 이용할 수 있다는 편리성이생기게 됩니다.def my_add(x,y):    return x + ydef my_minus(x,y):    return x - ydef my_mul(x,y):    return x * ydef my_operation(func, arg_list):    result = []    for (tmp1,tmp2) in arg_list:        result.append(func(tmp1,tmp2))    return result        data = [(1,2), (3,4), (5,6)]my_result1 = my_operation(my_add,data)   # 합my_result2 = my_operation(my_minus,data) # 차my_result3 = my_operation(my_mul,data)   # 곱print(\"함수 호출 결과 : {}\".format(my_result1))print(\"함수 호출 결과 : {}\".format(my_result2))print(\"함수 호출 결과 : {}\".format(my_result3))함수의 리턴값으로 다른 함수를 사용할 수 있어요def addMaker(x):    def my_add_maker(y):        return x + y    return my_add_makeradd_5 = addMaker(5);add_10 = addMaker(10);print(\"결과값은 : {}\".format(add_5(1)))print(\"결과값은 : {}\".format(add_5(5)))print(\"결과값은 : {}\".format(add_10(20)))위의 예제는 함수를 결과값으로 리턴하는 함수에 대한 예제입니다. 이 예제를 살펴보면무언가 이상한 점을 발견할 수 있습니다. 로컬 변수의 scope가 유지되고 있다는 점이 이상하게보입니다. 이 부분은 Closure(클로져)에서 다시 얘기하기로 하죠.사실 first-class function의 개념은 그다지 어려운 개념은 아닙니다. 단, 이렇게 유연한프로그래밍 기법을 어디서 어떻게 활용해야 생산성, 효율성을 높일 수 있는가 하는게 문제인 듯 합니다.이런 기법들을 이용해서 기존의 코드보다 더 효율적인 코드를만들어 낼 수 있다는걸 인식하고 어떻게 하면 활용할 수 있을까를 계속 고민하는 것도 좋은 학습방법이지 않을까 합니다.End.Python 강좌는 아래의 책과 사이트를 참조했습니다.    조금 더 자세한 사항을 알고 싶으시면 해당 사이트를 방문하세요!!    Python Official HomePage    점프 투 파이썬 - 이지스 퍼블리싱    전문가를 위한 파이썬(Fluent Python) - 한빛미디어    파이썬 웹 프로그래밍 - 한빛미디어    이미지 출처 : Designed by rawpixel.com / Freepik",
        "url": "/python-lecture-python-first-class"
    }
    ,
    
    "python-lecture-python-magic-function": {
        "title": "Python 기초강의(7) - Python Magic Function",
            "author": "moon9342",
            "category": "",
            "content": "Python 기초강의는 여러 절로 구성되어 있습니다.     Python 기초강의(1) - Introduction    Python 기초강의(2) - Python 기본    Python 기초강의(3) - Python 제어문    Python 기초강의(4) - Python function    Python 기초강의(5) - Python 연습문제(1)    Python 기초강의(6) - Python 객체지향    Python 기초강의(7) - Python Magic Function    Python 기초강의(8) - Python First Class    Python 기초강의(9) - Python Closure    Python 기초강의(10) - Python Decorator    Python 기초강의(11) - Python Generator    Python 기초강의(12) - Python Module    Python 기초강의(13) - Python Exception &amp; File    Python 기초강의(14) - Python 연습문제(2)    Python Django 웹 프레임워크(1) - introduction    Python Django 웹 프레임워크(2) - Poll project 개발(1)    Python Django 웹 프레임워크(3) - Poll project 개발(2)    Python Django 웹 프레임워크(4) - Poll project 개발(3)    Python Django 웹 프레임워크(5) - Poll project 개발(4)    Python Django 웹 프레임워크(6) - Poll project 개발(5)    Python Django 웹 프레임워크(7) - Django의 개발방식    Python Django 웹 프레임워크(8) - Blog project 개발    Magic Method  method 이름 앞뒤에 더블 언더스코어(__)가 붙어 있습니다. (대표적인 magic method : __init__)  class안에 정의할 수 있는 특수한 형태의 method입니다.  일반적으로 연산자(+, -, &gt;, &lt;)가 동작할 때 각각의 데이터 타입에 맞는 method로 오버로딩하여 백그라운드에서 연산을 수행합니다.일반적으로 class의 method를 호출할 때 우리는 직접 magic method를 호출하지 않습니다. 특정 상황이 되면내부적으로 수행되게 됩니다.# Magic Methodclass Student(object):    def __init__(self,name,dept):        self.name = name        self.dept = dept        print(\"{1} 학과 {0} 학생이 생성되었습니다.\".format(self.name,self.dept))    def __del__(self):        print(\"소멸자가 호출되었습니다.!!\")stu_1 = Student(\"홍길동\",\"컴퓨터\")    # __init__ 호출del stu_1                             # __del__ 호출우리가 흔히 사용하는 연산자(operator)는 내부적으로 magic method를 호출하게 됩니다. 다음의 예를 보죠# Magic Method - __add__ methodclass MyInt(int):    passmynum = MyInt(100)print(mynum + 200)         # + 연산자 이용print(mynum.__add__(200))  # __add__ magic method 명시적 호출어떤 method가 실행되는지 몰라도 결과값은 똑같은데 이렇게 자동으로 호출되는 매직 메소드에 대해서 알고있어야 할 필요가 있을까요?다음의 예제를 한번 보면 magic method의 활용에 대해서 이해할 수 있을 듯 합니다.# Magic Method - 필요성class Car(object):    def __init__(self, model, price):        self.model = model        self.price = pricecar_1 = Car(\"Genesis G70\", 5000)# 인스턴스 정보 출력print(car_1)         # car_1 객체의 메모리 주소가 출력된다.###########################################class Car(object):    def __init__(self, model, price):        self.model = model        self.price = price    def __str__(self):        return \"차종은 {} 이고 차량 가격은 {} 입니다.(__str__ 이용)\".format(self.model,self.price)    # def __repr__(self):    #     return \"차종은 {} 이고 차량 가격은 {} 입니다.(__repr__ 이용)\".format(self.model,self.price)car_1 = Car(\"Genesis G70\", 5000)# 인스턴스 정보 출력print(car_1)         # __str__ method 또는 __repr__ method가 호출되어서 객체의 정보가 출력된다.이번에는 operator에 대해서 magic method를 활용하는 방법에 대해서 알아보도록 하겠습니다. 다음의 코드를 보도록하죠# Magic Method - operator 응용class Car(object):    def __init__(self, model, price):        self.model = model        self.price = pricecar_1 = Car(\"Genesis G70\", 5000)car_2 = Car(\"Sonata\", 3000)print(car_1 &lt; car_2)   # 어느차가 더 비싼차인지를 알아보자!!                       # 이 코드는 당연히 Errorclass Car(object):    def __init__(self, model, price):        self.model = model        self.price = price    def __lt__(self, other):        if self.price &lt; other.price:            return \"{} 가격이 더 낮습니다.\".format(self.model)        else:            return \"{} 가격이 같거나 더 높습니다.\".format(self.model)    car_1 = Car(\"Genesis G70\", 5000)car_2 = Car(\"Sonata\", 3000)print(car_1 &lt; car_2)  # Magic Method 활용End.Python 강좌는 아래의 책과 사이트를 참조했습니다.    조금 더 자세한 사항을 알고 싶으시면 해당 사이트를 방문하세요!!    Python Official HomePage    점프 투 파이썬 - 이지스 퍼블리싱    전문가를 위한 파이썬(Fluent Python) - 한빛미디어    파이썬 웹 프로그래밍 - 한빛미디어    이미지 출처 : Designed by rawpixel.com / Freepik",
        "url": "/python-lecture-python-magic-function"
    }
    ,
    
    "python-lecture-python-oop": {
        "title": "Python 기초강의(6) - Python 객체지향",
            "author": "moon9342",
            "category": "",
            "content": "Python 기초강의는 여러 절로 구성되어 있습니다.     Python 기초강의(1) - Introduction    Python 기초강의(2) - Python 기본    Python 기초강의(3) - Python 제어문    Python 기초강의(4) - Python function    Python 기초강의(5) - Python 연습문제(1)    Python 기초강의(6) - Python 객체지향    Python 기초강의(7) - Python Magic Function    Python 기초강의(8) - Python First Class    Python 기초강의(9) - Python Closure    Python 기초강의(10) - Python Decorator    Python 기초강의(11) - Python Generator    Python 기초강의(12) - Python Module    Python 기초강의(13) - Python Exception &amp; File    Python 기초강의(14) - Python 연습문제(2)    Python Django 웹 프레임워크(1) - introduction    Python Django 웹 프레임워크(2) - Poll project 개발(1)    Python Django 웹 프레임워크(3) - Poll project 개발(2)    Python Django 웹 프레임워크(4) - Poll project 개발(3)    Python Django 웹 프레임워크(5) - Poll project 개발(4)    Python Django 웹 프레임워크(6) - Poll project 개발(5)    Python Django 웹 프레임워크(7) - Django의 개발방식    Python Django 웹 프레임워크(8) - Blog project 개발    영상설명이번 영상은 Python 언어의 Object Oriented 영상입니다.Python 객체지향Why OOP?class &amp; instanceInheritance  Python 기초강의 - Python 객체지향Python 객체지향Programming paradigm의 변화에 대해서 그림으로 알아보겠습니다.  구조적 프로그래밍      프로그램 작성 시 기능으로 세분화 한 다음 각각의 기능을 모듈로 제작    프로그램을 모듈(함수)이라는 실행단위로 분할.    상위 모듈에서 하위 모듈을 호출하는 방식으로 프로그램을 구성    프로그램 구조를 이해하기 쉽고 프로그램을 빠르게 작성할 수 있다.    프로그램 규모가 커지게 되면 유지보수와 기존 코드의 재사용에 한계가 나타나게 된다.    객체지향 프로그래밍      현실세계의 해결해야 하는 문제를 그대로 프로그램으로 표현.    즉, 프로그램을 기능으로 세분화 하지 않고    프로그램을 구성하는 주체(객체)들을 파악하고 그 객체들간의 data 흐름에 초점을 맞추어서  프로그램 작성    프로그램의 설계, 작성이 상대적으로 어려움.    하지만 이렇게 작성된 객체지향 프로그램은 유지보수와 재사용성에 이점이 있다.  정리를 하자면,객체 지향 프로그래밍은 컴퓨터 프로그래밍의 패러다임의 하나입니다.객체 지향 프로그래밍은 컴퓨터 프로그램을 명령어의 목록으로 보는 시각에서 벗어나 여러 개의 독립된 단위, 즉 객체들의 모임으로 파악하고자 하는 것입니다.Why OOP?간단하게 학생데이터를 이용하여 왜 객체지향으로 프로그래밍을 하면 편리하고 좋은지를 알아보도록 하겠습니다.다음의 코드는 학생의 이름, 학과, 학번, 각 학년 평점을 저장하는 다양한 방법을 보여줍니다.# python OOP# 학생의 이름, 학과, 학번, 각 학년 평점을 저장하는 다양한 방법# 1명의 학생 정보를 저장stu_name = \"홍길동\"    # 이름stu_dept = \"컴퓨터\"    # 학과stu_num = \"202011003\"   # 학번stu_grade = 3.5         # 학점# 만약 3명의 학생 정보를 저장하려면 어떻게 해야 할까요?stu1_name = \"강감찬\"    # 이름stu1_dept = \"철학\"    # 학과stu1_num = \"201998015\"   # 학번stu1_grade = 4.5         # 학점stu2_name = \"신사임당\"    # 이름stu2_dept = \"경영\"    # 학과stu2_num = \"201844028\"   # 학번stu2_grade = 3.4         # 학점stu3_name = \"이순신\"    # 이름stu3_dept = \"국어국문\"    # 학과stu3_num = \"202011040\"   # 학번stu3_grade = 3.8         # 학점# 위의 코드는 중복된 코드가 너무 많다. 리스트를 이용해서 조금 더# 나은 형태의 코드로 변경해보겠습니다.stu_name = [\"강감찬\", \"신사임당\", \"이순신\"]stu_dept = [\"철학\", \"경영\", \"국어국문\"]stu_num = [\"201998015\", \"201844028\", \"202011040\"]stu_grade = [4.5, 3.4, 3.8]print(\"학생이름 : {}\\n학생학과 : {}\\n학번 : {}\\n성적 : {}\".format(    stu_name[0], stu_dept[0], stu_num[0], stu_grade[0]))# 첨자(index)가 같은 데이터는 한 사람의 데이터를 의미하게 처리했습니다.# 조금 나은 형태이지만 이 역시 실수를 유발할 여지가 많고 첨자(index)처리에# 혼동이 올 수 있기 때문에 추천되지 않습니다.# 마지막으로 class를 이용해 한 사람의 데이터를 논리적인 하나의 단위(객체)로# 묶어 사용하는 방법을 살펴보겠습니다.class Student(object):    def __init__(self, name, dept, num, grade):        self.name = name        self.dept = dept        self.num = num        self.grade = grade    def __repr__(self):        return self.namestudents = []students.append(Student(\"강감찬\", \"철학\", \"201998015\", 4.5))students.append(Student(\"신사임당\", \"경영\", \"201844028\", 3.4))students.append(Student(\"이순신\", \"국어국문\", \"202011040\", 3.8))print(students)print(students[0].dept)class &amp; instance  파이썬은 객체 지향적 프로그래밍 언어입니다. 파이썬의 모든 것은 객체(object)입니다. 문자열, 리스트, 함수, 심지어 모듈 또한 객체(object)입니다.일반적으로 파이썬 객체지향을 설명할 때 하는 말입니다. 사실 객체지향 언어의 대부분이 같은 특성을 가집니다. 그러면 객체는 무엇일까요?  객체란 속성과 같은 여러가지의 데이터와 함수(객체 안에서는 메소드라고 부릅니다.)를 포함한 하나의 데이터 구조를 말합니다파이썬에서 이 객체들은 변수에 할당될 수도 있고, 함수(혹은 메소드)의 인자로 전달될 수도 있습니다.# 객체란 무엇인가?class Student(object):    def __init__(self, name, dept, num, grade):        self.name = name        self.dept = dept        self.num = num        self.grade = grade    def get_student_info(self):        return \"이름 : {}, 학과 : {}, 학번 : {}\".format(self.name,self.dept,self.num)# 객체 생성stu1 = Student(\"홍길동\", \"컴퓨터\", \"202011003\", 3.5)# 메소드 호출print(stu1.get_student_info())print(Student.get_student_info(stu1))dir() 함수중요한 함수 중 하나는 dir() 입니다. 이 함수는 만약 인자로 객체가 들어오지 않으면 현재 module scope상의지역변수를 리턴하고 객체 인자가 있을 경우 객체의 모든 속성과 메소드의 목록을 리턴합니다.# dir() 함수print(dir(stu1))# 결과['__class__', '__delattr__', '__dict__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__le__', '__lt__', '__module__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__', 'dept', 'get_student_info', 'grade', 'name', 'num']python은 함수 역시 객체한가지 특이한 점은 python의 함수 역시 객체라는 것입니다.def my_func():    pass# my_func의 속성과 메소드 확인print(\"my_func의 dir() : \", dir(my_func))my_func의 dir() :  ['__annotations__', '__call__', '__class__', '__closure__', '__code__', '__defaults__', '__delattr__', '__dict__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__get__', '__getattribute__', '__globals__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__kwdefaults__', '__le__', '__lt__', '__module__', '__name__', '__ne__', '__new__', '__qualname__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__']# my_func에 새로운 속성 추가(객체이기 때문에 가능)my_func.myName = '강감찬'# 추가된 속성 확인print(\"my_func의 dir() : \", dir(my_func))my_func의 dir() :  ['__annotations__', '__call__', '__class__', '__closure__', '__code__', '__defaults__', '__delattr__', '__dict__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__get__', '__getattribute__', '__globals__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__kwdefaults__', '__le__', '__lt__', '__module__', '__name__', '__ne__', '__new__', '__qualname__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', 'myName']# 추가한 속성값 출력print(\"my_func의 myName : \", my_func.myName)my_func의 myName :  강감찬__init__ 메소드class로 부터 객체를 생성할 때 중요한 메소드가 하나 있습니다. 바로 __init__ 메소드입니다. 일반적으로다른 객체지향언어에서는 생성자(constructor)라고 불리는 것입니다. python에서는 initializer라고 부릅니다.이 메소드는 객체가 생성될 때 자동으로 호출되며 호출되는 순간 instance를 self라는 인자로 받아서 처리합니다.위의 코드에서print(stu1.get_student_info())라는 부분이 있는데 이 코드가 실행되면 실제로는print(Student.get_student_info(stu1))이 코드가 실행되게 됩니다.인스턴스 변수, 인스턴스 메소드위에서 self라는 키워드에 대해서 설명했는데 이 self를 이용하여 생성되는 속성을인스턴스 변수, self를 이용한 메소드를 인스턴스 메소드라고 합니다.당연히 이 인스턴스 변수는 각각의 instance가 개별적으로 가지고 있는 데이터 입니다.클래스 변수이 인스턴스 변수와 살짝 다른 개념이 바로 클래스 변수(class variable)입니다. 이 변수는모든 인스턴스가 공유하는 변수라고 생각하시면 됩니다.즉, 인스턴스 차원이 아닌 클래스 차원의 변수라고 보시면 됩니다.# class variable 예제class Student(object):    scholarship_rate = 3.5   # class variable    def __init__(self, name, dept, num, grade):        self.name = name        self.dept = dept        self.num = num        self.grade = grade    def get_student_info(self):        return \"이름 : {}, 학과 : {}, 학번 : {}\".format(self.name,self.dept,self.num)    def is_scholarship(self):        if self.grade &gt;= Student.scholarship_rate:   # class variable 사용            return True        else:            return False# 문제를 단순화 시키기 위해서 학점부분을 학년으로 구분하지 않고# 전체평균평점으로 처리stu1 = Student(\"홍길동\", \"컴퓨터\", \"202011003\", 4.0)   # 객체 생성print(\"장학금 여부 : \", stu1.is_scholarship())  네임스페이스(namespace)Python은 그림과 같은 모양의 네임스페이스라는 것을 가지고 있습니다. 이 네임스페이스는 객체들의 이름들을 나눠서 관리하는데, 이름을 찾을때 인스턴스 네임스페이스 -&gt; 클래스 네임스페이스 -&gt; 수퍼 클래스 네임스페이스의 순서로 찾아갑니다. 하지만 반대로는 찾지 않습니다. 즉, 자식이 부모의 네임스페이스는 참조 할 수 있는데, 부모가 자식의 네임스페이스를 참조할 수는 없습니다.따라서 class variable을 사용하는 위의 코드에서 다음과 같이 변경해서 사용할 수 있습니다.    def is_scholarship(self):        # class variable을 class명이 아닌 self로 사용가능.        if self.grade &gt;= self.scholarship_rate:               return True        else:            return False다른 객체지향 언어(예를들어 Java)같은 경우 instance가 생성된 후 속성을 동적으로 추가할 수 없습니다.하지만 python은 동적으로 속성을 추가할 수 있기 때문에 namespace와 관련된 다음과 같은 문제가 생길 수 있습니다.# namespace 주의해야 할 점class Student(object):    scholarship_rate = 3.5   # class variable    def __init__(self, name, dept, num, grade):        self.name = name        self.dept = dept        self.num = num        self.grade = grade    def get_student_info(self):        return \"이름 : {}, 학과 : {}, 학번 : {}\".format(self.name,self.dept,self.num)    def is_scholarship(self):        if self.grade &gt;= self.scholarship_rate:   # instance namespace 사용            return True        else:            return False# 문제를 단순화 시키기 위해서 학점부분을 학년으로 구분하지 않고# 전체평균평점으로 처리stu1 = Student(\"홍길동\", \"컴퓨터\", \"202011003\", 4.0)   # 객체 생성print(\"장학금 여부 : \", stu1.is_scholarship())   # Truestu1.scholarship_rate = 4.5   # instance namespace 안에                              # scholarship_rate 속성이 새로 생성print(\"장학금 여부 : \", stu1.is_scholarship())   # Falseclass method인스턴스 메소드는 self인 인스턴스를 인자로 받고 인스턴스 변수와 같이 하나의 인스턴스에만 한정된 데이터를 생성, 변경, 참조하기 위해서 사용됩니다.클래스 메소드는 cls인 클래스를 인자로 받고 모든 인스턴스가 공유하는 클래스 변수와 같은 데이터를 생성, 변경 또는 참조하기 위해서 사용됩니다.# class method 예제class Employee(object):    raise_rate = 1.1  # 연봉 인상율 class variable    def __init__(self, u_name, u_pay):        self.u_name = u_name        self.u_pay = u_pay    def apply_raise(self):        self.u_pay = int(self.u_pay * self.raise_rate)    def get_pay(self):        return '현재 \"{}\"의 연봉은 \"{}\"입니다.'.format(self.u_name, self.u_pay)    # 클래스 메소드 데코레이터를 사용하여 클래스 메소드 정의    @classmethod    def change_raise_rate(cls, rate):        cls.raise_rate = rate        print('인상율 \"{}\"가 적용 되었습니다.'.format(rate))emp_1 = Employee(\"홍길동\", 1000)emp_2 = Employee(\"강감찬\", 5000)# 연봉 인상 전print(emp_1.get_pay())print(emp_2.get_pay())# 연봉 인상율 변경Employee.change_raise_rate(1.5)   # class method 호출# 연봉 인상emp_1.apply_raise()emp_2.apply_raise()# 연봉 인상 후print(emp_1.get_pay())print(emp_2.get_pay())static method인스턴스 메소드는 인스턴스를 통해서 호출이 되고, 첫 번째 인자로 인스턴스 자신을 자동으로 전달합니다. 이 인수를 self라고 칭합니다.클래스 메소드는 클래스를 통해서 호출이 되고 @classmethod라는 데코레이터로 정의합니다. 첫 번째 인자로는 클래스 자신이 자동으로 전달되고 이 인수를 cls라고 칭합니다.스태틱 메소드는 앞서 설명한 두 메소드와는 틀리게 인스턴스나 클래스를 첫 번째 인자로 받지 않습니다. 스태틱 메소드는 클래스 안에서 정의되어 클래스 네임스페이스 안에는 있을뿐 일반 함수와 동일하게 동작합니다.# static method 예제class Employee(object):    def __init__(self, u_name, u_pay):        self.u_name = u_name        self.u_pay = u_pay    def apply_raise(self):        self.u_pay = int(self.u_pay * self.raise_rate)    def get_pay(self):        return '현재 \"{}\"의 연봉은 \"{}\"입니다.'.format(self.u_name, self.u_pay)    # 스태틱 메소드 데코레이터를 사용하여 클래스 메소드 정의    @staticmethod    def is_valid(u_pay):        if u_pay &lt; 0:            print(\"인상율은 음수가 될 수 없습니다.\")emp_1 = Employee(\"홍길동\", 1000)Employee.is_valid(-10)public vs. privatePython은 기본적으로 instance variable과 class variable이 public으로 지정됩니다.즉, 객체 외부에서 자유롭게 해당 객체의 데이터를 살펴보고 변경할 수 있다는 말이죠.편하기는 하지만 객체지향적 관점에서는 지양해야 되는 부분입니다. 객체 외부에서 객체의 데이터를함부로 변경하게 되면 여러 문제를 야기할 수 있기 때문입니다. 객체지향에서는 information hiding(정보은닉) 개념이 있어서 이런 부분을 지양하도록 강력 권장합니다.그러면 우리의 public으로 기본 설정된 instance variable을 어떻게 하면 private으로 변경할 수 있을까요? __를 instance variable 앞에 붙이면 됩니다.다음의 예제를 이용해서 살펴보도록 하죠# public vs. privateclass Student(object):    def __init__(self, name, dept, num):        self.name = name     # public        self.__dept = dept   # private        self.num = num    def get_student_info(self):        return \"이름 : {}, 학과 : {}, 학번 : {}\".format(self.name,self.__dept,self.num)    def getDept(self):        return self.__dept    def __getInfo(self):        return \"__로 시작했기 때문에 private method 입니다.\"    stu1 = Student(\"홍길동\", \"컴퓨터\", \"202011003\")   # 객체 생성print(\"학생 이름은 : {}\".format(stu1.name))    #  홍길동print(\"학생 이름은 : {}\".format(stu1.num))     #  202011003# print(\"학생 이름은 : {}\".format(stu1.__dept))  #  Errorprint(stu1.get_student_info())   # access 가능print(stu1.getDept())            # getter# print(stu1.__getInfo())          # Error외부 함수와 내부 method 구별외부함수의 이름과 class의 method 이름이 같다면 어떻게 사용해야 하는가에 대한 설명입니다.# 외부 함수와 내부 method 구별def print_name():    return \"이것은 소리없는 아우성!!\"class Student(object):    def __init__(self, name):        self.name = name         def print_name(self):        return \"이름 : {}\".format(self.name)    def call_method(self):        print(print_name())       # 외부함수 호출        print(self.print_name())  # instance method 호출stu1 = Student(\"홍길동\")   # 객체 생성stu1.call_method()Inheritance상속은 한 번 정의한 데이터 타입(class)을 필요에 따라 재활용해서 반복되는 코드를 줄이고자 하는 목적을 가지고 있습니다.여기서는 Unit, Marine을 대상으로 상속에 대한 내용을 알아보도록 하겠습니다.가장 먼저 Unit class를 정의합니다. 이 class는 모든 유닛이 가지고 있어야 할 속성을 가지고 있는 베이스 class가 될 것입니다. 그리고 이 Unit class를 상속받는 Marine sub class를 정의하도록 하겠습니다.# Inheritance 예제class Unit(object):    def __init__(self, damage, life):        self.utype = self.__class__.__name__        self.damage = damage        self.life = life            def show_status(self):        print('직업: {}'.format(self.utype))        print('공격력: {}'.format(self.damage))        print('생명력: {}'.format(self.life))        class Marine(Unit):    passmarine_1 = Marine('100', '100')marine_1.show_status()# Student class가 어떠한 구조를 가지고 있나를 확인print(help(Marine))인스턴스 생성시에 무조건 호출되어야 하는 __init__() method도 자신의 네임스페이스에서 찾지 못 하면 부모 클래스에서 참조하는 것을 알 수 있습니다.이제 코드를 약간 수정해서 Marine class에 Marine만이 가지고 있는 속성을 추가해 보도록 하겠습니다.# method overridingclass Unit(object):    def __init__(self, damage, life):        self.utype = self.__class__.__name__        self.damage = damage        self.life = life            def show_status(self):        print('직업: {}'.format(self.utype))        print('공격력: {}'.format(self.damage))        print('생명력: {}'.format(self.life))        class Marine(Unit):    def __init__(self, damage, life, offense_upgrade, defense_upgrade):        self.utype = self.__class__.__name__        self.damage = damage        self.life = life        self.offense_upgrade = offense_upgrade        self.defense_upgrade = defense_upgrade            def show_status(self):        print('직업: {}'.format(self.utype))        print('공격력: {}'.format(self.damage))        print('생명력: {}'.format(self.life))        print('공격력 업그레이드: {}'.format(self.offense_upgrade))        print('방어력 업그레이드: {}'.format(self.defense_upgrade))            marine_1 = Marine('100', '100',0,0)marine_1.show_status()상위 class의 method를 하위 class에서 재정의 하는 것을 method overriding이라고 합니다. 같은 이름의 method를 사용해야 하지만 class가 다르기 때문에 실제 수행되는 코드가 변경되어야 할 때 이 개념을 이용합니다.method overriding을 이용했지만 위의 코드는 중복되는 코드가 너무 많아서 상속의 장점을 살리지 못하고있습니다. 이 코드를 super()를 이용하여 수정해 보도록 하겠습니다.# method overriding using super()class Unit(object):    def __init__(self, damage, life):        self.utype = self.__class__.__name__        self.damage = damage        self.life = life            def show_status(self):        print('직업: {}'.format(self.utype))        print('공격력: {}'.format(self.damage))        print('생명력: {}'.format(self.life))        class Marine(Unit):    def __init__(self, damage, life, offense_upgrade, defense_upgrade):        super(Marine, self).__init__(damage, life)        self.offense_upgrade = offense_upgrade        self.defense_upgrade = defense_upgrade            def show_status(self):        super(Marine, self).show_status()        print('공격력 업그레이드: {}'.format(self.offense_upgrade))        print('방어력 업그레이드: {}'.format(self.defense_upgrade))marine_1 = Marine('100', '100',0,0)marine_1.show_status()기본적인 내용에 대해서는 알아봤으니 이번에는 간단한 시나리오를 가지고 클래스를 디자인해보도록 하겠습니다.Marine, Medic, DropShip 3 종류의 Unit을 사용할 것이고 4명의 Marine을 생성하고 2명의 Medic, 1개의 DropShip을 생성한 후 DropShip에 6명을 태워서 특정 지점에 공격하러 가는 내용으로class를 정의하고 실행해보도록 하겠습니다.# 간단한 예제class Unit(object):    def __init__(self, damage, life):        self.utype = self.__class__.__name__        self.damage = damage        self.life = life            def show_status(self):        print('직업: {}'.format(self.utype))        print('공격력: {}'.format(self.damage))        print('생명력: {}'.format(self.life))    def attack(self):        pass                class Marine(Unit):    def __init__(self, damage, life, offense_upgrade, defense_upgrade):        super(Marine, self).__init__(damage, life)        self.offense_upgrade = offense_upgrade        self.defense_upgrade = defense_upgrade            def show_status(self):        super(Marine, self).show_status()        print('공격력 업그레이드: {}'.format(self.offense_upgrade))        print('방어력 업그레이드: {}'.format(self.defense_upgrade))    def attack(self):        print('마린이 공격합니다. 땅땅!!')    def stimpack(self):        if self.life &gt; 20:            self.damage = self.damage * 1.5            self.life = self.life - 10            print('마린이 Stimpack을 사용합니다. 칙!!')            else:            print('체력이 낮아 Stimpack을 사용할 수 없습니다.')    class Medic(Unit):    def __init__(self, damage, life, defense_upgrade):        super(Medic, self).__init__(damage, life)        self.defense_upgrade = defense_upgrade    def show_status(self):        super(Medic, self).show_status()        print('방어력 업그레이드: {}'.format(self.defense_upgrade))    def attack(self):        print('메딕이 치료합니다. 힐힐!!')class DropShip(Unit):    def __init__(self, damage, life, defense_upgrade):        super(DropShip, self).__init__(damage, life)        self.defense_upgrade = defense_upgrade        self.unit_arr = []    def show_status(self):        super(DropShip, self).show_status()        print('방어력 업그레이드: {}'.format(self.defense_upgrade))    def attack(self):        print('목표지점으로 이동합니다. 쓩!!')    def board(self,unit_arr):        self.unit_arr = unit_arr        print('부대를 태웠습니다.')    def drop(self):        print('모든 Unit이 DropShip에서 내립니다.')        return self.unit_arr    # Marine 생성marine_1 = Marine(10,100,0,0)marine_2 = Marine(10,100,0,0)marine_3 = Marine(10,100,0,0)marine_4 = Marine(10,100,0,0)# Medic 생성medic_1 = Medic(0,100,0)medic_2 = Medic(0,100,0)# 병력을 list안에 모은다.troop = list()troop.append(marine_1)troop.append(marine_2)troop.append(marine_3)troop.append(marine_4)troop.append(medic_1)troop.append(medic_2)# DropShip 생성dropship = DropShip(0,50,0)# DropShip에 부대원을 태운다.dropship.board(troop)# 공격지점으로 이동dropship.attack()# 공격지점에서 부대원들 내리기troop = dropship.drop()# 부대원들 공격for unit in troop:    if isinstance(unit,Marine):        unit.stimpack()    unit.attack()End.Python 강좌는 아래의 책과 사이트를 참조했습니다.    조금 더 자세한 사항을 알고 싶으시면 해당 사이트를 방문하세요!!    Python Official HomePage    점프 투 파이썬 - 이지스 퍼블리싱    전문가를 위한 파이썬(Fluent Python) - 한빛미디어    파이썬 웹 프로그래밍 - 한빛미디어    이미지 출처 : Designed by rawpixel.com / Freepik",
        "url": "/python-lecture-python-OOP"
    }
    ,
    
    "python-lecture-python-program-exercise-1": {
        "title": "Python 기초강좌(5) - Python 연습문제(1)",
            "author": "moon9342",
            "category": "",
            "content": "Python 기초강의는 여러 절로 구성되어 있습니다.     Python 기초강의(1) - Introduction    Python 기초강의(2) - Python 기본    Python 기초강의(3) - Python 제어문    Python 기초강의(4) - Python function    Python 기초강의(5) - Python 연습문제(1)    Python 기초강의(6) - Python 객체지향    Python 기초강의(7) - Python Magic Function    Python 기초강의(8) - Python First Class    Python 기초강의(9) - Python Closure    Python 기초강의(10) - Python Decorator    Python 기초강의(11) - Python Generator    Python 기초강의(12) - Python Module    Python 기초강의(13) - Python Exception &amp; File    Python 기초강의(14) - Python 연습문제(2)    Python Django 웹 프레임워크(1) - introduction    Python Django 웹 프레임워크(2) - Poll project 개발(1)    Python Django 웹 프레임워크(3) - Poll project 개발(2)    Python Django 웹 프레임워크(4) - Poll project 개발(3)    Python Django 웹 프레임워크(5) - Poll project 개발(4)    Python Django 웹 프레임워크(6) - Poll project 개발(5)    Python Django 웹 프레임워크(7) - Django의 개발방식    Python Django 웹 프레임워크(8) - Blog project 개발    Python program 연습문제지금까지 Python 언어의 기본적인 사항들에 대해서 살펴보았습니다. 그럼 간단하게 몇몇개의프로그래밍 문제를 해결하고 넘어가도록 하죠. 이 문제들을 꼭 작성해야 다음으로 넘어갈 수 있는건당연히 아닙니다. 하지만 IT 쪽에서의 가장 기본적인 능력인 문제해결능력을 갖추기위해서라도 Coding 훈련은 꾸준히 해 주는게 좋습니다.Python program 연습문제 - 1## 문제 1.## 10보다 작은 자연수 중에서 3 또는 5의 배수는## 3,5,6,9가 존재해요! 이것들의 합은 23입니다.## 1000보다 작은 자연수 중에서 3 또는 5의 배수들을## 구해서 모두 합하면 얼마인가요?## 정답 : 233168Python program 연습문제 - 2## 문제 2.## 피보나치 수열의 각 항은 바로 앞의 항 두 개를 더한 것이 됩니다. ## 1과 2로 시작하는 경우 이 수열은 아래와 같습니다.## 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...## 짝수이면서 4백만 이하인 모든 항을 더하면 얼마가 됩니까?## 정답 : 4613732Python program 연습문제 - 3## 문제 3.## 알파벳 대소문자로 된 문자열이 주어지면, ## 이 문자열에서 가장 많이 사용된 알파벳이 ## 무엇인지 출력하는 프로그램을 작성하시오. ## 단, 대소문자는 구별하지 않아요. 만약 동률이 존재하는 경우 ## 알파벳 순으로 제일 앞에 있는## 문자를 출력하세요.## 문자열) \"This is a sample Program mississippi river\"## 문자열) \"abcdabcdababccddcd\"## 정답 :  \"This is a sample Program mississippi river\" =&gt; I## 정답 :  \"abcdabcdababccddcd\" =&gt; CPython program 연습문제 - 4## 문제 4.## 로또 프로그램 작성 ## 5000원으로 로또복권을 5장 자동으로 구매합니다. ## 이번 주 로또 당첨번호를 생성하여 로또 당첨을 확인하세요!## 쉬운버전으로 먼저 작성합니다.  ## 6숫자가 다 맞으면 1등, 5개 맞으면 2등으로 처리합니다.## 즉, 쉬운버전은 보너스 숫자는 없는 것으로 간주합니다.## 쉬운버전을 해결했다면 ## 보너스 숫자를 이용하여 로또 당첨을 확인합니다.## 보너스 숫자를 제외한 모든 숫자가 다 맞으면 1등,## 보너스 숫자를 포함하여 6개의 숫자가 맞으면 2등,## 보너스를 제외하고 5개의 숫자가 맞으면 3등으로 처리합니다.## 쉬운버전의 출력은 1등 몇개, 2등 몇개, 3등 몇개, ## 4등 몇개, 꽝 몇개로 출력## 어려운버전의 출력은 1등 몇개, 2등 몇개, 3등 몇개, ## 4등 몇개, 5등 몇개, 꽝 몇개로 출력## 랜덤값을 도출하기 위해서는 다음의 코드를 이용한다.import random i = random.randint(1, 100)  # 1부터 100 사이의 임의의 정수 f = random.random()   # 0부터 1 사이의 임의의 floati = random.randrange(1, 101, 2) # 1부터 100 사이의 임의의 짝수i = random.randrange(10)  # 0부터 9 사이의 임의의 정수##### 추가문제##### 1등에 당첨될려면 평균적으로 얼마만큼의 돈을 투자해야 할까요?##### 로또 1게임은 1000원입니다.Python program 연습문제 - 5## 문제 5.## 어떤 수를 소수의 곱으로만 나타내는 것을 소인수분해라 하고, ## 이 소수들을 그 수의 소인수라고 합니다.## 예를 들면 13195의 소인수는 5, 7, 13, 29 입니다.## 600851475143의 소인수 중에서 가장 큰 수를 구하세요.## 정답 : 6857 Python program 연습문제 - 6## 문제 6.## 앞에서부터 읽을 때나 뒤에서부터 읽을 때나 모양이 ## 같은 수를 대칭수(palindrome)라고 부릅니다.## 두 자리 수를 곱해 만들 수 있는 대칭수 중 ## 가장 큰 수는 9009 (= 91 × 99) 입니다.## 세 자리 수를 곱해 만들 수 있는 가장 큰 대칭수를 구하세요## 정답 : 906609Python program 연습문제 - 7## 문제 7.## 1 ~ 10 사이의 어떤 수로도 나누어 떨어지는 가장 작은 수는 2520입니다.   ## 그러면 1 ~ 20 사이의 어떤 수로도 나누어 떨어지는 가장 작은 수는 얼마입니까?## 정답 : 232792560Python program 연습문제 - 8## 문제 8.## 1부터 10까지 자연수를 각각 제곱해 더하면 다음과 같습니다 (제곱의 합).## 1**2 + 2**2 + ... + 10**2 = 385## 1부터 10을 먼저 더한 다음에 그 결과를 제곱하면 다음과 같습니다 (합의 제곱).## (1 + 2 + ... + 10)**2 = 552 = 3025## 따라서 1부터 10까지 자연수에 대해 \"합의 제곱\"과 \"제곱의 합\" 의 ## 차이는 3025 - 385 = 2640 이 됩니다.## 그러면 1부터 100까지 자연수에 대해 \"합의 제곱\"과 \"제곱의 합\"의 차이는 ## 얼마입니까?## 정답 : 25164150Python program 연습문제 - 9## 문제 9.## 소수를 크기 순으로 나열하면 2, 3, 5, 7, 11, 13, ... 과 같이 됩니다.## 이 때 10,001번째의 소수를 구하세요.## 정답 : 104743Python program 연습문제 - 10## 문제 10.## 세 자연수 a, b, c 가 피타고라스 정리 a**2 + b**2 = c**2 를 만족하면 ## 피타고라스 수라고 부릅니다 (여기서 a &lt; b &lt; c ).## 예를 들면 3**2 + 4**2 = 9 + 16 = 25 = 5**2이므로 ## 3, 4, 5는 피타고라스 수입니다.## a + b + c = 1000 인 피타고라스 수 a, b, c는 한 가지 뿐입니다. ## 이 때, a × b × c 는 얼마입니까?## 정답 : 31875000Python program 연습문제 - 11## 문제 11.## 양의 정수 n에 대하여, 다음과 같은 계산 과정을 반복하기로 합니다.## n → n / 2 (n이 짝수일 때)## n → 3 * n + 1 (n이 홀수일 때)## 13에 대하여 위의 규칙을 적용해보면 아래처럼 10번의 과정을 통해 1이 됩니다.## 13 → 40 → 20 → 10 → 5 → 16 → 8 → 4 → 2 → 1## 아직 증명은 되지 않았지만, 이런 과정을 거치면 어떤 수로 시작해도 ## 마지막에는 1로 끝나리라 생각됩니다. ## (이런 수들을 우박수 hailstone sequence라 합니다.)## 그러면, 백만(1,000,000) 이하의 수로 시작했을 때 1까지 도달하는데 ## 가장 긴 과정을 거치는 숫자는 얼마입니까?## 계산 과정 도중에는 숫자가 백만을 넘어가도 괜찮습니다.## 정답 : Python program 연습문제 - 12## 문제 12.## 다음과 같은 특성을 갖는 숫자의 개수를 찾는 기능을 구현합니다.## 입력으로 두개의 숫자( x, y )를 이용합니다. ## - 두 개의 숫자 x와 y를 이용하여,##   x초과 y미만의 숫자 중 각 자리의 숫자를 모두 더한 값이 5의 배수가 ##   되는 숫자를 찾습니다.## - 숫자들을 모두 찾은 후 해당 숫자가 총 몇 개인지를 출력합니다.## 예1) 두 개의 숫자 1과 100이 주어졌을 경우,##      1초과 100미만의 숫자 중 각 자리의 숫자를 모두 더한 값이 5의 배수가 ##      되는 숫자를 찾습니다.##      - 20의 경우 각 자리 숫자를 모두 더한 값이 2이므로, 적합하지 않다.##      - 23의 경우 각 자리 숫자를 모두 더한 값이 5이므로, 적합하다.##      [총 개수] 19## 예2) 두 개의 숫자 5와 500이 주어졌을 경우,##      5초과 500미만의 숫자 중 각 자리의 숫자를 모두 더한 값이 5의 배수가 ##      되는 숫자를 찾습니다.##      [총 개수] 98## 입력으로 주어지는 두 개의 수 : 100 10000## 정답 : 예제의 결과가 출력되도록 코드 작성 Python program 연습문제 - 13## 문제 13.## 6자리 이상 9자리 미만의 수를 입력으로 사용합니다.## 수의 중앙을 기준으로 두 개의 수로 분리한 후 큰 수를 선택한다.## - 수의 숫자개수가 홀수 개인 경우 수의 중앙 숫자를 기준으로 ##   왼쪽과 오른쪽 수로 분리## - 수의 숫자개수가 짝수 개인 경우 수를 반으로 나누어 ##   왼쪽과 오른쪽 수로 분리## 예1) 1234567 -&gt; (123, 567) -&gt; (567)## 예2) 34217869 -&gt; (3421, 7869) -&gt;(7869)## 입력으로 제공된 수를 더 이상 두 개의 수로 분리할 수 없을 때까지 ## 과정을 반복하여 남은 최종 숫자를 구해 출력한다.## 예1) 567 -&gt; (5, 7) -&gt; (7)## 예2) 7869 -&gt; (78, 69) -&gt; (78) -&gt; (7, 8) -&gt; (8)## 정답 : 예제의 결과가 출력되도록 코드 작성Python program 연습문제 - 14## 문제 14.## 2**15 = 32768 의 각 자리수를 더하면 3 + 2 + 7 + 6 + 8 = 26 입니다.## 2**1000의 각 자리수를 모두 더하면 얼마입니까?## 정답 : 1366Python program 연습문제 - 15## 문제 15.## 각 부품의 생산정보가 문자열로 제공된다.## [부품생산정보] : A7B5C4A1A8B9B3A5A8B9B1C7C1A1B3C7B9B3A7B8A1C9A8   ## 각 부품정보는 부품명과 품질데이터로 구성된다. ## - A,B,C 3개의 부품이 있으며 품질은 1이상 10미만의 정수.##   예) A7 : A부품, 품질 7   ## 생산정보에서 품질이 7이상인 부품만을 순서대로 선택한다.## [생산정보] A7B5C4A1A8B9B3A5A8B9B1C7C1A1B3C7B9B3A7B8A1C9A8## [품질이 7이상인 부품 목록] A7A8B9A8B9C7C7B9A7B8C9A8   ## 품질이 7이상인 부품들을 조립해 완성품을 만든다.## A, B, C 세 부품이 순서대로 있을 때만 부품을 조립한다.## A7A8B9A8B9C7C7B9A7B8C9A8 =&gt; A8B9C7, A7B8C9 2개 조립## 조립한 부품의 목록과 전체 조립한 개수를 출력## 정답 : 예제의 결과가 출력되도록 코드 작성Python program 연습문제 - 16## 문제 16.## n! 이라는 표기법은 n × (n − 1) × ... × 3 × 2 × 1을 뜻합니다.## 예를 들자면 10! = 10 × 9 × ... × 3 × 2 × 1 = 3628800 이 되는데,## 여기서 10!의 각 자리수를 더해 보면 3 + 6 + 2 + 8 + 8 + 0 + 0 = 27 입니다.## 100! 의 자리수를 모두 더하면 얼마입니까?## 정답 : Python program 연습문제 - 17## 문제 17.## 최소 10개 이상 최대 20개 이하의 숫자로 구성된 숫자목록이 배열 혹은 리스트 형태로 제공된다. ## 숫자목록 : 1,3,4,5,7,9,2,3,4,7## 아래의 순서로 숫자목록의 숫자를 교환하여 재배치한다.## 1) 숫자목록의 앞에서부터 4개의 숫자를 선택한다.##    목록에서 숫자 선택 : [1,3,4,5],7,9,2,3,4,7## 2) 선택된 4개의 숫자의 합을 구한다.##    4개의 숫자 합 : [1,3,4,5],7,9,2,3,4,7 =&gt; 13## 3) 첫 번째와 두 번째 숫자를 교환하고 세 번째와 네 번째 숫자를 교환한다.##    숫자 교환 : [3,1,5,4],7,9,2,3,4,7## 4) 오른쪽으로 한칸씩 이동하여 순서대로 1,2,3번 과정을 반복해 숫자목록의 숫자를 재배치한다.## 예) [1,3,4,5],7,9,2,3,4,7 =&gt; ##     [3,1,5,4],7,9,2,3,4,7 =&gt;##     3,[1,5,4,7],9,2,3,4,7 -&gt; …## 숫자목록의 끝까지 숫자배치를 진행할 때 선택되는 4개의 수의 최대 합을 출력## [초기 입력 데이터]## 1 3 4 5 7 9 2 3 4 7 ## --------------------------------------------------------------- ## [선택된 4개의 수의 최대 합]: 21## [초기 입력 데이터]## 10 15 3 5 9 5 7 8 9 15 44 54 15 67 32 25 48 98 44 56 ## ---------------------------------------------------------------## [선택된 4개의 수의 최대 합]: 159## 정답 : 예제의 결과가 출력되도록 코드 작성Python program 연습문제 - 18## 문제 18.## 어떤 대상을 순서에 따라 배열한 것을 순열이라고 합니다. ## 예를 들어 3124는 숫자 1, 2, 3, 4로 만들 수 있는 순열 중 하나입니다.   ## 이렇게 만들 수 있는 모든 순열을 숫자나 문자 순으로 늘어놓은 것을 ## 사전식(lexicographic) 순서라고 합니다.## 0, 1, 2로 만들 수 있는 사전식 순열은 다음과 같습니다. ## 012   021   102   120   201   210## 0, 1, 2, 3, 4, 5, 6, 7, 8, 9로 만들 수 있는 사전식 순열에서 ## 1,000,000번째는 무엇입니까?정답 : Python program 연습문제 - 19## 문제 19.## 입력으로 제공되는 숫자열에서 짝수와 홀수를 추출하여 새로운 숫자열을 생성한다.## 1) 입력된 숫자열에서 짝수와 홀수를 순서대로 추출한다.##    [입력] 78235169##    [짝수 추출] 826##    [홀수 추출] 73519## 2) 추출된 짝수의 뒤에 추출된 홀수를 연결하여 새로운 숫자열을 생성한다.##    [짝수와 홀수 연결] 82673519## 결과숫자열을 앞에서부터 순서대로 뺄셈 연산 또는 덧셈 연산 한다.## 숫자열의 앞에서 부터 순서대로 뺄셈 연산한다. ## 단, 앞선 연산 결과가 0 이하이면 그 차례에는 덧셈 연산한다. ## [결과 숫자열] 82673519## [각 수의 연산 순서와 방법]##   8 - 2 = 6##   6 – 6 = 0##   0 + 7 = 7 (앞의 연산 결과가 0 이하이므로 덧셈 연산한다.)##   7 – 3 = 4##   4 – 5 = -1##  -1 + 1 = 0 (앞의 연산 결과가 0 이하이므로 덧셈 연산한다.)##   0 + 9 = 9 (앞의 연산 결과가 0 이하이므로 덧셈 연산한다.)## [연산 결과] 9## [입력]: 78235169## [출력]: 9## [입력]: 693756874## [출력]: 7## 정답 : 예제의 결과가 출력되도록 코드 작성End.Python 강좌는 아래의 책과 사이트를 참조했습니다.    조금 더 자세한 사항을 알고 싶으시면 해당 사이트를 방문하세요!!    Python Official HomePage    점프 투 파이썬 - 이지스 퍼블리싱    전문가를 위한 파이썬(Fluent Python) - 한빛미디어    파이썬 웹 프로그래밍 - 한빛미디어    이미지 출처 : Designed by rawpixel.com / Freepik",
        "url": "/python-lecture-python-program-exercise-1"
    }
    ,
    
    "python-lecture-python-function": {
        "title": "Python 기초강의(4) - Python function",
            "author": "moon9342",
            "category": "",
            "content": "Python 기초강의는 여러 절로 구성되어 있습니다.     Python 기초강의(1) - Introduction    Python 기초강의(2) - Python 기본    Python 기초강의(3) - Python 제어문    Python 기초강의(4) - Python function    Python 기초강의(5) - Python 연습문제(1)    Python 기초강의(6) - Python 객체지향    Python 기초강의(7) - Python Magic Function    Python 기초강의(8) - Python First Class    Python 기초강의(9) - Python Closure    Python 기초강의(10) - Python Decorator    Python 기초강의(11) - Python Generator    Python 기초강의(12) - Python Module    Python 기초강의(13) - Python Exception &amp; File    Python 기초강의(14) - Python 연습문제(2)    Python Django 웹 프레임워크(1) - introduction    Python Django 웹 프레임워크(2) - Poll project 개발(1)    Python Django 웹 프레임워크(3) - Poll project 개발(2)    Python Django 웹 프레임워크(4) - Poll project 개발(3)    Python Django 웹 프레임워크(5) - Poll project 개발(4)    Python Django 웹 프레임워크(6) - Poll project 개발(5)    Python Django 웹 프레임워크(7) - Django의 개발방식    Python Django 웹 프레임워크(8) - Blog project 개발    영상설명이번 영상은 Python 언어의 function 영상입니다.Python functionPython 사용자 정의 함수Python 내장 함수Python lambda  Python 기초강의 - Python 함수Python functionpython 함수의 body에는 최소한 한 개 이상의 문장이 필요합니다. 만약 내용이 없는 함수를 만들 경우 pass keyword를 사용해야 합니다.함수명은 가독성을 높이기 위해 필요에 따라 밑줄로 구분 된 단어와 함께 소문자를 이용하는것을 원칙으로 합니다.Python의 함수는 내장함수와 사용자 정의 함수로 구분할 수 있습니다.Python 사용자 정의 함수먼저 user define 함수를 정의하고 사용하는 몇가지 예를 살펴보도록 하겠습니다.사용자 정의 함수함수를 정의할때는 def 키워드를 이용해서 함수를 정의합니다. 함수의 인자를명시할 때는 당연히 데이터 타입을 명시하지 않습니다. Python은 하나의 함수가 다양한 데이터 타입의 입력인자를 받아서 처리할 수 있도록 유연하게 설계되어 있습니다.# python user define functiondef my_sum(a, b, c):    return a + b + cresult = my_sum(1, 2, 3.0)print(\"result의 값은 : {0}\".format(result))다수의 인자 전달함수로 전달되는 인자의 수가 가변적일 때 tuple형태로 인자를전달할 수 있습니다.def my_sum(*args):          # tuple형태로 전달    result = 0    for i in range(len(args)):        result += i    return resultprint(\"결과값은 : {0}\".format(my_sum(1, 2, 3, 4, 5, 6)))여러개의 리턴값 사용Python은 함수의 리턴값을 여러 개 사용할 수 있습니다. 정확히 말하자면,여러개의 값을 tuple로 만들어서 리턴하는 형태로 함수의 리턴값은 사실 한 개 입니다.def multi_return(a, b):    result1 = a + b    result2 = a * b    return result1, result2data1 = multi_return(10, 20)print(type(data1))print(data1)data1, data2 = multi_return(10, 20)print(\"두수의 합 : {0}, 두수의 곱 : {1}\".format(data1, data2))default parameter의 사용함수의 입력 인자에 기본값을 지정할 수 있습니다. 입력 인자에 명시적인값이 전달되지 않았을 경우 기본값으로 지정된 값을 사용한다는 의미이고당연히 맨 마지막 인자에만 기본값을 지정할 수 있습니다.def default_param(a, b, c=True):    data = a + b    if data &gt; 10 and c:        return data    else:        return 0result1 = default_param(10, 20)result2 = default_param(30, 40, False)mutable vs immutable함수의 입력인자가 list, dict 등인 경우 mutable 특징을 가집니다. 즉, 함수내에서해당 인자의 내용을 변경하면 원래 데이터인 list, dict의 내용이 변경됩니다. 이런 특징을mutable이라고 합니다.반대로 숫자, 문자열, tuple 등은 immutable 특징을 가집니다. 함수내에서해당 인자의 내용을 변경하여도 원래의 데이터에는 변형이 이루어지지 않음을 의미합니다. 이런 특징을 immutable이라고 합니다.# mutable vs. immutable# call-by-value &amp; call-by-referencedef my_func(tmp_number, tmp_list):    tmp_number = tmp_number + 100    tmp_list.append(100)data_x = 10data_list = [10]my_func(data_x,data_list)print(\"data_x의 값은 : {}\".format(data_x))print(\"data_list의 값은 : {}\".format(data_list))local variable vs global variable# local variable vs global variabletmp = 100def my_func(x):    global tmp     # tmp를 global scope에서 찾는다.    tmp += x       # 만약 tmp를 global로 선언하지 않았다면                   # local variable ( 초기화 x -&gt; error )    return tmpprint(my_func(100))print(tmp)Python 내장 함수Python은 상당히 많은 내장 함수를 제공합니다. 이를 통해 데이터 처리를 간편하게 할 수 있습니다. 간단한 연산부터 데이터 타입의 변환같은 처리를쉽게 할 수 있습니다.기본적인 내장 함수는 알아 두어야 할 필요가 있습니다.  기본 내장 함수      abs(x) : 절대값을 return    all(x) : 반복 가능한 자료형 x에 대해 x가 모두 참이면 True, 그렇지 않으면 False    any(x) : 반복 가능한 자료형 x에 대해 x중 하나라도 참이면 True, 그렇지 않으면 False    eval(expression) : 실행 가능한 문자열을 입력 받아서 문자열을 실행한 결과값을 return    int(x) : 입력값을 정수형태로 return    len(x) : 입력값 x의 길이를 return    list(x) : 반복 가능한 자료형 x를 입력 받아 list로 만들어서 return    str(x) : 문자열 형태로 변환하여 return    tuple(x) : 반복 가능한 자료형을 입력받아 tuple로 바꾸어 return    type(x) : 입력값의 데이터 타입을 return  # python built-in functions# python의 내장함수# dir() : 사용가능한 변수와 함수를 리스트 형태로 returnprint(dir({\"key\" : 100}))   # dictionary에서 사용가능한 변수와 함수print(dir([]))              # list에서 사용가능한 변수와 함수# divmod(a,b) : a를 b로 나눈 몫과 나머지를 tuple로 반환print(divmod(8,3))# enumerate() : 순서가 있는 자료형을 입력으로 받아#               index값을 포함하는 enumerate 객체 returnresult = enumerate([\"Show\",\"me\", \"the\", \"money\"])myList = list(result)myList[0]for idx,item in enumerate([\"Show\",\"me\", \"the\", \"money\"]):    print(idx, item)    # id() : 객체의 고유 주소값(reference) returna = 100print(id(a))# join() : 일반적으로 리스트를 특정 구분자를 포함하여 #          문자열로 변환할 때 많이 사용animal = [\"멍멍이\",\"사자\",\"호랑이\",\"개\"]print(\",\".join(animal))print(\"-\".join(animal))# map() : 특정함수에 입력값을 주어 반복 호출def my_func(x):    return x**2a = list(map(my_func,range(1,10)))print(a)# max(), min() : 최대값, 최소값 returnprint(max([7,4,9,2,3,1]))print(max(\"This is a sample Text\"))# pow(x,y) : x를 y 제곱한 결과 returnprint(pow(2,4))# sorted() : 입력값을 정렬한 후 그 결과를 list로 리턴# sorted()는 기본 내장함수로 정렬된 list를 return하는 반면# list의 sort() 함수는 list를 정렬하고 결과를 return하지 않음a = [4,7,9,2,3,6]result = a.sort()print(result)   # Noneprint(a)        # 정렬되어 있음a = [4,7,9,2,3,6]result = sorted(a)print(result)   # 정렬된 결과print(a)        # 원본은 변함 없음.# zip() : 동일한 개수로 이루어진 자료형을 묶어 주는 역할#         일반적으로 list나 tuple형태로 변환해서 사용a = [1,2,3]b = [\"a\",\"b\",\"c\"]c = list(zip(a,b))print(c)str=list(zip(\"Hello\",\"World\"))print(str)str=list(zip(\"Hello1234\",\"World\"))print(str)Python lambdalambda(람다)는 한 줄로 함수를 정의하는 방법입니다. 단, 함수의 이름이 명시되지 않기 때문에 anonymous function이라고도 합니다.함수명이 없기 때문에 일반적으로 람다식(lambda expression)은 변수에 할당되어서사용됩니다. 이런 특징을 first class라고 하는데 이는 뒤쪽 강의에서 다시 설명하도록하겠습니다.lambda는 입력 값을 대체 표현식으로 대체해주는 역할을 합니다. 따라서 일반적인 함수와는약간 다릅니다.사용하는 형식은 다음과 같습니다.  변수 = lambda 입력변수1, 입력변수2, … : 대체 표현식# labmda# lambda의 모든 입력인자를 다 이용하는 # 대체식을 사용하지 않아도 된다.f = lambda x1,x2,x3 : x1 + x2    # x3은 대체식에서 사용되지 않았다.# 일반적인 함수의 형태로 인식하면 # 다음과 같이 사용해야 될 것이라고 생각하기 쉽다.# f = lambda x1,x2,x3 : return (x1 + x2)# 하지만 표현식이 대체되는 개념이기 때문에 # return 구문을 사용하면 안된다.print(f(10,20,30))End.Python 강좌는 아래의 책과 사이트를 참조했습니다.    조금 더 자세한 사항을 알고 싶으시면 해당 사이트를 방문하세요!!    Python Official HomePage    점프 투 파이썬 - 이지스 퍼블리싱    전문가를 위한 파이썬(Fluent Python) - 한빛미디어    파이썬 웹 프로그래밍 - 한빛미디어    이미지 출처 : Designed by rawpixel.com / Freepik",
        "url": "/python-lecture-python-function"
    }
    ,
    
    "python-lecture-python-control-statement": {
        "title": "Python 기초강의(3) - Python 제어문",
            "author": "moon9342",
            "category": "",
            "content": "Python 기초강의는 여러 절로 구성되어 있습니다.     Python 기초강의(1) - Introduction    Python 기초강의(2) - Python 기본    Python 기초강의(3) - Python 제어문    Python 기초강의(4) - Python function    Python 기초강의(5) - Python 연습문제(1)    Python 기초강의(6) - Python 객체지향    Python 기초강의(7) - Python Magic Function    Python 기초강의(8) - Python First Class    Python 기초강의(9) - Python Closure    Python 기초강의(10) - Python Decorator    Python 기초강의(11) - Python Generator    Python 기초강의(12) - Python Module    Python 기초강의(13) - Python Exception &amp; File    Python 기초강의(14) - Python 연습문제(2)    Python Django 웹 프레임워크(1) - introduction    Python Django 웹 프레임워크(2) - Poll project 개발(1)    Python Django 웹 프레임워크(3) - Poll project 개발(2)    Python Django 웹 프레임워크(4) - Poll project 개발(3)    Python Django 웹 프레임워크(5) - Poll project 개발(4)    Python Django 웹 프레임워크(6) - Poll project 개발(5)    Python Django 웹 프레임워크(7) - Django의 개발방식    Python Django 웹 프레임워크(8) - Blog project 개발    영상설명이번 영상은 Python 언어의 control statement 영상입니다.Python Control Statement - ifPython Control Statement – forPython Control Statement - while  Python 기초강의 - Python 제어문Python Control Statement - ifPython의 조건문은 두가지 방식으로 사용이 가능합니다. 첫번째는 전통적인 if ~ elif ~ else 형태이고 다른 하나는 in 구문을 사용하는 형태입니다.또한 코드 block을 표현하기 위해서 다른 언어처럼 { }를 이용하지 않고들여쓰기(indentation)를 이용합니다.다음의 예제를 통해서 알아보도록 하겠습니다.# python control statement ifa = 20if a % 3 == 0:    print(\"{}은(는) 3의 배수입니다.\".format(a))elif a % 5 == 0:    print(\"{}은(는) 5의 배수입니다.\".format(a))else:    print(\"{}은(는) 3과 5의 배수가 아닙니다.\".format(a))  아래의 코드는 in 연산자를 이용하는 경우입니다.# python control statement ifarea = [\"서울\", \"부산\", \"제주\"]region = \"수원\"if region in area:    passelse:    print(\"{} 지역은 포함되지 않습니다.\".format(region))   mydict = { \"서울\" : 100, \"광주\" : 200 }region = \"부산\"if region in mydict:    print(\"키 값이 dict안에 있습니다.\")   else:    print(\"키 값이 dict안에 없습니다.\")    Python Control Statement – forPython의 for구문은 두가지 방식으로 사용이 가능합니다.for ~ in range() 형태와 for ~ in dict,list 형태입니다.# python control statement formySum = 0for tmp in range(1,10,2):    mySum += tmp    print(\"현재 tmp값은 {}이고 현재 누적값은 {}입니다.\".format(tmp,mySum))print(\"총 누적값은 {}입니다.\".format(mySum))    아래의 예제는 for ~ in dict,list 형태입니다.# python control statement formyList = [1, 2, 3, 4, 5]mySum = 0for tmp in myList:    mySum += tmpprint(\"리스트의 합은 : {0}\".format(mySum))####################################myList = [(1, 2), (3, 4), (5, 6)]mySum = 0for (tmp1, tmp2) in myList:    mySum += (tmp1 + tmp2)print(\"리스트의 합은 : {0}\".format(mySum))####################################myDict = { \"홍길동\" : 24, \"신사임당\" : 21 }for (key,value) in myDict.items():    print(\"Key : {} , Value : {}\".format(key,value))####################################score = [100, 50, 80, 90, 70, 60]mySum = 0for i in range(len(score)):    mySum += score[i]print(\"score의 합은 %d\" % mySum)추가적으로,리스트의 [...] 괄호 안에 for 구문을 통한 반복적인 표현식을 이용해서리스트의 요소들을 정의할 수 있는데 이를 List Comprehension이라고 합니다.아래의 예제처럼 사용됩니다.# List ComprehensionmyList = [1, 2, 3, 4, 5, 6, 7, 8, 9]score1 = [tmp * 2 for tmp in myList]score2 = [tmp * 2 for tmp in myList if tmp % 2 == 0]print(\"score1 리스트 : {0}\".format(score1))print(\"score2 리스트 : {0}\".format(score2))# dictionay에도 사용가능my_dict = {\"stu\" + str(x): x ** 2 for x in range(1, 10)}print(\"my_dict : {0}\".format(my_dict))Python Control Statement - whilePython의 while 구문은 다른 언어의 while 사용과 유사합니다.단, Python은 do~while 구문이 존재하지 않는다는 점만 기억하시면 될 듯 합니다.# python control statement whileidx = 0mySum = 0while idx &lt; 10:    mySum += idx    idx += 1print(\"0~9까지의 합은 : {}\".format(mySum))End.Python 강좌는 아래의 책과 사이트를 참조했습니다.    조금 더 자세한 사항을 알고 싶으시면 해당 사이트를 방문하세요!!    Python Official HomePage    점프 투 파이썬 - 이지스 퍼블리싱    전문가를 위한 파이썬(Fluent Python) - 한빛미디어    파이썬 웹 프로그래밍 - 한빛미디어    이미지 출처 : Designed by rawpixel.com / Freepik",
        "url": "/python-lecture-python-control-statement"
    }
    ,
    
    "python-lecture-python-basic": {
        "title": "Python 기초강의(2) - Python 기본",
            "author": "moon9342",
            "category": "",
            "content": "Python 기초강의는 여러 절로 구성되어 있습니다.     Python 기초강의(1) - Introduction    Python 기초강의(2) - Python 기본    Python 기초강의(3) - Python 제어문    Python 기초강의(4) - Python function    Python 기초강의(5) - Python 연습문제(1)    Python 기초강의(6) - Python 객체지향    Python 기초강의(7) - Python Magic Function    Python 기초강의(8) - Python First Class    Python 기초강의(9) - Python Closure    Python 기초강의(10) - Python Decorator    Python 기초강의(11) - Python Generator    Python 기초강의(12) - Python Module    Python 기초강의(13) - Python Exception &amp; File    Python 기초강의(14) - Python 연습문제(2)    Python Django 웹 프레임워크(1) - introduction    Python Django 웹 프레임워크(2) - Poll project 개발(1)    Python Django 웹 프레임워크(3) - Poll project 개발(2)    Python Django 웹 프레임워크(4) - Poll project 개발(3)    Python Django 웹 프레임워크(5) - Poll project 개발(4)    Python Django 웹 프레임워크(6) - Poll project 개발(5)    Python Django 웹 프레임워크(7) - Django의 개발방식    Python Django 웹 프레임워크(8) - Blog project 개발    영상설명이번 영상은 Python 언어의 Built-in Types에 대한 영상입니다.Python Data Type(Numeric)Python Data Type(Sequence)Python Data Type(Text Sequence Type)Python Data Type(Mapping Type)Python Data Type(Set Type)Python Data Type(Bool Type)Python Data Type(date, timedelta)  Python 기초강의 - Python built-in typesjupyter notebook 단축키jupyter notebook을 PyCharm이 아닌 Web Application으로 사용할 때 마우스로 메뉴를 이용해도 되지만 단축키를 이용하는게훨씬 편합니다. 아래내용은 기억해두면 사용하기 편한 단축키에 대한 설명입니다.Shift-Enter : run cell, select belowCtrl-Enter : run cellAlt-Enter : run cell, insert belowA : insert cell aboveB : insert cell belowX : cut selected cellC : copy selected cellV : paste cell belowShift-V : paste cell aboveD, D : delete selected cellZ : undo last cell deletionL : toggle line numberO : toggle outputPython 주석, keyword, 변수생성  한줄 주석은 # 으로 처리합니다. 여러줄 주석은 \"\"\"   \"\"\" 를 이용합니다.(혹은 '''  ''')# Python 주석# 한줄 주석은 # 으로 처리# 여러줄 주석은 \"\"\" \"\"\" 이용( 혹은 ''' ''' )\"\"\"이부분은 주석처리됩니다.!!여러줄 주석처리할 경우 사용되며 따옴표(single quotation mark)를사용해도 됩니다.\"\"\"# keyword module loadingimport keywordprint(keyword.kwlist)# 변수의 생성과 삭제a = 100print(\"생성된 a의 값은 : \", a)del aprint(\"삭제된 a의 값은 : \", a)['False', 'None', 'True', 'and', 'as', 'assert', 'break', 'class',  'continue', 'def', 'del', 'elif', 'else', 'except', 'finally', 'for',  'from', 'global', 'if', 'import', 'in', 'is', 'lambda', 'nonlocal',  'not', 'or', 'pass', 'raise', 'return', 'try', 'while', 'with', 'yield']생성된 a의 값은 :  100---------------------------------------------------------------------------NameError                                 Traceback (most recent call last)&lt;ipython-input-1-9ac0e81add16&gt; in &lt;module&gt;()     25 print(\"생성된 a의 값은 : \", a)     26 del a---&gt; 27 print(\"삭제된 a의 값은 : \", a)NameError: name 'a' is not definedPython Data Type(Built-in Types)Python의 data type은 다음과 같습니다.  Python Built-in Types      Numeric    Sequence    Text Sequence    Mapping    Set    Bool  각각의 데이터 타입에 대해서 하나하나 알아보도록 하겠습니다.Python Data Type(Numeric)# python numeric type# Numeric Type (숫자형)# int (정수)# float (실수)# complex (복소수)a = 123           # 정수b = 3.141592      # 실수 c = 3.14E10       # 실수 (지수형태)d = 1 + 2j        # 복소수e = 0o34          # 8진수f = 0xAB          # 16진수print(type(a))    # &lt;class 'int'&gt;print(type(b))    # &lt;class 'float'&gt;print(type(c))    # &lt;class 'float'&gt;print(type(d))    # &lt;class 'complex'&gt;print(type(e))    # &lt;class 'int'&gt;print(type(f))    # &lt;class 'int'&gt;div = 3 / 4       # 나누셈의 결과는?print(div)        # 0.75result = 3 ** 3   # 지수표현print(result)     # 27result = 10 % 3   # 나머지 연산print(result)     # 1result = 10 // 3  # 나눗셈 몫print(result)     # 3Python Data Type(Sequence)listPython의 Sequence Type - list에 대해서 코드로 알아보겠습니다.# python sequence type - list# list# 임의의 객체를 순서대로 저장하는 집합 자료형# Java의 ArrayList와 유사 ( index 부여 및 값 변경 가능 )# 대괄호 ( [ ] )를 이용하여 표시# range()를 이용하여 리스트 생성 가능a = list()a = []a = [1,2,3]a = [1,2,\"Hello\",3.14]a = [1,2,[\"Show\",\"me\", \"the\", \"money!!\"],3.14]print(a)          # [1, 2, ['Show', 'me', 'the', 'money!!'], 3.14]print(a[0]);      # 1print(a[-1])      # 3.14print(a[2][0])    # Showprint(a[0:2])     # [1, 2]print(a[2][2:])   # ['the', 'money!!']a = [1,2,3]b = [4,5,6]print(a + b)      # [1, 2, 3, 4, 5, 6] a = [1,2,3]print( a * 3 )    # [1, 2, 3, 1, 2, 3, 1, 2, 3]print(str(a[0]) + \"Hello\") # a[0] + \"Hello\" =&gt; Errora = [1,2,3]a[0] = 5          # [5, 2, 3]a[0:1] = [7,8,9]  # [7, 8, 9, 2, 3]a[1] = [\"Hello\", \"World\"]  # [7, ['Hello', 'World'], 9, 2, 3]a[1:3] = []   # [7, 2, 3]del a[0]      # [2, 3]print(a)a = [1,2,3]a.append(4)          # [1, 2, 3, 4]a.append([5,6,7])    # [1, 2, 3, 4, [5, 6, 7]]#a = [7,3,1,8,2]#a = [\"Hello\",\"World\",\"kaka\",\"hoho\"]a = [\"홍길동\",\"최길동\",\"이순신\",\"강감찬\",\"박효신\",\"아이유\"]result = a.sort()   print(result)       # Noneprint(a)            # ['강감찬', '박효신', '아이유', '이순신', '최길동', '홍길동'] result = a.reverse()  print(result)       # Noneprint(a)            # ['홍길동', '최길동', '이순신', '아이유', '박효신', '강감찬']a = [7,3,1,8,2]print(a.index(1))   # 1의 위치 반환 (2)a = [1,2,3]a.insert(0,-1)print(a)            # [-1, 1, 2, 3]a = [1,2,3,1,2,1,2,3]a.remove(3)   # 첫번째로 나오는 3 제거 =&gt; [1, 2, 1, 2, 1, 2, 3]a = [1,2,3,4]print(a.pop())   # 마지막 index위치의 값을 pop                 # 4print(a)         # [1, 2, 3]a = [1,2,3,4]print(a.pop(1))  # index위치의 값을 pop                 # 2print(a)         # [1, 3, 4]a = [1,2,3,1,2,1,2,3]print(a.count(1))    # 1의 개수 counting =&gt; 3a = [1,2,3]a.extend([4,5,6])print(a)            # [1, 2, 3, 4, 5, 6]############################################# is 연산자와 == 연산자# is 연산자는 reference를 비교하는 연산자이고# == 연산자는 value를 비교하는 연산자# 변수의 reference(메모리 주소에 대한 int값)를 얻기위한# 함수 =&gt; id()a = 100;      print(id(a))    # 1759493440b = 100;print(id(b))    # 1759493440c = 256         print(id(c))    # 1759498432d = 256print(id(d))    # 1759498432e = 257         # 257 이상이면 다른 주소에 할당                # console에서는 정상실행                # pyCharm에서는 같은 주소가 할당(왜?)                print(id(e))    # 1134539404368f = 257print(id(f))    # 1134539405008# 다른 데이터 타입은 매번 실행 시 다른 메모리 할당list_1 = [1,2,3]list_2 = [1,2,3]print(id(list_1), id(list_2))    # 1134539686024 1134540817352# 두 개의 list 비교a = [1,2,3]b = a;print(a is b) # True              # a와 b가 같은 객체 referenceb = a[:]      # 리스트 전체 복사의 의미print(a is b) # False              # a와 b가 서로 다른 객체 referencefrom copy import copyb = copy(a)  # 리스트 복사print(a is b)  # FalsetuplePython의 Sequence Type - tuple에 대해서 코드로 알아보겠습니다.# python sequence type - tuplea = ()b = (1,)     # 요소가 1개인 Tuple 표현             # type(b) =&gt; &lt;class 'tuple'&gt;c = (1)      # type(c) =&gt; &lt;class 'int'&gt;d = (1,2,3)  # 일반적인 형태e = 1,2,3    # () 생략가능a,b,c = (10,20,30) # tuple의 각 값을 변수에 대입f = (1,2,(3,4),5,(6,7,8))print(f[0])    # indexingprint(f[1:3])  # slicing =&gt; (2, (3, 4))a = (1,2,3)b = (4,5,6)print(a + b)   # (1, 2, 3, 4, 5, 6)a = (1,2,3)print(a * 3)   # (1, 2, 3, 1, 2, 3, 1, 2, 3)# tuple과 list의 변환my_list = [1,2,3]my_tuple = tuple(my_list)print(my_tuple)   # (1, 2, 3)my_tuple = 10,20,30my_list = list(my_tuple)print(my_list)   # [10, 20, 30]rangePython의 Sequence Type - range에 대해서 코드로 알아보겠습니다.# python sequence type - range# range는 숫자 sequence로 주로 for문에서 사용# range의 장점은 표현하는 범위에 무관하게 항상# 같은(작은)양의 메모리를 사용range_1 = range(10)print(range_1)    # range(0, 10)range_2 = range(1,11,2)print(range_2)    # range(1, 11, 2)print(7 in range_2)    # Trueprint(10 in range_2)   # Falseprint(range_2.index(7)) # 7이 처음나오는 index  =&gt; 3print(range_2[2])       # 5print(range_2[2:])      # range(5, 11, 2)print(range_2[-1])      # 9Python Data Type(Text Sequence Type)Python의 Text Sequence Type - str에 대해서 코드로 알아보겠습니다.# python text sequence type - str# 문자열 생성방법 (4가지)a = \"Hello\"b = 'python'c = \"\"\"this is amultilinesample text\"\"\"d = '''이것은소리없는아우성'''print(d)# 문자열 연산 , Indexing, Slicingfirst = \"this is a\"middle = ' sample'last = \"\"\" text\"\"\"print(first + middle + last)  # this is a sample texttext = \"Python\"print(text * 3)  # PythonPythonPythona = \"Talk is cheap. Show me the code\"print(a[3]);  # kprint(a[-1])  # eprint(a[0:4]);  # Talkprint(a[:20])  # Talk is cheap. Showprint(a[5:]);  # is cheap. Show me the codeprint(a[:])  # Talk is cheap. Show me the code# in, not in 연산myStr = \"This is a sample Text\"print(\"sample\" in myStr)  # Trueprint(\"text\" not in myStr)  # Trueprint(\"this\" in myStr)  # Falseprint(\"this\" in myStr.lower())  # True# 문자열 formattinga = \"I have %d apples.\" % 3b = \"I have %s apples.\" % \"five\"num = 10c = \"I have %d apples.\" % numd = \"I have %d apples and %s bananas\" % (3, \"three\")e = \"Error Rate is %d%%.\" % 80f = \"I have %10s apples.\" % \"five\"g = \"I have %-10s apples.\" % \"five\"h = \"%0.4f\" % 3.141592i = \"%10.4f\" % 3.141592  # 전체 자리수 10자리,# 오른쪽 정렬,# 소수점 이하 4자리(반올림)# 문자열 함수a = \"cocacola\"result = len(a)  # 문자열 길이 =&gt; 8result = a.count(\"c\")  # 문자 개수 count =&gt; 3result = a.find(\"o\")  # 문자가 처음나온 위치, 없으면 -1 =&gt; 1result = a.index(\"a\")  # 문자가 처음나온 위치, 없으면 Error =&gt; 3a = \"::\"b = \"abcd\"result = a.join(b)print(result)  # a::b::c::da = \" hoBBy \"result = a.upper()result = a.lower()result = a.strip()print(result)a = \"Show me the Code\"result = a.replace(\"Code\", \"Money\")print(result)        # Show me the Moneya = \"Show me the Code\"result = a.split()print(result)  # ['Show', 'me', 'the', 'Code']a = \"a:b:c:d:e\"result = a.split(\":\")print(result)  # ['a', 'b', 'c', 'd', 'e']a = \"I have {0} apples\".format(3)a = \"I have {0} apples and {1} bananas\".format(3, \"three\")a = \"I have {num1} apples and {num2} bananas\".format(num1=5, num2=\"two\")a = \"{0:0.4f}\".format(3.141592)print(a)  # 3.1416# 천 단위 comma 출력num = 1234567899print(\"{0:,}\".format(num))# 백분율 출력 ( 반올림 처리 )num = 0.87657print(\"{0:.0%}\".format(num))print(\"{0:.2%}\".format(num))                        Python Data Type(Mapping Type)Python의 Mapping Type - dict에 대해서 코드로 알아보겠습니다.# python mapping type - dict# dictionary는 key와 value의 대응관계 type# Associative array 혹은 Hash와 유사한 구조# {} 기호로 표현a = { \"name\" : \"홍길동\", \"age\" : 30 }print(type(a))   # &lt;class 'dict'&gt;a[10] = \"KK\"a[\"Hobby\"] = \"Game\"print(a)   # {'name': '홍길동', 'age': 30, 10: 'KK', 'Hobby': 'Game'}del a[10]  # key값이 10인 쌍을 삭제print(a)   # {'name': '홍길동', 'age': 30, 'Hobby': 'Game'}print(a[\"name\"])   # 홍길동a = { \"name\" : \"홍길동\", \"age\" : 30, \"age\" : 40 }# key가 중복되면 1개를 제외한 나머지 무시.# key에 list는 올 수 없지만 tuple은 올 수 있다.a = { \"name\" : \"홍길동\", \"age\" : 30, (\"address\",) : \"서울\" }print(a[('address',)])     # 서울a = { \"name\" : \"홍길동\", \"age\" : 30, \"address\" : \"서울\" }print(a.keys())   # a.keys() =&gt; dict_keys 객체 리턴                  # dict_keys(['name', 'age', 'address'])                  # list와 유사하지만 list 함수 사용 불가                  # list로 변환 =&gt; list(a.keys()) print(a.values())   # a.values() =&gt; dict_values 객체 리턴                    # dict_values(['홍길동', 30, '서울'])print(a.items())    # key와 value의 쌍을 tuple로 묶은                     # dict_items 객체 리턴                    # dict_items([('name', '홍길동'), ('age', 30), ('address', '서울')])for key in a.keys():    #print(key + \", \" + a[key]) =&gt; Type Error    print(\"{0}, {1}\".format(key,a[key]))print(a.get(\"address\"))          # 만약 찾지 못하면 None 리턴                                 # 서울print(a.get(\"address!!\",\"지역\")) # 만약 찾지 못하면 default 리턴print(\"name\" in a)  # key가 딕셔너리에 있는지 조사                    # Truea.clear()               # Key:Value쌍 모두 삭제print(a)                # {}Python Data Type(Set Type)Python의 Set Type - set에 대해서 코드로 알아보겠습니다.# python Set Type - set# Set 특징# 중복이 없고, 순서가 없다.a = {1,2,3}              # set 생성a = set([1,2,3,1,2,3])   # set 생성 =&gt; {1, 2, 3}print(type(a))           # &lt;class 'set'&gt;print(a)                 # {1, 2, 3}a = set(\"Hello\")print(a)           # {'o', 'e', 'l', 'H'}s1 = set([1,2,3,4,5])s2 = set([3,4,5,6,7])print(s1 &amp; s2)             # intersectionprint(s1.intersection(s2)) # {3, 4, 5}print(s1 | s2)             # unionprint(s1.union(s2))        # {1, 2, 3, 4, 5, 6, 7} print(s1 - s2)             # differenceprint(s1.difference(s2))   # {1, 2}s1 = set([1,2,3,4,5])s1.add(7)                  # set에 요소 추가print(s1)                  # {1, 2, 3, 4, 5, 7}s1.update([1,2,9,6,8])     # set에 값 여러개 추가(list이용)print(s1)                  # {1, 2, 3, 4, 5, 6, 7, 8, 9}s1.update({10,11,12})      # set에 값 여러개 추가(set이용)print(s1)                  # {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12}s1.remove(1)               # set에서 특정값 삭제print(s1)                  # {2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12}Python Data Type(Bool Type)Python의 Bool Type - bool은 다음과 같은 특징을 가집니다.  True , False  not, and, or 연산자 사용  python에서 and, or ,not은 논리 연산(True,False 연산)  python에서 &amp;, |, ~은 비교 연산(bitwise 연산)  다음의 경우 False로 간주      빈 문자열 (\"\")    빈 리스트 ( [] )    빈 튜플 ( () )    빈 딕셔너리 ( {} )    숫자 0 ( 0 이외의 다른 숫자는 True )    None  # python Bool Type - boola = 5b = 0print(a &amp; b)       # bitwise 연산 0101 &amp; 0000 =&gt; 0000  =&gt; 0print(bool(a &amp; b)) # 0은 bool로 전환시 False           =&gt; Falseprint(a | b)       # bitwise 연산 0101 | 0000 =&gt; 0101  =&gt; 5print(bool(a | b)) # 0이외의 숫자는 bool로 전환시 True  =&gt; Truea = Trueb = Falseprint(int(a))    # True는 정수 전환시 1print(int(b))    # False는 정수 전환시 0print(a &amp; b)     # Falseprint(a | b)     # Trueprint(a and b)   # Falseprint(a or b)    # Trueprint(not a)     # FalsePython Data Type(date, timedelta)# python date type# 날짜from datetime import date, datetimetoday = date.today()print(type(today))      # &lt;class 'datetime.date'&gt;print(today)print(\"연도 : {0}, 월 : {1}, 일 : {2}\".format(today.year,today.month, today.day))# 날짜 및 시간my_datetime = datetime.today()print(my_datetime)print(\"현재 시 : {0}\".format(my_datetime.hour))print(\"현재 분 : {0}\".format(my_datetime.minute))print(\"현재 초 : {0}\".format(my_datetime.second))print(\"현재 마이크로초 : {0}\".format(my_datetime.microsecond))# pip install python-dateutilfrom datetime import date, datetime, timedeltafrom dateutil.relativedelta import relativedeltatoday = date.today()days = timedelta(days=-1)   # 일을 기준으로 하루 전print(\"하루 전 날짜 : {}\".format(today + days))# weeks, days, hours, minutes, seconds 사용가능# years와 months는 timedelta로 사용할 수 없다.# days = timedelta(years=-2)   # 월을 기준으로 2개월 전 ( error )# years와 months는 relativedelta 사용 ( 2019-03-31의 1달전은 2019-02-28 )days = relativedelta(months=-2)print(\"두달 전 날짜 : {}\".format(today + days))## 특정 날짜 객체를 생성from dateutil.parser import parsemyDay = parse(\"2019-01-01\")print(\"parse()로 얻어온 날짜 : {}\".format(myDay))myDay = datetime(2019,1,1)print(\"datetime()로 얻어온 날짜 : {}\".format(myDay))# 날짜 출력 형식from datetime import datetimetoday = datetime.today()# strftime( 날짜를 문자열형태로 포맷 지정 )print(\"{0}\".format(today.strftime(\"%m-%d-%y\"))) # year : 19print(\"{0}\".format(today.strftime(\"%m-%d-%Y\"))) # year : 2019# 문자열을 날짜 형식으로 변환 ( strptime )str = \"2019,01,03-13:30:29\"my_date = datetime.strptime(str, \"%Y,%m,%d-%H:%M:%S\")print(type(my_date))print(my_date)Python Console 입출력# python console IO# console입력을 받기 위해서는 input()을 이용input_val = input(\"숫자를 입력하세요!!\")print(type(input_val))  # input으로 입력받은 값은 str# eval() : 입력받은 문자열을 숫자연산처리print(eval(\"1+3*5\"))   # 16print(type(eval(input_val)))Python print() 함수# python print function# print() 함수print(\"Hello\" + \"World\") # + 연산자는 문자열 연결print(\"Hello\" \"World\")   # + 연산자가 없어도 문자열 연결print(\"Hello\",\"World\")   # , 를 이용하면 공백추가하여 문자열 연결# 기본적으로 print()는 한줄 출력한 후 line feed (줄바꿈)# end=\"\" 를 이용하여 출력 후 처리를 지정할 수 있다.for tmp in range(1,10):    print(tmp, end=\" \")  # 개행 =&gt; 공백으로 변환End.Python 강좌는 아래의 책과 사이트를 참조했습니다.    조금 더 자세한 사항을 알고 싶으시면 해당 사이트를 방문하세요!!    Python Official HomePage    점프 투 파이썬 - 이지스 퍼블리싱    전문가를 위한 파이썬(Fluent Python) - 한빛미디어    파이썬 웹 프로그래밍 - 한빛미디어    이미지 출처 : Designed by rawpixel.com / Freepik",
        "url": "/python-lecture-python-basic"
    }
    ,
    
    "python-lecture-python-introduction": {
        "title": "Python 기초강의(1) - Introduction",
            "author": "moon9342",
            "category": "",
            "content": "Python 기초강의는 여러 절로 구성되어 있습니다.     Python 기초강의(1) - Introduction    Python 기초강의(2) - Python 기본    Python 기초강의(3) - Python 제어문    Python 기초강의(4) - Python function    Python 기초강의(5) - Python 연습문제(1)    Python 기초강의(6) - Python 객체지향    Python 기초강의(7) - Python Magic Function    Python 기초강의(8) - Python First Class    Python 기초강의(9) - Python Closure    Python 기초강의(10) - Python Decorator    Python 기초강의(11) - Python Generator    Python 기초강의(12) - Python Module    Python 기초강의(13) - Python Exception &amp; File    Python 기초강의(14) - Python 연습문제(2)    Python Django 웹 프레임워크(1) - introduction    Python Django 웹 프레임워크(2) - Poll project 개발(1)    Python Django 웹 프레임워크(3) - Poll project 개발(2)    Python Django 웹 프레임워크(4) - Poll project 개발(3)    Python Django 웹 프레임워크(5) - Poll project 개발(4)    Python Django 웹 프레임워크(6) - Poll project 개발(5)    Python Django 웹 프레임워크(7) - Django의 개발방식    Python Django 웹 프레임워크(8) - Blog project 개발    영상설명이번 영상은 Python 언어의 개요 및 개발환경설정에 대한 영상입니다.Python 개요Python 개발환경 설정(일반적인 Python 개발환경)Python 개발환경 설정(Anaconda를 이용한 Jupyter Notebook 개발환경)Why Python  Python 기초강의 - Python 소개 및 환경설정Python 개요Python은 1990년 귀도 반 로섬에 의해 개발된 프로그래밍 언어입니다. 과거에는 프로그래밍 교육위주로 사용이 되었지만 현재는 데이터 분석, 머신러닝 위주의 실무에서 점점 더 많이 사용하는 추세입니다.  Python의 특징      shallow learning curve : 문법이 쉬워 빠르게 배우고 활용할 수 있습니다. 특히 기존 프로그래밍언어를 다루었던 개발자들은 더욱 더 쉽게  Python을 배울 수 있습니다.    무료/간결/강력 : 시스템 프로그래밍을 제외한 대부분의 프로그래밍을 할 수 있습니다.빠른 수행속도가 필요한 경우 필요한 부분만 C 언어로 제작해서 Python안에 포함시켜 사용할 수 있습니다.    가독성 높은 코드 : Python은 indentation이 강제되므로 가독성 높은 코드를 생산할 수 있습니다.다른언어에서처럼 block을 표현할 때 사용하는 중괄호({ })를 사용하지 않습니다. 대신 indentation(들여쓰기)를이용해 블럭을 표현합니다.    다양한 분야의 프로그래밍 : Python은 Web Programming, Database Programming, Data Analysis Programming 등에 폭넓게 이용할 수 있지만 System Programming과 Mobile App Programming에는 적합하지 않습니다. Mobile App 같은 경우 별도의 package를 이용하면APK파일을 생성할 수 있지만 굳이 python으로 Android App을 개발할 필요는 없어보입니다.  Python 개발환경 설정(일반적인 Python 개발환경)일반적인 Python 개발환경부터 알아보겠습니다.먼저 Python Official Homepage에 접속해 다운로드 페이지에서 Python을 다운로드 합니다. 현재 버전은 3.8.2버전이지만 차후에 TensorFlow 2.0을 사용하기 위해서 Python 3.7.4버전을다운로드 합니다.(이글을 쓰는 시점 기준으로 TensorFlow 2.0은 Python 3.8을 지원하지 않습니다.)또한 언어 특성상 Python 2.7버전과 3.x버전은 차이가 있습니다. 다운로드가 끝나면 기본 형태로 설치를 진행합니다. PATH 추가하는 부분은 포함시켜 설치를 진행해야 사용하기 편합니다.이제 사용할 IDE(Integrated Development Environment)를 설치합니다. 일반적으로 PyCharm을 많이 이용합니다. Community edition과 Professional edition이 있습니다. Professional edition은 30일 trial version으로 사용할 수 있습니다. 그 이후에는 비용을 지불해야 합니다.물론 지우고 다시 깔아서 쓰는 방법도 있습니다. 기능면으로는 당연히 Professional Edition이 좋기 때문에그리고 추후에 Jupyter Notebook을 PyCharm에서 사용할 수 있도록 Professional Edition을 사용합니다.JetBrains사이트로 접속한 후 PyCharm을 다운로드 받습니다.다운로드가 완료되면 기본형태로 설치합니다. 설치가 끝나면 프로젝트를 생성할 수 있는 화면이 나오게 됩니다.Python 개발환경 설정(Anaconda를 이용한 Jupyter Notebook 개발환경)Data Analysis를 위해서 Python을 학습하고 사용할때는 Jupyter Notebook 또는 Google CoLab을많이 이용합니다. 먼저 Anaconda를 이용해 Jupyter Notebook을 PC에 설치해서 사용하는 법에 대해 알아보고 추후에 Google CoLab에 대해서도알아보도록 하겠습니다.참고로 Anaconda는 Continuum Analytics에서 개발한 Python Data Science Platform 중 가장유명한 Platform입니다. 가상환경 생성 및 데이터 분석에 필요한 여러 라이브러리들을 편하게 설치, 사용할 수 있는 환경을 제공합니다.또한 Jupyter Notebook은 Python, R 파일을 작성하고 실행하는 개발환경을 제공하는 Web Application입니다. Cell이라는 단위로 코드를 나누어 실행 할 수 있기 때문에 Interactive한 개발이 가능하다는 것이 가장 큰 장점입니다.  Anaconda 환경설정      Anaconda 다운로드 및 설치    Anaconda는 무료로 사용가능하며 python과 다수의 유용한 package를 제공하고 있습니다.    Anaconda 설치 후, Anaconda Prompt를 관리자 권한으로 실행한 후 pip를 최신 버전으로 upgrade 합니다.    python -m pip install --upgrade pip    conda 가상 환경을 생성합니다.    conda create  -n data_env python=3.7 openssl    가상환경으로 전환하기 위해서 다음의 코드를 실행    activate data_env    jupyter notebook에서는 여러 버전의 python과 여러 개의 conda 가상환경을 구동할 수 있습니다. 하지만 기본 설정으로는 실행되지 않고 nb_conda를 설치해야 Jupyter Notebook이 설치됩니다.    conda install nb_conda    jupyter notebook 설정 파일을 생성하기 위해 Anaconda prompt에서 jupyter notebook --generate-config 실행생성된 설정파일을 수정하여 실습에서 사용할 폴더를 C:/jupyter_notebook로 설정한 후 해당 폴더를 생성합니다.    실행결과 : Writing default config to: C:/Users/shmoon/.jupyter/jupyter_notebook_config.py    해당파일의 261라인을 다음과 같이 수정하고 해당 라인의 주석을 해제합니다.(폴더는 수동으로 생성해야 합니다.)    c.NotebookApp.notebook_dir = 'C:/jupyter_notebook'    notebook 실행 ( jupyter notebook )  가상환경 listing 및 삭제는 다음과 같이 수행합니다. 단, 삭제시 폴더는 수동으로 모두 삭제해야 합니다.conda info --envsconda remove --name data_env --allJupyter Notebook은 정말 편하게 Machine Learning 개발을 진행할 수 있도록 도와주지만Web Application이라는 한계때문에 기존 개발 IDE에서 기본으로 제공되는 Assist와 같은기능을 원할하게 사용하지 못한다는 단점이 있습니다. Assist가 안되는건 아닌데 사용하기가 많이불편합니다.이 문제는 PyCharm을 이용하면 해결할 수 있습니다. PyCharm에서 Jupyter Notebook 파일을 생성해서사용할 수 있고 사용하는 Kernel을 Anaconda에서 설치한 Jupyter Notebook의 Kernel을 이용할 수 있습니다.Anaconda Prompt에서 Jupyter Notebook을 실행시키면 token 키가 포함된 URL을 제공해 주는데 이를 PyCharm의 환경설정에넣어주면 쉽게 PyCharm에서 Jupyter Notebook Kernel을 연동할 수 있습니다.단, 이 기능은 PyCharm Community Edition은 제공하지 않고 Professional Edition만 제공합니다.Why Pythonpython의 장점을 다시 한번 정리해보죠.  상대적으로 쉬운 언어  interactive programming이 가능  강력한 데이터 분석 Library가 많음  Open Source ( 무료 )  R에 비해 범용적 사용이 가능  현재 가장 인기있는 언어  주의) 하위호환성 없음 (python 2.x vs. python 3.x)End.Python 강좌는 아래의 책과 사이트를 참조했습니다.    조금 더 자세한 사항을 알고 싶으시면 해당 사이트를 방문하세요!!    Python Official HomePage    점프 투 파이썬 - 이지스 퍼블리싱    전문가를 위한 파이썬(Fluent Python) - 한빛미디어    파이썬 웹 프로그래밍 - 한빛미디어    이미지 출처 : Designed by rawpixel.com / Freepik",
        "url": "/python-lecture-python-introduction"
    }
    ,
    
    "arduino": {
        "title": "Arduino",
            "author": "moon9342",
            "category": "",
            "content": " Arduino 개요아두이노(Arduino)는 이탈리아에서 개발한 오픈소스 보드로 이탈리아어로 강한 친구라는 뜻을 가지고 있습니다.  아두이노는 우리가 흔히 얘기하는 컴퓨터가 아닙니다. 라즈베리파이와는 다르게 아두이노는 우리가 사용하는 컴퓨터처럼 OS를 설치하고 응용프로그램을 설치하는 등의 일을 할 수 없습니다. 참고로 라즈베리파이는 OS설치와 여러 응용프로그램 설치가 가능한 싱글보드 컴퓨터입니다. 우리과정에서는라즈베리파이대신에 라떼판다(Latte panda)를 이용할 예정입니다. 라떼판다는 아두이노 레오나르도 칩이 코프로세서로 설치되어 있습니다.아두이노는 Micro-Controller 입니다. 즉, 코드를 돌리는 단순한 기계입니다.아마도 아두이노란 용어는 많이 들어봤을텐데 이런 아두이노가 왜 이렇게 각광을 받고 있을까요? 그 이유는 사물인터넷(IoT, Internet of things)과 맞물려 있기 때문입니다.사물인터넷(IoT)은 일반적인 물건처럼 보이지만 1)통신장비를 결합하고 2)고도화된 통신기술을 이용하여 3)특별한 작업을 수행하는 장비를 지칭합니다.간단한 예를 들자면 사용자의 음성을 인식하는 스피커라든지, 거울에 그날의 날씨나 뉴스와 같은 내용을 띄워주는 스마트 미러와 같은 것이 있습니다.이러한 사물인터넷을 구현하기 위해 그 안에 들어가는 Controller는 다음과 같은 특징을 가져야 합니다.  가격이 저렴해야 한다.  프로그램 실행코드를 기판에 주입(upload)하는 과정이 간편해야 한다.  센서의 사용이 간편해야 한다.Arduino는 이러한 특징을 가지고 있는 Micro Controller입니다.아두이노는 제품의 이름이 아니라 브랜드명입니다. 아두이노라는 브랜드 안에 여러개의 모델이 존재하고 있습니다. 마치 갤럭시라는 브랜드안에 S9,S10,S20와같은 모델이 있는것처럼 말이죠. 아두이노의 가장 대표적인 모델(가장 기본적인 모델)은 Uno 입니다.굉장히 많은 아두이노 모델(버전)들이 있고 각 버전들은 나름대로의 특징을 가지고 있습니다. 아주 작은 크기로 소형화된 버전, 크기가 크지만 상대적으로 고사양인 버전, wifi기능에 특화된 버전같은여러 버전들이 있습니다.일반적으로 많이 사용하는 버전은 다음과 같은 3가지라고 볼 수 있습니다.  Arduino Uno : 가장 일반적인 모델  Arduino Mega ADK : 크기가 크지만 꽤나 복잡한 연산을 수행.  Arduino Pro Mini : 크기가 작아 저전력으로 사용가능.아두이노에 대해서 또 알아두어야 할 점은 오픈소스 하드웨어란 점입니다.즉, 설계와 활용법이 모두 대중적으로 공개되어 있습니다. 따라서 아두이노 호환보드라고 불리는유사제품들이 굉장히 많이 존재합니다. 하지만 정품제품과 이런 호환제품간에 성능이나 기타 능력면에서 차이는 거의 없다고 보면 됩니다. (가격차이는 좀 있습니다.) 전류,전압,저항아두이노를 사용하기 위해서는 기본적인 전기에 대한 지식이 필요합니다.전기는 전압과 전류로 설명할 수 있는데 전압은 물의 수압과 같은 개념으로 두 점 사이의 전기적인 전위 차이를 의미합니다.이 전위차에 의해서 전압이 높은 곳에서 낮으곳으로 전자가 흐르게 됩니다.건전지의 경우 플러스(+)가 높은 전압, 마이너스(-)가 낮은 전압입니다.아두이노 보드 부분에 POWER라고 적힌 부분 밑에 3V3, 5V라고 적힌 전원 헤더소켓이 있습니다. 각각 전압이 3.3V, 5V라는 것을 의미하고 이렇게 전압이 표시된 곳이 건전지의 +부분과 같고 전기가 흘러나오는 곳이라고 생각하면 됩니다.헤더소켓은 핀을 꼽을 수 있는 소켓을 의미하며 점퍼와이어를 연결할 수 있습니다.점퍼와이어의 수컷은 핀으로 암컷은 구멍으로 되어 있습니다.전원 헤더 소켓의 오른쪽에 GND라고 적힌 헤더 소켓이 2개 있습니다. 그리고 DIGITAL이라고 적힌 곳에도 GND 헤더 소켓이 존재합니다.이 GND는 그라운드라는 의미로 전압이 0V인 곳을 의미합니다. 즉, 건전지의마이너스(-)부분과 같고 전기가 빠져나가는 배수로 개념이라고 생각하면 됩니다.전자부품을 연결할 때 전자제품의 플러스 부분을 3V3, 5V 헤더소켓에 연결하고 마이너스 부분을 GND 헤더 소켓에 연결하면 됩니다. 아두이노는 일반적으로 5V를 이용합니다.전류는 전위가 높은 곳에서 낮은곳으로 전하가 연속적으로 이동하는 형상을 의미합니다. 물로 비유하면 수압이 높은곳에서 낮은곳으로 물이 흐르며 이 물의 흐름에 의해서 물레방아가 돌아가게 됩니다. 전자의 흐름을 전류라고 하고 이 전류에 의해서 전자기기가 동작하게 됩니다.저항은 물체가 전류의 흐름을 제어하는 것을 의미하며 저항이 높은 물체일수록 전류가 적게 흐르고 저항이 낮은 물체일수록 전류가 많이 흐르게됩니다. 수도꼭지를 생각하시면 됩니다.물리학의 기본법칙 중 하나로 옴의 법칙이라는 것이 있습니다. 전압, 전류, 저항사이의 관계를 나타내는 법칙으로 전류의 세기는전압에 비례하고 저항에 반비례한다는 공식입니다. 기본공식이기 때문에 잘 알아두어야 합니다.  전압은 기호로는 V(Voltage)를 이용하고 단위는 V(볼트)를 이용한다.  전류는 기호로는 I(Intensity)를 이용하고 단위는 A(암페어)를 이용한다.  저항은 기호로는 R(Resistance)을 이용하고 단위는 옴을 이용한다.전류(I) = 전압(V) / 저항(R) Sensor(센서), Actuator(액추에이터), 기타아두이노는 센서를 이용하여 주위환경에 대한 정보를 수집할 수 있습니다. 밝기 센서, 거리 센서등여러 종류의 센서를 이용하여 아두이노는 데이터를 수집할 수 있습니다. 또한 아두이노가어떤 활동을 할 수 있도록 만들어주는 전자부품이 있을 수 있는데 이를 액추에이터라고 합니다. 모터, LED 같은 것들이 대표적인 액추에이터입니다.저항은 전기를 열로 바꾸어주는 전자부품입니다. 저항에는 4개 혹은 그 이상의 띠가 표시되어 있는데이 띠의 색이 저항값을 의미합니다. 당연히 저항이 높을 수록 더 많은 전기를 열로 바꾸게 됩니다. 각 저항이 가지는 값은 저항에 둘려져있는 띠의 색상으로 알 수 있습니다. 교재를 이용해서 각 저항의 값을 알아내는 방법을 알아둘 필요도 있어보입니다.또는 저항 제품들마다 해당 저항은 몇 옴인지를 표시해 놓고 있는 경우도 있습니다.다이오드는 전류가 한 방향으로만 흐를 수 있도록 해주는 전자부품입니다. 즉, 전류의 역류를 방지하는반도체 소자입니다. 띠가 있는 부분이 -를 의미하고 띠가 없는 부분이 +를 의미하는데 전기는 띠가 없는 부분에서 있는부분으로만 흘러갈 수 있습니다. 즉, 양극(+)에서 음극(-)의 방향으로 전류를 흐르게 합니다.우리가 회로도를 구성한다고 가정했을 때 그 안에 저항도 넣고, 센서도 넣고, 모터도 넣어서 구성할 수 있습니다. 이렇게 회로를 다 구성한 후 회로에 전원을 반대로 연결하면 어떻게 될까요?센서는 고장날테고, 모터는 반대로 돌게되며 스파크나 화재까지 발생할 수 있습니다. 즉, 안전을 위해 다이오드를 사용해야 합니다. 모터와 같은 전자부품을 사용하는 경우 다이오드가 필수적으로 들어가야 합니다. 모터가 회전하고 있는 동안에 모터안의 코일에 에너지가 축적됩니다. 그러다가 모터가 OFF된다면 전원은 끊기지만코일에 에너지가 남아있는 상태가 되며 모터는 에너지를 방출하려 합니다. 이때 높은 전압을 가진역방향의 기전력이 발생하게 되고 아두이노 보드나 센서등이 파괴될 수 있습니다. 이를 막기위해서다이오드를 이용하여 역방향으로 오는 기전력을 차단하여 다른 제품을 안전하게 보호해야 합니다.다이오드는 안전을 위해서 꼭 사용해 주어야 하며 특히 모터와 같은 코일을 사용하는 회로에서는반드시 사용해야 하는 부품입니다.브레드보드(일명 빵판)은 전자부품을 쉽게 연결할 수 있도록 도와줍니다. 브레드보드안에 가로와 세로방향에 따라 철심이 박혀있기 때문에 전자부품을 연결할 수 있습니다. 아래의 브레드보드에서 가로로 파진 홈(notch)인 중앙선의 위아래에 위치한 수직방향의 단자띠(terminal strip)와 수평방향의 버스띠(bus strip)로 구성됩니다. 단자띠는 부품들간의 연결을 위한것이고 버스띠는 전원공급을위한 것입니다.(적색선이 +이고, 청색선이 -입니다.) 디지털과 아날로그아두이노를 제어하는 방법은 크게 디지털과 아날로그 두가지가 있습니다.아두이노 보드에서 점퍼 와이어 핀을 꼽을 수 있는 부분을 헤더소켓 이라고 하는데 그냥 짧게 핀(pin)이라고부르기도 합니다. 아두이노에서 디지털 신호를 제어할 수 있는 핀을 디지털 핀이라고 부릅니다.아두이노 UNO의 경우 DIGITAL이라고 표시된 곳에 숫자 0부터 13까지 적혀있는 핀들을 볼 수 있습니다.이 핀들이 바로 디지털 핀입니다. 그리고 이 디지털 핀을 통해서 디지털 신호를 제어할 수 있습니다.즉, 디지털 핀에 전기를 연결하거나 끊어줄 수 있다는 말입니다. 이렇게 전기를 연결하거나 끊는 방식이 디지털 출력입니다. 반면 디지털 입력은 디지털 핀으로부터 전기가 들어오는지 들어오지 않는지를 체크하는 것입니다. 디지털 핀의 0과 1번은 컴퓨터와 통신을 담당하는 부분이기 때문에일반적으로 사용하지 않고 나머지 번호의 핀을 이용합니다.디지털 핀을 이용할때는 디지털 핀을 입력 용도로 쓸 것인지 출력 용도로 쓸 것인지를 설정해야 합니다.이때 사용하는 함수 pinMode() 함수로 사용방법은 다음과 같습니다.// 13번 핀을 입력으로 설정합니다.// INPUT은 0을 가지는 상수값입니다.pinMode(13,INPUT);// 13번 핀을 출력으로 설정합니다.// OUTPUT은 1을 가지는 상수값입니다.pinMode(13,OUTPUT);디지털 핀을 설정한 후 디지털 신호를 출력할 수 있습니다. 디지털 신호를 출력하는 함수는 digitalWrite() 함수로 다음과 같이 사용한다.// 13번 핀에 디지털 신호를 내보내지 않는다.// LOW : 0digitalWrite(13,LOW);// 13번 핀에 디지털 신호를 내보낸다.// HIGH : 1digitalWrite(13,HIGH);HIGH로 설정하면 전압이 5V가 되면서 전기가 흘러가게 됩니다.아날로그의 제어 역시 디지털 제어처럼 간단합니다.디지털핀은 하나의 핀에서 입력과 출력을 둘 다 제어할 수 있지만 아날로그 핀은 입력용과출력용이 따로 분리되어 있습니다. 아두이노 UNO의 경우 ANALOG IN이라고 표시된 곳에 A0부터A5까지 적혀있는 핀이 있는데 이 핀들이 바로 아날로그 입력 핀 입니다.디지털에서의 입력은 LOW,HIGH와 같이 단순히 전기가 끊겼는지 연결됐는지를 확인하는거에 비해아날로그 입력은 전압이 0V와 5V사이에서 어떤 크기로 들어오는지 확인합니다.아두이노 UNO의 디지털 핀들이 있는 곳에 보면 틸트(~) 표시가 붙은 핀들을 볼 수 있는데이 핀들이 바로 아날로그 출력 핀입니다. 당연히 이 핀들은 전압을 0V에서 5V사이에서 원하는크기로 설정하는 것입니다.아날로그 신호를 출력할 때 사용하는 함수는 analogWrite()인데 신호를 출력할 핀번호와 설정할 전압의 값을 인자로 사용합니다. 아날로그 신호 출력의 경우 0V부터 5V사이를 256개로쪼개서 원하는 값을 사용할 수 있습니다. 즉, 0V는 0의 값을 가지며 5V는 255의 값을 가집니다.LED를 이용하게 되면 당연히 전압의 크기에 따라서 LED의 밝기가 달라지게 됩니다. Arduino IDE 설치Arduino는 코드를 돌리는 기계이기 때문에 아두이노에게 우리가 작성한 code를 upload해 주어야 합니다.우리가 코드를 작성한 후 Arduino에게 code를 이식하는 작업을 도와주는 것이 Arduino IDE입니다.Arduino 홈페이지를 방문한 후 자신에게 맞는 (windows installer 버전) 버전을 선택하여 다운로드 후설치를 진행합니다.Arduino IDE를 실행하면 아두이노 개발환경에서 작성한 코드를 볼 수 있는데 이를 Sketch(스케치)라고부릅니다. 그리고 이 스케치를 아두이노 보드에 이식하는 것을 Upload라고 합니다.Arduino는 USB Type-A 단자를 이용하여 컴퓨터와 연결합니다. IDE에서 보드종류를 선택하고포트를 선택한 후 업로드 버튼을 누르면 Arduino에 코드가 이식되고 수행되게 됩니다.아두이노 보드에 기본으로 부착된 LED를 이용하여 블링크 예제를 실습해보도록 하겠습니다.기본 LED는 별도의 하드웨어 연결없이 제어할 수 있습니다. DIGITAL 13번 핀을 이용하고 다음의 코드로실행합니다.프로그램을 아두이노에 Upload하게 되면 초기에 setup()함수가 한번 실행되게 됩니다. 일반적으로초기설정과 관련된 코드가 setup()함수에 나오게 됩니다.setup()함수가 호출되고 난 후 loop()함수가 자동으로 반복실행되게 됩니다.void setup() {    pinMode(13,OUTPUT);}void loop() {    digitalWrite(13,HIGH);    delay(1000);    // 1초간 아두이노 보드를 멈추는 함수    digitalWrite(13,LOW);    delay(1000);}analog입력을 이용하여 LED 밝기를 조절하도록 코드를 작성할 수 있습니다. 아래와 같이 아두이노 회로를 구현합니다. (analog입력은 9번을 사용합니다.)void setup() {}void loop() {    for(int i=0; i&lt;256; i++) {        analogWrite(9,i);        delay(10);    }    for(int i=255; i&gt;=0; i--) {        analogWrite(9,i);        delay(10);    }      } PC와의 통신아두이노 보드는 PC와 Serial 모니터를 이용해서 통신할 수 있습니다. 이 Serial 모니터는아두이노 보드의 센서값을 확인하거나 아두이노 보드로 명령을 보낼 때 주로 사용합니다.아래의 코드를 컴파일 한 후 upload하고 Serial 모니터를 이용하여 확인void setup() {    Serial.begin(9600);    // 보드레이트 설정 : 시리얼 통신할 때의 통신속도를 의미. PC쪽에서 보드레이터를 동일하게    // 설정해야 통신이 가능. 다른 보드레이트를 이용할 경우 데이터가 잘못 전송될 수 있음.}void loop() {    Serial.println(\"Hello World\");   // Serial 모니터로 데이터 전송    delay(1000);}반대로 PC에서 아두이노 보드로 메시지를 전송할 수 있습니다. Serial 모니터의 상단에서글자를 입력하고 전송버튼을 누르면 아두이노 보드로 메시지가 전송됩니다.void setup() {    Serial.begin(9600);}void loop() {    if(Serial.available()) {     // Serial통신으로 받은 데이터가 있는지를 확인        char c = Serial.read();  // Serial통신으로 들어온 데이터 중 1바이트를 잘라내어 읽는다.                                 // 만약 문자열형태로 읽고 싶다면 readString()이용        Serial.print(c);    }} LED 사용LED는 전류가 흐르면 빛이 나는 액추에이터입니다. LED는 LED 렌즈의 지름이 5mm인 것을 많이 사용합니다.LED는 플러스와 마이너스로 극성이 나누어져있는데 LED의 다리 길이가 긴쪽이 플러스, 짧은 쪽이 마이너스극성을 가집니다.LED가 버틸 수 있는 전류보다 많은 전류가 연결되면 당연히 LED가 탈 수 있습니다. 반대로 너무 작은전류가 흐를경우 LED의 빛이 거의 나지 않게됩니다. 따라서 전류의 양을 조절하기 위해 저항을 LED의앞이나 뒤에 연결해 주어야 합니다. 그러면 얼마만큼의 전류가 적당한지를 알아야 하는데 이는 전자부품의데이터시트를 보고 확인해야 합니다.일반적으로 5mm LED의 필요 전류는 15mA이고 강하전압이 2V정도 된다고알려져 있습니다. 그렇다면 아두이노 보드에서 전류가 15mA 정도 흐르게 하기 위해서는 저항을 어떤값을 이용해야 할까요?전압 = 전류 * 저항아두이노의 전압은 5V이고 LED의 강하전압은 2V이기때문에 5-2=3 즉, 3V로 계산하면 됩니다.LED에서 필요한 전류는 15mA이기 때문에 0.015A입니다. 따라서3 = 0.015 * 저항저항을 구해보면 200이라는 값을 구할 수 있고 우리는 200옴짜리 저항을 이용해서 사용해야 LED가 타지않고 사용할 수 있게될 것입니다. 좀 더 안전하게 사용하기 위해서는 220옴과 같은 약간 더 큰 옴값을 이용하는 것이 좋습니다.int ledPin = 13;void setup() {  pinMode(ledPin,OUTPUT);}void loop() {  digitalWrite(ledPin,HIGH);  delay(1000);  digitalWrite(ledPin,LOW);  delay(1000);} 버튼 사용버튼을 누르면 LED가 켜지고 버튼을 떼면 LED가 꺼지게끔 만들어보겠습니다.부품을 여러개 사용하다보면 전원과 그라운드가 모자르게 되는경우가 있는데 이때브레드보드를 이용하면 이 문제를 해결할 수 있습니다.      아두이노의 그라운드 핀에 점퍼와이어를 연결한 후 브레드보드의 긴 파란색 부분에 연결합니다.일반적으로 그라운드는 검은색 점퍼와이어를 이용하는게 좋습니다. (구별을 위해서)        LED를 디지털 핀 13번에 연결합니다. 저항(220옴)도 같이 연결해서 기존에 LED 켜기할 때 사용했던구조로 연결합니다.        버튼을 중앙선을 기준으로 놓습니다. 버튼을 눌러야 전류가 통하도록 연결합니다. 저항은10k옴을 이용합니다. 그리고 디지털 핀 8번을 입력으로 사용합니다. (버튼을 누르면 전류가 흐르고 디지털 핀 8번에서 digitalRead()하면 HIGH값이 리턴됩니다.)        아래의 코드를 이용하여 버튼을 누르면 전원이 연결되고 디지털 핀 8번으로부터 입력이 HIGH가됩니다. 이를 조건문으로 활용하여 디지털 핀 13번에 연결한 LED에 불이 들어오게끔 코드를 작성합니다.  void setup() {  pinMode(13,OUTPUT);  pinMode(8,INPUT);}void loop() {    int value = digitalRead(8);    if(value==HIGH) {      digitalWrite(13,HIGH);    } else {      digitalWrite(13,LOW);    }} 자바프로그램과의 연동(Event기반)통신에서의 시리얼 통신이란 패러럴 통신(병렬 통신)에 반대되는 말로써 한번의 통신의 한 비트의 데이터를 보내는 방식을 말합니다.이런 Serial통신을 이용하여 Java와 아두이노간의 데이터 통신을 할 수 있습니다.간단하게 아두이노에서 버튼을 누르면 자바프로그램(javaFX)에서 “아두이노에서 버튼부품 클릭해서 LED 켜기”이라는 메시지를 javaFX의 TextArea에 출력하고 javaFX의 “LED 켜기” 버튼을 누르면 아두이노의LED를 켜고 “LED 끄기” 버튼을 누르면 아두이노의 LED를 끄게 구현하겠습니다.  아두이노 회로 구현(위에서 설명한 버튼과 LED구현을 그대로 이용)  아두이노 스케치 프로그램 작성 및 업로드int btnInputPin = 8;void setup() {  // put your setup code here, to run once:  pinMode(13,OUTPUT);  pinMode(btnInputPin,INPUT);  Serial.begin(9600);}void loop() {  // put your main code here, to run repeatedly:  if(Serial.available()) {   // Serial통신을 사용할 때 데이터 수신시 사용                             // 리턴값 : 시리얼 통신으로 수신한 데이터의 길이(bytes)                             // Serial 통신으로 아두이노에 데이터가 들어오면 이 데이터는                             // 일단 Serial Buffer라고 불리는 작은 메모리에 저장되고                             // Serial.read() 계열의 함수를 통해서 버퍼의 데이터를 읽어옵니다.    String inString = Serial.readString();    if(inString == \"LED_ON\") {      digitalWrite(13,HIGH);      } else if(inString == \"LED_OFF\"){      digitalWrite(13,LOW);    }  }  int value = digitalRead(btnInputPin);  if(value == HIGH) {    digitalWrite(13,HIGH);    Serial.print(\"O\");     delay(1000);   // 1초간 정지(메시지가 계속 전달되는것을 피하기 위해)  }}  자바프로그램 작성 및 실행class Exam03_ArduinoSerialListener implements SerialPortEventListener {\tInputStream in;\tExam03_ArduinoJavaFXSerial window;\tExam03_ArduinoSerialListener(InputStream in,Exam03_ArduinoJavaFXSerial window) {\t\tthis.in = in;\t\tthis.window = window;\t}\t@Override\tpublic void serialEvent(SerialPortEvent oEvent) {\t\tif (oEvent.getEventType() == SerialPortEvent.DATA_AVAILABLE) {\t\t\ttry {\t\t\t\tint available = in.available();\t\t\t\tSystem.out.println(\"받은 바이트수 : \" + available);\t\t\t\tbyte chunk[] = new byte[available];\t\t\t\tin.read(chunk, 0, available);\t\t\t\tString result = new String(chunk);\t\t\t\tSystem.out.println(\"아두이노에서 받은 메시지 : \" + result);\t\t\t\tif(result.equals(\"O\")) {\t\t\t\t\twindow.printMessage(\"아두이노에서 버튼부품 클릭해서 LED 켜기\");\t\t\t\t\t}\t\t\t} catch (Exception e) {\t\t\t\tSystem.err.println(e.toString());\t\t\t}\t\t}\t\t\t}\t}public class Exam03_ArduinoJavaFXSerial extends Application {\tTextArea textarea;\tButton ledOnBtn, ledOffBtn;\tInputStream in;\tBufferedWriter bw;\tpublic void printMessage(String msg) {\t\tPlatform.runLater(()-&gt;{\t\t\ttextarea.appendText(msg + \"\\n\");\t\t});\t}\tprivate void connectSerial() throws Exception {\t\tCommPortIdentifier portIdentifier = null;\t\t\t\tportIdentifier = \t\t\t\tCommPortIdentifier.getPortIdentifier(\"COM14\");\t\tif ( portIdentifier.isCurrentlyOwned() ) {\t\t\tSystem.out.println(\"현재 포트가 사용되고 있습니다.\");\t\t} else {\t\t\tCommPort commPort = \t\t\t\t\tportIdentifier.open(\"PORT_OPEN\",2000);\t\t\tif ( commPort instanceof SerialPort ) {\t\t\t\t//포트 설정(통신속도 설정. 기본 9600으로 사용)\t\t\t\tSerialPort serialPort = (SerialPort) commPort;\t\t\t\tserialPort.setSerialPortParams(9600,\t\t\t\t\t\tSerialPort.DATABITS_8,\t\t\t\t\t\tSerialPort.STOPBITS_1,\t\t\t\t\t\tSerialPort.PARITY_NONE);\t\t\t\t//Input,OutputStream 버퍼 생성 후 오픈\t\t\t\tin = serialPort.getInputStream();\t\t\t\t\t\t\t\t\tbw = new BufferedWriter(\t\t\t\t\t\tnew OutputStreamWriter(\t\t\t\t\t\t\t\tserialPort.getOutputStream()));\t\t\t\tserialPort.addEventListener(\t\t\t\t\t\tnew Exam03_ArduinoSerialListener(in,this));\t\t\t\tserialPort.notifyOnDataAvailable(true);\t\t\t} else {\t\t\t\tSystem.out.println(\"Serial 포트만 사용가능합니다.\");\t\t\t}\t\t}     \t}\t@Override\tpublic void start(Stage primaryStage) throws Exception {\t\tBorderPane root = new BorderPane();\t\troot.setPrefSize(700, 500);\t\ttextarea = new TextArea();\t\troot.setCenter(textarea);\t\tledOnBtn = new Button(\"LED 켜기\");\t\tledOnBtn.setPrefSize(250, 50);\t\tledOnBtn.setOnAction((e) -&gt; {\t\t\tString line = \"LED_ON\";\t\t\tprintMessage(\"LED 켜기버튼 클릭!!\");\t\t\ttry {\t\t\t\tbw.write(line,0,line.length());\t\t\t\tbw.flush();\t\t\t\t\t\t\t} catch (IOException e1) {\t\t\t\t// TODO Auto-generated catch block\t\t\t\te1.printStackTrace();\t\t\t}\t\t});\t\tledOffBtn = new Button(\"LED 끄기\");\t\tledOffBtn.setPrefSize(250, 50);\t\tledOffBtn.setOnAction((e) -&gt; {\t\t\tString line = \"LED_OFF\";\t\t\tprintMessage(\"LED 끄기버튼 클릭!!\");\t\t\ttry {\t\t\t\tbw.write(line,0,line.length());\t\t\t\tbw.flush();\t\t\t\t\t\t\t} catch (IOException e1) {\t\t\t\t// TODO Auto-generated catch block\t\t\t\te1.printStackTrace();\t\t\t}\t\t\t\t\t});\t\tFlowPane flowpane = new FlowPane();\t\tflowpane.setPrefSize(700, 50);\t\tflowpane.setHgap(10);\t\tflowpane.getChildren().add(ledOnBtn);\t\tflowpane.getChildren().add(ledOffBtn);\t\troot.setBottom(flowpane);\t\tScene scene = new Scene(root);\t\tprimaryStage.setScene(scene);\t\tprimaryStage.setTitle(\"javaFX Arduino Serial 통신\");\t\tprimaryStage.setOnCloseRequest(e-&gt;{\t\t\tSystem.exit(0);\t\t});\t\tprimaryStage.show();\t\ttry {\t\t\tconnectSerial();\t\t\t} catch (Exception e) {\t\t\tSystem.out.println(e);\t\t}\t}\tpublic static void main(String[] args) {\t\tlaunch();\t}} 안드로이드와 아두이노 연동 예제안드로이드의 SeekBar를 이용하여 Mobile Device에서 LED의 불빛을 제어하는예제를 작성합니다.Android - Java Network Server - Arduino 형태로 다음의 영상처럼 동작하도록 구현합니다. 피에조 스피커 활용피에조 스피커는 전기적 신호를 이용해서 소리를 내는 전자부품입니다. 동작하는전압에 따라 크기가 다양합니다. 여기서는 5V용 피에조 스피커를 활용합니다.피에조 스피커를 이용한 소리출력 예제를 작성해보도록 하겠습니다.  아두이노 회로 구현  아두이노 스케치 프로그램 작성 및 업로드int melody[] = { 262, 294, 330, 349, 392, 440, 494, 523 };void setup() {  for(int i=0; i&lt;8; i++) {    tone(8,melody[i],250);    delay(400);    noTone(8);  }}void loop() {  } LCD 활용LCD는 액정 화면에 글자나 숫자를 표시하는 전자부품입니다. 아두이노와 연결해 사용하는 것은주로 2줄이 있고 한 줄당 16글자를 표시할 수 있는 1602 LCD를 많이 이용합니다. (총 32자 표시)LCD를 확인해보면 핀이 아주 많은 것을 확인할 수 있습니다.각 핀들의 의미는 다음과 같습니다.      배경관련 LCD의 가장 오른쪽의 K와 A는 배경의 밝기와 관련이 있습니다. K는 배경밝기를제어하기 위해서 GND에 연결하고 A는 전원에 연결합니다. 만약 배경조명이 없거나 배경 밝기가 필요없다면이 2개의 핀들을 사용하지 않습니다.        데이터관련 오른쪽 3번째부터 10번째까지 핀들은 LCD에 값을 보내거나 LCD로부터 값을받을 때 사용하는 핀입니다. 각 핀들의 이름은 D7 ~ D0입니다.        설정관련 E핀은 LCD에 값을 쓸 수 있도록 할지 말지를 설정합니다. RW핀은 LCD의 값을읽을지 쓸지 선택할 때 사용합니다.        기타 VSS핀은 LCD가 동작하기 위해서 GND에 연결하는 핀이고, VDD핀은 전원에 연결합니다. V0핀은 글자 색을 진하게 할지 흐리게 할지 설정할 때 사용합니다.  이렇게 LCD는 핀들이 굉장히 많고 용도도 각기 다릅니다. 상당히 복잡하지만 사실 우리가 LCD를이용할때는 라이브러리를 이용해서 사용합니다. LCD는 LiquidCrystal이라는 라이브러리를 이용해서제어합니다.먼저 아두이노 회로도를 만들어야 합니다. 글로 표현하기에는 너무 복잡하기 때문에 교재를 이용해서회로도를 완성합니다. (아두이노, 상상을 현실로 만드는 프로젝트-입문편. 영진닷컴)#include &lt;LiquidCrystal.h&gt;LiquidCrystal lcd(12,11,2,3,4,5);// LiquidCrystal(RS,E,D4,D5,D6,D7); 핀 연결번호void setup() {  lcd.begin(16,2);}void loop() {  lcd.clear();  lcd.print(\"Hello World\");  delay(500);}LiquidCrystal 라이브러리에서 사용할 수 있는 함수는 다음과 같습니다.  LiquidCrystal() : LCD 클래스 생성에 사용. LCD 인터페이스 설정  begin() : LCD 화면 초기화(column과 row설정)  clear() : LCD 화면을 지우고 커서를 좌상으로 이동  home() : 커서를 좌상으로 이동  setCursor() : 커서를 특정위치로 이동  write() : 현재 커서에 한 문자를 출력  print() : 현재 커서부터 출력(Serial.print()와 유사)  cursor(), nocursor() : 커서 표시 on/off  display(), noDisplay() : LCD 화면에 정보 표시 on/off  scrollDisplayLeft(), scrollDisplayRight() : LCD 내용과 커서를 좌/우로 한칸 스크롤  autoscroll(), noautoscroll() : 문자 출력 시 이전 내용을 스크롤할 지를 결정  leftToright(), rightToLeft() : 문자 출력 후 커서의 이동위치 결정 LCD와 조도센서의 활용조도센서(Ambient Light Sensor)를 이용하여 측정한 조도를 LCD에 표현하는 예제를 구현합니다.#include &lt;LiquidCrystal.h&gt;LiquidCrystal lcd(12,11,2,3,4,5);// LiquidCrystal(RS,E,D4,D5,D6,D7); 핀 연결번호int cds = A0;  void setup() {  lcd.begin(16,2);}void loop() {  int val= analogRead(cds);   // analogRead()로 측정되는 범위(0~1023)  lcd.clear();  lcd.print(val);  delay(100);}End.",
        "url": "/arduino"
    }
    ,
    
    "can": {
        "title": "CAN Protocol",
            "author": "moon9342",
            "category": "",
            "content": " CAN 개요CAN은 Controller Area Network의 약자로 1986년에 독일의 메르세데스 벤츠사의 요구(자동차내의 3개의 서로다른 ECU간의 데이터 통신)로 자동차 부품회사인 로베르트 보쉬사가 개발해 자동차기술자 협회에서 제안한 네트워크 시스템입니다.ECU는 Electoric Control Unit의 약자로 자동차의 엔진, 자동변속기, ABS등의 상태를 컴퓨터로 제어하는전자제어장치를 의미합니다. 이런 ECU들은 각 목적에 따라 차량안에 분산되어 위치하고 있습니다.여러 센서들로부터 데이터를 ECU가 받아들이고 다른 ECU와 통신해서 차량의 모든 부분을 제어하는 역할을 담당하고 있습니다.현재 현대차 Genesis는 약 70개의 ECU가 탑제되어 있고 벤츠 S클래스와 BMW 7시리즈에는 80여개의 ECU,렉서스 LS시리즈에는 약 100개의 ECU가 탑제되어 있습니다.대표적인 ECU를 몇가지 살펴보면,  ACU(Airbag Control Unit) : 자동차 충돌 상황의 센서 신호를 받아 Airbag을 제어하는 ECU.  BCM(Body Control Module) : 자동차의 각종 경고, 도난방지 기능등을 제어하는 ECU.  ECU(Engine Control Unit) : 엔진의 상태를 모니터링하면서 연료량, 점화시기등의 기능을 제어하는 ECU.  TCU(Transmission Control Unit) : 자동차의 속도, 바퀴속도등의 값을 이용해 변속기를 제어하는 ECU.  ABS(Anti-lock Breaking System) : 자동차가 미끄러지지 않도록 브레이크의 on/off를 짧은시간동안 반복 제어하는 ECU.시간상으로 보자면, 1986년에 CAN 1.0발표후에 1991년에 CAN 2.0이 발표되고 1992년에 메르세데스 벤츠에서 CAN을 채택한 자동차가 출시되게 됩니다.그리고 그 다음해인 1993년에 ISO에 의해서 국제표준규격으로 채택됩니다.자동차내부의 통신은 CAN이 유일할까요? 그렇지는 않습니다. 시간이 지나면서 여러가지 형태의네트워크가 개발, 발표되고 있습니다. (FlexRay, LIN, CAN FD 등)그럼 CAN은 ECU간의 통신을 어떤 방식으로 할까요?CAN은 ECU간의 통신을 위해 직렬(Serial) 네트워크 통신방식을 이용합니다. 하나의 ECU가 시스템 안에 있는 다른 ECU에 대해 각각 입출력 단자를 갖는것이 아니라 CAN BUS에 대한 단일 CAN Interface만을 보유하고 있는 것이 특징입니다.자동차안에는 많은 ECU가 탑제되어 있고 이런 ECU간의 데이터 공유를 통해서 자동차가 제어됩니다.자동차는 환경적으로 고온, 충격, 진동 노이즈가 많은 환경인데 이런 열악한 환경에서도 CAN은 잘 견디기 때문에속도가 느림에도 불구하고 주력 차량 네트워크 통신 표준으로 사용되고 있습니다. CAN 프로토콜의 장점  CAN 프로토콜은 Multi Master 통신을 한다. CAN BUS를 공유하고 있는 MCU들은 모두가 Master의 역할을 수행할 수 있으며BUS가 idle상태이면 언제든지 BUS를 사용하고 싶을 때 사용할 수 있습니다.  노이즈에 매우 강하다. Twisted Pair Wire 2개를 사용하여 전기적 전압차를 이용한 통신을 하기 때문에 노이즈에 강합니다.  표준 프로토콜. CAN은 표준 프로토콜이기 때문에 시장성을 확보할 수 있습니다.  하드웨어적으로 오류보정이 가능. CRC가 하드웨어 적으로 생성되기 때문에 오류 검출이 가능하고 만약 오류가 검출되었을 때 하드웨어적으로 재전송합니다.  다양한 방식의 통신. CAN은 수신필터를 이용하여 필터를 어떻게 설정하느냐에 따라unicast, multicast, broadcast 통신을 할 수 있습니다.  ECU간의 우선순위가 존재. 각각의 ECU는 고유의 ID를 가지고 있는데 이 ID값이 낮을수록 우선순위가 높습니다. 이 우선순위를 이용하면 급한 Message를 먼저 처리할 수 있습니다.  CAN BUS 이용. 사용되는 전선의 양을 획기적으로 줄일 수 있습니다. CAN 통신의 형태CAN 프로토콜 환경 구성은 CAN Controller와 CAN Transceiver로 구현되어있습니다. CAN Controller는 내부 버퍼를 가지며 CAN Transceiver의 수신 메시지에 대해 ID 값을 기반으로 유효 데이터인지를 판별하여 MCU로 전송하는 역할을 수행합니다.CAN통신은 일반적으로 다음의 두 가지 형태로 사용된다.  MCU(Micro Controller Unit) 내부에 CAN Controller가 존재(통합형)  MCU(Micro Controller Unit) 외부에 CAN Controller가 존재(독립형) CAN 프로토콜의 특징CAN 통신은 여러 개의 ECU를 CAN BUS에 병렬로 연결하여 데이터를 주고 받는 방식으로 2가닥의 Twisted Pair Wire로 연결되어 있습니다.또한 CAN BUS는 직렬통신 프로토콜을 사용하는데 직렬(Serial) 통신은 일반적으로 하나의 신호선을 이용하여 데이터를 주고받는 통신을 지칭합니다. 신호선이 하나이기 때문에 데이터를 일정한 시간간격으로 전송하게 되며 따라서 일정한 길이의 데이터를 보내기 위해서는 약간의 시간이 필요합니다.데이터 전송에 약간의 시간이 필요하지만 적은 수의 신호선을 사용하기 때문에 비용을 절감할 수 있는 장점이 있습니다. 이때문에 많은 통신장비들이 직렬통신으로 데이터를 전송합니다. Serial 통신의 대표적인 예가 USB, PC의 COM port이죠.이와 반대로 병렬통신은 여러 개의 신호선을 이용하여 데이터를 전송하는 방식이기 때문에 단위시간당 더 많은 데이터를 보낼 수 있지만 통신 거리가 길어질수록 많은 선들을 모두 연장해야 하므로 비용이 증가하게 되고 최신 단말 장치들이 소형화 추세에 있는데 현실적으로 통신을 하기위한 I/O단자의 크기는 크게 줄일 수 없습니다. 따라서 많은 I/O단자를 가지고 있는 병렬통신은 소형화된 기기에서 사용하기에 적합하지 않습니다.CAN 통신은 주소를 이용한 통신이 아닌 ID를 이용한 통신으로 이 ID의 값에 따라 통신의 우선순위가 결정됩니다.각 ECU들은 BUS상에서 메시지를 주고 받기 때문에 기존의 ECU들은 새롭게 추가된 ECU에 대한 정보를 Update할 필요가 없습니다.CAN은 다중 통신망(Multi Master Network)이고 CSMA/CD(Carrier Sense Multiple Access/Collision Detection)방식을 이용합니다. 즉, Ethernet 통신방식과 유사하다고 생각하시면 됩니다.각 ECU는 메시지를 보내기 이전에 CAN BUS가 사용중인지를 파악(Carrier Sense)합니다. 메시지를 보낼 수 있을 때 메시지를 보내며 수신측에서 CRC를 이용해 충돌이 발생했는지를 감지하고 만약 충돌이 발생하면 재전송하게됩니다.보낸 메시지는 송신측이나 수신측의 주소를 포함하지 않습니다. 대신 메시지안에는 ID(11bit 혹은 29bit)가 포함되어 있습니다. CAN 메시지는 크게 ID Field와 Data Field를 가지고 있는데 ID Field는 ECU의 ID값이 될 수 있지만 “엔진 회전수”와 같은 것을 나타내는 ID값이 될 수 도 있습니다. 이때 Data Field는 2000 rpm과 같은 값을 가지고 있게 되는 것이죠. 이런 메시지인 경우 여러 ECU에서 해당 message를 수신해야 하는데 각 ECU는 ID MASK(Filter)를 이용하여 자신이 받아들일 수 있는 메시지를 정해서 받습니다. ECU가 데이터를 전달 받으면 Receiver는 Ack를 신호를 생성하여 보내게 됩니다.CAN 네트워크상의 모든 ECU는 네트워크 상의 메시지를 수신한 후 ID를 이용하여 자신에게 필요한 메시지인지를 식별한 후 자신이 필요한 경우만 메시지를 취하고 그렇지 않으면 해당 메시지는 무시합니다.CAN BUS상에 흐르는 여러 ECU의 데이터들이 동시에 하나의 ECU로 유입되는 경우 식별자(ID)의 숫자를 비교하여 우선순위가 높은 메시지를 먼저 취합니다.메시지를 보낼 경우 마찬가지로 우선 순위가 높은 메시지가 CAN BUS의 사용권한을 보장 받으며 낮은 순위의 메시지는 다음 BUS cycle에 전송하게 됩니다. CAN 프레임 구성CAN 통신은 프레임이라고 하는 패킷(packet)으로 데이터를 전송합니다. 프레임이란 하나의 메시지를 이루는 필드 또는 bit들의 집합을 말하며 CAN 프레임은 다음과 같은 분할 구역(section)으로 구성되어 있습니다.  SOF(Start Of Frame) : 메시지의 시작을 의미하는 비트로 버스의 노드(node)를 동기화하기 위해 사용됩니다.  Identifier(ID) : 식별자로서 메시지의 내용을 식별하고 메시지의 우선순위를 부여합니다. CAN 메시지에 있는 ID의 길이에 따라서 표준 CAN과 확장 CAN 두 가지로 구분됩니다. 표준 CAN은 11 비트 식별자이고, 확장 CAN은 29비트 식별자로 구분됩니다.  Control : 데이터의 길이(DLC)를 의미합니다.  Data : 특정한 노드에서 다른 노드로 전송하는 데이터 포함하며 8Bytes까지 사용할 수 있습니다.  CRC : 프레임의 송신 오류 및 오류 검출에 사용됩니다.  ACK : 오류가 없는 메시지가 전송되었다는 것을 의미하는 비트로서, CAN 제어기는 메시지를 정확하게 수신했다면 ACK(Acknowledgement) 비트를 전송합니다. 전송 노드는 버스 상에서 ACK 비트의 유무를 확인하고 만약 ACK 비트가 발견되지 않는다면 재전송을 시도합니다.임의의 노드에서 올바른 메시지를 수신하게 되면 ACK 필드를 받는 순간 ACK 슬롯의 값을 ‘d’로 설정해 Bus 상에서 계속 전송하게 됩니다.  EOF(End of Frame) :  프레임의 끝을 나타내고 종료를 의미합니다. CAN의 활용CAN 통신은 자동차 분야뿐만 아니라 자동화 기기, 의료 기기 그리고 로봇 등 다양한 분야에서도 널리 쓰이고 있기 때문에 앞으로도 매우 중요하게 쓰일 통신방법이 될 것입니다.두 개의 컴퓨터를 CAN 장비를 이용해서 Serial 연결 한 후 CANPro Analyzer를 이용하여 packet을 주고 받는실습을 진행한 후 Java Program과 Arduino를 결합하여 실습을 진행합니다.CANPro 장비 연결      Windows 10은 디지털 서명 해제 작업을 먼저 선행해야 한다.디지털 서명 해제 for Windows10        드라이버를 설치하지 않고 CANPro 장비의 USB를 PC에 연결하고제어판 &gt; 하드웨어 및 소리 &gt; 장치관리자를 확인하면 기타장치 &gt; CANPro Analyzer가 노란색 느낌표가 표시된 상태로 등록된것을 볼 수 있다.        제공된 드라이버 폴더 RealSYS_USB_Device_Driver(20170316)안의 dp-chooser.exe를 관리자 모드로 실행해서 개발툴용 USB Device Driver를 설치한다. 설치가 완료되면 노란색 느낌표가 있던 기타장치는 사라지고장치관리자 &gt; 포트 부분에 CANPro가 등록된걸 확인할 수 있다. (혹은 USB Serial Port로 등록)정상적으로 설치가 되었으면 리부팅.        드라이버에 설치하면 제공된 CANPro Analyzer for Windows10을 설치한다.        총 3대의 컴퓨터(데스크탑 PC + 노트북 + 라떼판다)에 각각 CAN 장비(Controller + Transceiver)를 연결합니다.CAN BUS가 존재하지 않기 때문에 3대를 연결하기 위해서는 아래 그림처럼 선을 겹쳐서 연결해야 합니다.  CANPro 장비 설정  노트북을 기준으로 설명하면 CANPro Analyzer를 실행시킨 후 동작 &gt; CANPro 환경 설정 쓰기를 실행합니다.  아래 그림과 같이 CANPro 장비 설정을 바꿉니다. PC통신 인터페이스는 Serial 통신으로 설정해야 하고 적절한 Serial 통신 포트를 설정해야 합니다. Serial 통신 속도부분과 프로토콜, CAN BPS부분은 다른 PC의 설정들과 동일하게 설정해야 합니다. 수신 ID는 자신의 수신 ID를 설정하는 부분입니다. 다른장비과 구분되게 설정합니다. 설정버튼을 누르면 현재 설정대로 CAN장비의 설정을 변경합니다.  동작 &gt; CANPro 환경 설정 읽기를 실행해서 설정한 내용을 읽어와서 정상적으로 설정이 됬는지 확인합니다. 데이터를 받기 위해서는 동작 &gt; CAN 데이터 수신 시작을 실행하여 데이터 수신을 시작해야 다른 CAN장비로부터들어오는 packet을 받을 수 있습니다.  데스크탑 PC와 노트북을 CAN장비로 연결한 후 packet을 보내고 받는 영상입니다. 수신 MASK ID를 설정하지않았기 때문에 모든 packet을 다 받습니다.  CAN Message 수신시 특정한 ID 또는 어떤 범위의 ID만 받고자 할때 MASK를 이용합니다.Mask는 Filter의 사용여부(Enable/Disable)를 결정합니다. 즉, 실제 Message ID가 CAN Rx에 수신 되었을 때, Filter의 각 bit값이 비교 되어 같은지 다른지 판단하여 수용하게 됩니다. 이때 각 Filter bit값이 비교 되기 위해서는 이에 대응되는 Mask bit가 Enable,즉 1이 되어야 합니다. 따라서 0일때는 Filter bit값에 상관없이 모두 수용하게 되는 것입니다. 이 부분은 실제 실습을 통해서 확인해야 할 듯 합니다. Java 프로그램을 이용한 CAN 활용CANPro Analyzer를 이용하여 CANPro 환경설정과 데이터의 이동, MASK를 이용한 멀티캐스트를 이해했다면 이제 Java 코드를 이용하여 CANPro를 통해 데이터를 주고 받아보겠습니다. 즉, Analyzer프로그램 대신Java Program을 이용하겠다는 의미입니다.CANPro 통신 프로토콜 사용자 메뉴얼을 참고하여 프로그램을 작성해야 합니다.  DataFrame Sender (Using JavaFX)public class Exam01_DataFrameSender extends Application{\tTextArea textarea;    // 메시지창 \tButton connBtn, sendBtn;    // 포트 연결 버튼, Data Frame 보내기 버튼\t\tprivate CommPortIdentifier portIdentifier;\tprivate CommPort commPort;\tprivate SerialPort serialPort;\t\tprivate OutputStream out;\t\t// TextArea에 문자열 출력하기 위한 method\tprivate void printMSG(String msg) {\t\tPlatform.runLater(()-&gt;{\t\t\ttextarea.appendText(msg + \"\\n\");\t\t});\t}\t\tprivate void connectPort(String portName) {\t\ttry {\t\t\tportIdentifier = CommPortIdentifier.getPortIdentifier(portName);\t\t\tprintMSG(portName + \"에 연결을 시도합니다!!\");\t\t\t\t\t\tif(portIdentifier.isCurrentlyOwned()) {\t\t\t\tprintMSG(portName + \"가 현재 다른 프로그램에 의해 사용중입니다. \");\t\t\t\t\t\t\t} else {\t\t\t\t// 포트를 열고 포트객체를 얻는다.\t\t\t\t// open()의 첫번째 인자 : Name of application making this call.\t\t\t\t// open()의 두번째 인자 : Time in milliseconds to block waiting for port open.\t\t\t\tcommPort = portIdentifier.open(this.getClass().getName(), 5000);\t\t\t\tif( commPort instanceof SerialPort ) {\t\t\t\t\tserialPort = (SerialPort) commPort;\t\t\t\t\tserialPort.setSerialPortParams(9600, // 통신속도\t\t\t\t\t\t\tSerialPort.DATABITS_8, // 데이터 비트 \t\t\t\t\t\t\tSerialPort.STOPBITS_1, // Stop 비트 \t\t\t\t\t\t\tSerialPort.PARITY_NONE);  // Parity 비트\t\t\t\t\t// OutputStream 생성\t\t\t\t\tout = serialPort.getOutputStream(); \t\t\t\t\tprintMSG(\"성공적으로 \" + portName + \"에 접속되었습니다.!!\");\t\t\t\t} else {\t\t\t\t\tprintMSG(\"Serial Port만 사용할 수 있습니다.!!\");\t\t\t\t\t}\t\t\t}\t\t} catch (Exception e) {\t\t\te.printStackTrace();\t\t}\t}\t\tprivate void sendDataFrame(String msg) {\t\t// String msg = \"W\" + \"28\" + \"10003B01\" + \"0000000000005011\";\t\t// 데이터프레임 전송\t\t// CAN 네트워크상에 특정 CAN Message를 보내고자 할 때\t\t// 시작문자 =&gt; 1문자 =&gt; \":\" 이용\t\t// 명령코드 =&gt; 1문자 =&gt; \"W\" (전송)\t\t// 송신데이터 특성코드 =&gt; 2문자\t\t//                   5번째 bit가 0이면 CAN2.0A, 1이면 CAN2.0B를 나타냄\t\t//                   4번째 bit가 0이면 Data Frame을 지칭, 1이면 Remote Frame\t\t//                   3번째~0번째는 송신데이터의 길이(0부터 8까지의 값을 가지게 된다.)\t\t//                   예) 28 =&gt; 00101000 =&gt; CAN2.0B이면서 데이터 길이가 8인\t\t//                             Data Frame을 의미.\t\t// CAN 송신 ID =&gt; 4문자(11bit사용시) 혹은 8문자(29bit사용시)\t\t//               16진수로 표현하고 4bit가 1문자로 표현되기때문에 29bit를 표현하기 위해서는\t\t//               8개의 16진수가 필요하고 문자로 표현.\t\t//               예) 041C0800 =&gt; 0번부터 28번 비트중에\t\t//                            =&gt; 26번, 20번, 19번, 18번, 11번 bit가 check\t\t// CAN 송신 Data =&gt; 위에서 정의한 송신데이터 특성 코드 중 송신데이터의 길이에 따라\t\t//              =&gt; 0 ~ 16문자를 표현\t\t//              =&gt; 예) 데이터 프레임 개수(송신데이터의 길이)가 8이면 ASCII형식으로는\t\t//                     8개의 문자로 Hex표현이면 16개의 문자로 표현\t\t// Checksum =&gt; 2문자(수식에 의한 Checksum계산)                       \t\t// 끝 문자 =&gt; 1문자 ( \"\\r\" 사용 )\t\t\t\tmsg = msg.toUpperCase();\t\tchar c[] = msg.toCharArray();\t\tint checksumData = 0;\t\tfor (char cc : c) {\t\t\tchecksumData += cc;\t\t}\t\tchecksumData = (checksumData &amp; 0xFF);\t\tString sendMsg = \":\" + msg + \t\t\t\tInteger.toHexString(checksumData).toUpperCase() + \"\\r\";\t\t\t\tprintMSG(\"생성된 전송 메시지 : \" + sendMsg);\t\t\t\t// 전송할 byte배열 생성\t\tbyte[] inputData = sendMsg.getBytes();\t\ttry {\t\t\tout.write(inputData);\t\t\t//out.flush();\t\t\tprintMSG(\"성공적으로 전송되었습니다.!!\");\t\t} catch (IOException e1) {\t\t\te1.printStackTrace();\t\t}\t\t\t\t\t\t}\t\t@Override\tpublic void start(Stage primaryStage) throws Exception {\t\tBorderPane root = new BorderPane();\t\troot.setPrefSize(700, 500);\t\t\t\ttextarea = new TextArea();\t\troot.setCenter(textarea);\t\t\t\t\tconnBtn = new Button(\"COM 포트 접속\");\t\tconnBtn.setPrefSize(200, 50);\t\tconnBtn.setPadding(new Insets(10));\t\tconnBtn.setOnAction(e-&gt;{\t\t\tString portName = \"COM16\";\t\t\t// 포트 접속\t\t\tconnectPort(portName);\t\t});\t\t\t\tsendBtn = new Button(\"Data Frame 전송\");\t\tsendBtn.setPrefSize(200, 50);\t\tsendBtn.setPadding(new Insets(10));\t\tsendBtn.setOnAction(e-&gt;{\t\t\t// Data Frame 전송\t\t\tString msg = \"W\" + \"28\" + \"10003B01\" + \"0000000000005011\";\t\t\tsendDataFrame(msg);\t\t\t\t\t});\t\t\t\t\t\t\t\tFlowPane flowPane = new FlowPane();\t\tflowPane.setPrefSize(700, 50);\t\tflowPane.setHgap(10);\t\tflowPane.getChildren().add(connBtn);\t\tflowPane.getChildren().add(sendBtn);\t\t\t\troot.setBottom(flowPane);\t\t\t\tScene scene = new Scene(root);\t\tprimaryStage.setScene(scene);\t\tprimaryStage.setTitle(\"CAN DataFrame Send Test\");\t\tprimaryStage.setOnCloseRequest(e-&gt;{\t\t\tSystem.exit(0);\t\t});\t\tprimaryStage.show();\t\t\t}\t \tpublic static void main(String[] args) {\t\tlaunch();\t}\t\t}  DataFrame Receiver &amp; 환경설정public class Exam02_DataFrameReceiver extends Application {\tTextArea textarea;\t// 포트접속버튼, 환경쓰기버튼, 데이터수신가능버튼, 데이터수신가능버튼\tButton connBtn, envBtn, revEnableBtn, revDisableBtn;\t\t\tprivate CommPortIdentifier portIdentifier;\tprivate CommPort commPort;\tprivate SerialPort serialPort;\t\tprivate BufferedInputStream bin;\tprivate OutputStream out;\t\t\tclass MyPortListener implements SerialPortEventListener {\t\t@Override\t\tpublic void serialEvent(SerialPortEvent event) {\t\t\tif (event.getEventType() == SerialPortEvent.DATA_AVAILABLE) {\t\t\t\tbyte[] readBuffer = new byte[128];\t\t\t\ttry { \t\t\t\t\twhile (bin.available() &gt; 0) {\t\t\t\t\t\tbin.read(readBuffer);\t\t\t\t\t}\t\t\t\t\tString revData = new String(readBuffer);\t\t\t\t\tprintMSG(\"Receive Low Data:\" + revData);\t\t\t\t\t\tif(revData.trim().equals(\":G01A8\")) {\t\t\t\t\t\tprintMSG(\"지금부터 데이터 수신 가능합니다.\");\t\t\t\t\t}\t\t\t\t\tif(revData.trim().equals(\":G00A7\")) {\t\t\t\t\t\tprintMSG(\"지금부터 데이터 수신이 불가능합니다.\");\t\t\t\t\t}\t\t\t\t\t\t// CAN 수신 데이터 읽기 \t\t\t\t\t// U2800000001111100000000000044\t\t\t\t\t// 시작문자 =&gt; :\t\t\t\t\t// 명령코드 =&gt; U\t\t\t\t\t// 수신데이터 특성코드 : 0010 1000 =&gt; 28\t\t\t\t\t// CAN 수신 ID : 00000001\t\t\t\t\t// CAN 수신 데이터 : 1111000000000000\t\t\t\t\t// checksum : 44\t\t\t\t\tif(revData.charAt(1) == 'U') {\t\t\t\t\t\tprintMSG(\"데이터를 수신했습니다.\");\t\t\t\t\t}\t\t\t\t} catch (Exception e) {\t\t\t\t\te.printStackTrace();\t\t\t\t}\t\t\t\t\t\t\t}\t\t\t\t}\t\t\t}\t\t// TextArea에 문자열 출력하기 위한 method\tprivate void printMSG(String msg) {\t\tPlatform.runLater(()-&gt;{\t\t\ttextarea.appendText(msg + \"\\n\");\t\t});\t}\t\tprivate void connectPort(String portName) {\t\ttry {\t\t\tportIdentifier = CommPortIdentifier.getPortIdentifier(portName);\t\t\tprintMSG(portName + \"에 연결을 시도합니다!!\");\t\t\t\t\t\tif(portIdentifier.isCurrentlyOwned()) {\t\t\t\tprintMSG(portName + \"가 현재 다른 프로그램에 의해 사용중입니다. \");\t\t\t\t\t\t\t} else {\t\t\t\t// 포트를 열고 포트객체를 얻는다.\t\t\t\t// open()의 첫번째 인자 : Name of application making this call.\t\t\t\t// open()의 두번째 인자 : Time in milliseconds to block waiting for port open.\t\t\t\tcommPort = portIdentifier.open(this.getClass().getName(), 5000);\t\t\t\tif( commPort instanceof SerialPort ) {\t\t\t\t\tserialPort = (SerialPort) commPort;\t\t\t\t\tserialPort.setSerialPortParams(921600, // 통신속도\t\t\t\t\t\t\tSerialPort.DATABITS_8, // 데이터 비트 \t\t\t\t\t\t\tSerialPort.STOPBITS_1, // Stop 비트 \t\t\t\t\t\t\tSerialPort.PARITY_NONE);  // Parity 비트\t\t\t        printMSG(portName + \"에 이벤트 리스너가 등록되었습니다.\");\t\t\t\t\t// Stream 생성\t\t\t\t\tbin = new BufferedInputStream(serialPort.getInputStream());\t\t\t\t\tout = serialPort.getOutputStream(); \t\t\t\t\tprintMSG(\"성공적으로 \" + portName + \"에 접속되었습니다.!!\");\t\t\t\t    serialPort.addEventListener(new MyPortListener());\t\t\t\t    serialPort.notifyOnDataAvailable(true);\t\t\t\t} else {\t\t\t\t\tprintMSG(\"Serial Port만 사용할 수 있습니다.!!\");\t\t\t\t\t}\t\t\t}\t\t} catch (Exception e) {\t\t\te.printStackTrace();\t\t}\t}\t\t\t@Override\tpublic void start(Stage primaryStage) throws Exception {\t\tBorderPane root = new BorderPane();\t\troot.setPrefSize(850, 500);\t\t\t\ttextarea = new TextArea();\t\troot.setCenter(textarea);\t\t\t\tconnBtn = new Button(\"Serial 포트 접속\");\t\tconnBtn.setPrefSize(200, 50);\t\tconnBtn.setPadding(new Insets(10));\t\tconnBtn.setOnAction(e-&gt;{\t\t\tString portName = \"COM16\";\t\t\tconnectPort(portName);\t\t});\t\t\t\t\t\t\t\trevEnableBtn = new Button(\"데이터수신가능\");\t\trevEnableBtn.setPrefSize(200, 50);\t\trevEnableBtn.setPadding(new Insets(10));\t\trevEnableBtn.setOnAction(e-&gt;{\t\t\t// CAN 데이터 수신 여부 설정\t\t\t// 시작문자 =&gt; 1문자 =&gt; \":\" 이용\t\t\t// 명령코드 =&gt; 1문자 =&gt; \"G\"\t\t\t// 수신 여부 명령 코드 =&gt; 2문자\t\t\t//                   00 : 현재 CANPro의 CAN 데이터 수신 여부 환경을 읽어온다.\t\t\t//                   10 : CANPro의 CAN 데이터 수신 동작을 중지한다.\t\t\t//                   11 : CANPro의 CAN 데이터 수신 동작을 시작한다.\t\t\t// Check Sum =&gt; 2문자\t\t\tString str = \"G11\";\t\t\tString tmpStr = str.toUpperCase();\t\t\tchar c[] = tmpStr.toCharArray();\t\t\tint checksumData = 0;\t\t\tfor (char cc : c) {\t\t\t\tchecksumData += cc;\t\t\t}\t\t\tchecksumData = (checksumData &amp; 0xFF);\t\t\tString checksumHexString = Integer.toHexString(checksumData).toUpperCase();\t\t\t//printMSG(\"checksum계산값 : \" + checksumHexString);\t\t\t\t\t\t// 끝문자 =&gt; 1문자 =&gt; \"\\r\" 이용\t\t\t\t\t\t// String msg = \":G11A9\\r\";\t\t\tString msg = \":\" + str + checksumHexString + \"\\r\";\t\t\t\t\t\ttry {\t\t\t\tbyte[] inputData = msg.getBytes();\t\t\t\tout.write(inputData);\t\t\t\t// 정상응답이 올경우\t\t\t\t// \":G01A8\"   =&gt; 00의 의미는 현재 CAN 데이터 수신 동작이 중지.\t\t\t\t//            =&gt; 01의 의미는 현재 CAN 데이터 수신 동작이 시작.\t\t\t\t//            =&gt; A8의 의미는 G01에 대한 checksum         \t\t\t\t\t\t\t} catch (IOException e1) {\t\t\t\te1.printStackTrace();\t\t\t}\t\t});\t\t\t\t\t\t\t\trevDisableBtn = new Button(\"데이터수신중지\");\t\trevDisableBtn.setPrefSize(200, 50);\t\trevDisableBtn.setPadding(new Insets(10));\t\trevDisableBtn.setOnAction(e-&gt;{\t\t\t// CAN 데이터 수신 여부 설정\t\t\t// 시작문자 =&gt; 1문자 =&gt; \":\" 이용\t\t\t// 명령코드 =&gt; 1문자 =&gt; \"G\"\t\t\t// 수신 여부 명령 코드 =&gt; 2문자\t\t\t//                   00 : 현재 CANPro의 CAN 데이터 수신 여부 환경을 읽어온다.\t\t\t//                   10 : CANPro의 CAN 데이터 수신 동작을 중지한다.\t\t\t//                   11 : CANPro의 CAN 데이터 수신 동작을 시작한다.\t\t\t// Check Sum =&gt; 2문자\t\t\tString str = \"G10\";\t\t\tString tmpStr = str.toUpperCase();\t\t\tchar c[] = tmpStr.toCharArray();\t\t\tint checksumData = 0;\t\t\tfor (char cc : c) {\t\t\t\tchecksumData += cc;\t\t\t}\t\t\tchecksumData = (checksumData &amp; 0xFF);\t\t\tString checksumHexString = Integer.toHexString(checksumData).toUpperCase();\t\t\t//printMSG(\"checksum계산값 : \" + checksumHexString);\t\t\t\t\t\t// 끝문자 =&gt; 1문자 =&gt; \"\\r\" 이용\t\t\t\t\t\t// String msg = \":G10A9\\r\";\t\t\tString msg = \":\" + str + checksumHexString + \"\\r\";\t\t\t\t\t\ttry {\t\t\t\tbyte[] inputData = msg.getBytes();\t\t\t\tout.write(inputData);\t\t\t\t// 정상응답이 올경우\t\t\t\t// \":G00A7\"   =&gt; 00의 의미는 현재 CAN 데이터 수신 동작이 중지.\t\t\t\t//            =&gt; 01의 의미는 현재 CAN 데이터 수신 동작이 시작.\t\t\t\t//            =&gt; A7의 의미는 G00에 대한 checksum         \t\t\t} catch (IOException e1) {\t\t\t\te1.printStackTrace();\t\t\t}\t\t});\t\t\t\t\t\t\t\tenvBtn = new Button(\"환경설정\");\t\tenvBtn.setPrefSize(200, 50);\t\tenvBtn.setPadding(new Insets(10));\t\tenvBtn.setOnAction(e-&gt;{\t\t\t// CAN 데이터 수신 여부 설정\t\t\t// 시작문자 =&gt; 1문자 =&gt; \":\" 이용\t\t\t// 명령코드 =&gt; 1문자 =&gt; \"Z\"\t\t\t// 자세한 설정내용은 CANPro User Manual 참조\t\t\t// CAN bit time에 대한 내용은 User Manual 3page\t\t\t// 250k =&gt; 0x0F, 0x34로 지정되어 있음.\t\t\t// https://www.mathsisfun.com/binary-decimal-hexadecimal-converter.html\t\t\t// 해당사이트를 이용하면 4bit의 값을 hexa로 표현 가능.\t\t\t// String str = \"Z 1C 0F34 00000001 00000001\";\t\t\tString str = \"Z1C0F340000000100000001\";\t\t\tString tmpStr = str.toUpperCase();\t\t\tchar c[] = tmpStr.toCharArray();\t\t\tint checksumData = 0;\t\t\tfor (char cc : c) {\t\t\t\tchecksumData += cc;\t\t\t}\t\t\tchecksumData = (checksumData &amp; 0xFF);\t\t\tString checksumHexString = Integer.toHexString(checksumData).toUpperCase();\t\t\t//printMSG(\"checksum계산값 : \" + checksumHexString);\t\t\t\t\t\t// 끝문자 =&gt; 1문자 =&gt; \"\\r\" 이용\t\t\t\t\t\tString msg = \":\" + str + checksumHexString + \"\\r\";\t\t\t\t\t\ttry {\t\t\t\tbyte[] inputData = msg.getBytes();\t\t\t\tout.write(inputData);\t\t\t} catch (IOException e1) {\t\t\t\te1.printStackTrace();\t\t\t}\t\t});\t\t\t\t\t\t\t\tFlowPane flowPane = new FlowPane();\t\tflowPane.setPrefSize(850, 50);\t\tflowPane.setHgap(10);\t\tflowPane.getChildren().add(connBtn);\t\tflowPane.getChildren().add(revEnableBtn);\t\tflowPane.getChildren().add(revDisableBtn);\t\tflowPane.getChildren().add(envBtn);\t\t\t\troot.setBottom(flowPane);\t\t\t\tScene scene = new Scene(root);\t\tprimaryStage.setScene(scene);\t\tprimaryStage.setTitle(\"CAN DataFrame Receive Test\");\t\tprimaryStage.setOnCloseRequest(e-&gt;{\t\t\tSystem.exit(0);\t\t});\t\tprimaryStage.show();\t\t\t}\t \tpublic static void main(String[] args) {\t\tlaunch();\t}\t\t}End.",
        "url": "/can"
    }
    ,
    
    "hadoop": {
        "title": "Hadoop 설치와 활용",
            "author": "moon9342",
            "category": "",
            "content": "VMware Workstation Pro 15 설치 및 CentOS 7 설치Hadoop을 사용하기 위해서 Windows 10에 VMWARE Workstation Pro 15를 설치한 후 CentOS 7을 설치합니다.(VMWare Workstation Player는 무료로 사용가능하지만 Workstation Pro 버전은 유료입니다. 30일 trial을 이용할 수 있습니다.)먼저 VMware Workstation Pro를 설치하고 실행하면 다음과 같은 화면을 볼 수 있습니다.새로운 가상머신을 만듭니다. 가상머신을 만든 후 나중에 iso파일을 이용해서 CentOS 7을 설치합니다.가상머신의 이름을 정해주는 부분이 나오는데 우리는 가상머신을 총 4개 이용할것입니다. 각각의 가상머신 이름을Hadoop01 ~ Hadoop04까지 사용합니다. 처음의 가상머신만 생성하고 나머지 3개의 가상머신은 clone해서 사용합니다.디스크 공간은 50GB로 설정하고 Customize Hardware를 클릭해서 사용 메모리는 2GB로 설정합니다.생성이 완료된 후 Virtual Machine Setting을 이용하여 CD/DVD부분에 CentOS 7 iso image파일을 연결한 후Virtual Machine을 기동시키면 CentOS 7 설치가 진행됩니다.CentOS 7 iso image는 여기를 클릭하면 CentOS-7-x86_64-DVD-2003.iso 파일을 받으실 수 있습니다.아래의 화면은 VMware Player를 이용한 설치화면입니다. WMware Workstation을 사용하는것과 차이가 없습니다.먼저 언어선택에서 한국어를 선택하시고 계속 진행하면 다음과 같은 화면이 나오는데 여기서 먼저 네트워크 및 호스트명으로 들어간 후 네크워크를 연결(켬)합니다.완료를 클릭하신 후 소프트웨어 &gt; 소프트웨어 설치를 클릭한 후 다음과 같이 설정합니다. (GNOME 사용이 필수는 아닙니다. 사용의 편의를 위해서 GNOME을 선택한 것 뿐입니다.)완료를 클릭한 후 시스템 &gt; 설치대상을 선택하여 파티션을 잡아줍니다.파티션을 설정합니다. 부분을 선택하고 완료를 누르면 수동으로 파티션 설정하는 부분으로 넘어갑니다. 다음의각 파티션을 설정합니다.  swap : 2GB  /boot : 1GB  /home : 10GB  / : 용량을 지정하지 않으면 나머지 모든 용량을 자동으로 할당합니다.설치시작을 눌러 설치를 시작합니다.root 유저의 암호를 변경하고 새로운 사용자를 한명 추가합니다. 새로운 사용자를 추가했지만사용의 편의를 위해 root 계정을 이용하도록 하겠습니다.설치가 끝나면 재부팅하고 root 계정으로 로그인합니다.Java 설치Hadoop은 JVM상에서 동작하기 때문에 Java를 설치해야 합니다. Java를 다시 설치하고 환경변수를 설정합니다. Java는 8버전을 이용합니다.  기존의 Java 삭제  rpm -qa | grep java결과로 출력된 파일 중 javapackages-tools-3.4.1-11.el7.noarch, python-javapackages-3.4.1-11.el7.noarch,tzdata-java-2018e-3.el7.noarch 3개에 대해서 삭제를 진행합니다.  yum remove javapackages-tools-3.4.1-11.el7.noarch  yum remove python-javapackages-3.4.1-11.el7.noarch  yum remove tzdata-java-2018e-3.el7.noarch  rpm -qa | grep java설치된 내용이 없음을 확인한 후 Oracle에서 Java 8을 다운로드 합니다.만약 다운로드가 잘 안되면 Windows에서 다운로드 한 후 (Linux X64 tar.gz파일) 공유폴더를 이용해서CentOS로 복사합니다.공유폴더 설정은 윈도우에서 공유폴더를 하나 생성한 후 폴더의 속성 &gt; 공유 &gt; 고급공유에서 선택한 폴더공유를체크하고 권한부분에서 eveyone에 모든 권한을 부여합니다.VMware 가상머신 설정에서 option 탭에서 아래의 그림과 같이 설정합니다. 설정이 끝나면 VMware Tool을 설치합니다.VM 메뉴의 Install VMware Tools를 선택하면 VMware Tools가 CD형식으로 바탕화면에 나타나고 /run/media/root/VMware Tools/ 디렉토리로 이동하면 VMwareTools-10.3.21-14772444.tar.gz 파일을 확인할 수 있습니다.해당 파일을 root 계정의 home으로 복사한 후 아래의 명령을 이용하여 해당 파일의 압축을 풀고 설치 shell script를 실행하면 VMware tool을 설치할 수 있습니다.  tar zxvf VMwareTools-10.3.21-14772444.tar.gzVMware Tool가 설치되어야 /mnt/hgfs폴더가 생성되고 그 안에 윈도우에서 공유한 공유폴더가 보여지게 됩니다..Java 파일을 얻었으면 압축을 풀고 /usr/local/java 폴더로 Java Home을 설정합니다.vi를 이용해서 /etc/profile에 다음의 내용을 추가합니다.export JAVA_HOME=/usr/local/javaexport HADOOP_HOME=/usr/local/hadoopexport CLASSPATH=$JAVA_HOME/lib:$CLASSPATHPATH=$PATH:$JAVA_HOME/bin:$HADOOP_HOME/bin:$HADOOP_HOME/sbin변경된 profile을 적용시켜야 합니다.  source /etc/profileJava가 정상적으로 설치됬는지 확인합니다.  java -versionVMWARE CentOS 7 복사Hadoop을 사용하기 위해서 서버 4개를 이용할 것입니다. 설치가 끝나면 생성된 가상머신에서 마우스 오른쪽클릭을 하면 메뉴가 나오는데 Manage &gt; Clone...을 선택합니다.Create a full clone을 선택 후 가상 머신 이름을 입력합니다. Hadoop02 ~ Hadoop04까지 3개를 생성합니다.HadoopHadoop은 Apache 최상위 오픈소스 프로젝트로 대용량의 데이터를 저장하고 분석하고 처리하기 위한 framework입니다.Hadoop의 특징은 다음과 같습니다.      선형적인 확장성 제공 : 일반적인 스토리지는 초기에 애플리케이션에서 사용할 용량을 예측하여 미리 스토리지 용량을 확보한 상태에서 시스템이 오픈되나, Hadoop을 이용할 경우에는 서비스 초기에 필요한 수준으로만 스토리지 용량을 확보해 시스템을 오픈한 후 데이터 증가 추이를 보면서 스토리지를 추가하는 방식으로 진행합니다.        데이터 분석 처리에 활용 : 분석용 데이터를 HDFS에 저장하고, Map/Reduce라는 분산/병렬 처리 프레임워크를 데이터 분석하는데 사용합니다.        API 기반의 파일 처리 시스템 : 일반적인 파일시스템처럼 운영체제에서 제공하는 파일처리 명령을 이용할 수 없고, Hadoop을 이용하는 애플리케이션은 Hadoop에서 제공하는 명령어나 프로그램 API를 이용해야 합니다.        Immutable File System : 파일은 한번 써지면 변경되지 않는다고 가정합니다. 따라서 Hadoop은 파일을 저장하고 저장된 파일에 대해 읽기 요청 위주(스트리밍 방식)인 응용이나 배치 작업 등에 적합합니다. 이런 제약 때문에 파일 처리를 주로 하는 기존 솔루션이나 시스템을 수정없이 Hadoop에 적용 할 수는 없습니다.        네임스페이스 관리를 NameNode 메모리에 저장 : 파일 시스템의 네임스페이스 정보를 NameNode의 메모리상에서 관리하기 때문에 Hadoop에 저장할 수 있는 파일과 디렉토리의 개수는 NameNode의 메모리 크기에 제한을 받게됩니다.        NameNode 이중화 : NameNode가 SPOF(Single Point Of Failre)입니다. NameNode에 문제가 발생하면 파일시스템 전체 클러스터에 장애가 발생하게 됩니다. 따라서 일반적으로 Secondary NameNode를 사용해야 합니다.  하둡 분산형 파일시스템(Hadoop Distributed FileSystem, HDFS) 특징      HDFS는 데이터를 저장하면 다수의 노드에 복제 데이터도 함께 저장하여 데이터의 유실을 방지합니다.        HDFS에 파일을 저장하거나, 저정된 파일을 조회하려면 스트리밍 방식으로 접근해야 합니다.        한번 저장된 파일은 수정할 수 없고(2.0부터는 append가능) 읽기만 가능합니다. 따라서 데이터의 무결성을 유지할 수 있습니다.        데이터의 수정은 불가능하지만 파일이동, 삭제, 복사를 할 수 있는 인터페이스는 제공합니다.  하둡 분산형 파일시스템(Hadoop Distributed FileSystem, HDFS) 아키텍쳐      블록 구조의 파일 시스템으로, 저장하는 파일은 특정 사이즈의 블록으로 나눠져 분산된 서버에 저장됩니다.        기본적으로 HDFS 블록의 사이즈는 Hadoop 배포판에 따라서 64,128,256MB로 상이합니다. 일반적으로 물리적인디스크는 블록이라는 개념을 이용합니다. 이 블록은 한번에 읽고 쓸 수 있는 데이터의 최대량을 의미합니다. 보통의파일 시스템의 블록크기는 수 KB이지만 Hadoop의 HDFS는 128MB와 같이 굉장히 큰 단위입니다.이렇게 큰 단위를 사용하는 이유는 데이터 탐색에 대한 비용을 최소화하기 위해서 입니다. 블록이 크면 블록의 시작점을탐색하는데 시간이 적게 걸리고 데이터를 전송하는데 더 많은 시간을 할당해 줄 수 있기 때문입니다.또한 HDFS 파일은 블록 크기보다 작은 데이터일 경우 전체 블록 크기에 해당하는 하위 디스크를 모두 점유하지는 않습니다.즉, 블록의 크기가 128MB이고 1MB의 데이터를 저장한다면 128MB의 디스크를 사용하는게 아니라 1MB의 디스크만을 사용합니다.        하나의 블록은 기본적으로 3개(변경가능)로 복제되며 각각 다른 HDFS의 노드에 분산저장됩니다.        HDFS는 Master 역할을 하는 NameNode 서버 한 대와, Slave 역할을 하는 DataNode 서버 여러 대로 구성됩니다.        NameNode는 HDFS의 모든 메타데이터(블록들이 저장되는 디렉토리의 이름, 파일명등)를 관리하고, HDFS 클라이언트가 이를 이용하여 저장된 파일에 접근할 수 있습니다.        Hadoop 어플리케이션은 HDFS에 파일을 저장하거나, 저장된 파일을 읽기 위해 HDFS 클라이언트를 사용하며, 클라이언트는 API형태로 사용자에게 제공합니다.        DataNode는 주기적으로 NameNode에게 블록 리포트(노드에 저장되어 있는 블록의 정보)를 전송하고 이를 통해 NameNode는 DataNode가 정상 동작하는지 확인합니다.        HDFS 클라이언트는 NameNode에 접속해서 원하는 파일이 저장된 블록의 위치를 확인하고, 해당 블록이 저장된 DataNode에서 직접 데이터를 조회합니다.  하둡 분산형 파일시스템(Hadoop Distributed FileSystem, HDFS) 파일 저장 Flow      어플리케이션이 HDFS 클라이언트에게 파일 저장을 요청하면, HDFS 클라이언트는 NameNode에게 파일 블록들이 저장될 경로 생성을 요청합니다. NameNode는 해당 파일 경로가 존재하지 않으면 경로를 생성한 후, 다른 클라이언트가 해당 경로를 수정하지 못하도록 Lock을 설정합니다. 그 후, NameNode는 클라이언트에게 해당 파일 블록들을 저장할 DataNode의 목록을 반환합니다.        클라이언트는 첫 번째 DataNode에게 데이터를 전송합니다.        첫 번째 DataNode는 데이터를 로컬에 저장한 후, 데이터를 두 번째 DataNode로 전송합니다.        두 번째 DataNode는 데이터를 로컬에 저장한 후, 데이터를 세 번째 DataNode로 전송합니다.        로컬에 데이터를 저장하였으면 자기에게 데이터를 넘겨준 DataNode에게 데이터의 로컬 저장이 완료 되었음을 응답(Ack)합니다.        로컬에 데이터를 저장하였으면 자기에게 데이터를 넘겨준 DataNode에게 데이터의 로컬 저장이 완료 되었음을 응답(Ack)합니다.        첫 번째 DataNode는 클라이언트에게 파일 저장이 완료 되었음을 응답합니다.  하둡 분산형 파일시스템(Hadoop Distributed FileSystem, HDFS) 파일 읽기 Flow      어플리케이션이 클라이언트에게 파일 읽기를 요청합니다.        클라이언트는 NameNode에게 요청된 파일이 어떤 블록에 저장되어 있는지 정보를 요청합니다.        메타데이터를 통해 파일이 저장된 블록 리스트를 반환합니다.        클라이언트는 DataNode에 접근하여 블록 조회 요청합니다.        DataNode는 클라이언트에게 요청된 블록을 전송합니다.        클라이언트를 어플리케이션에 데이터를 전달합니다.  MapReduce(맵리듀스)대용량의 데이터처리를 위한 분산 프로그래밍 모델이자 software framework입니다. 대량의 데이터를병렬로 분석할 수 있으며 프로그래머는 Map과 Reduce라는 두 개의 method를 직접 작성해서 구성합니다.      Map : 흩어져 있는 데이터를 연관성이 있는 데이터로 key,value형태로 분류하는 작업을 지칭합니다.        Reduce : Map에서 출력된 데이터에서 중복된 데이터를 제거하고 원하는 데이터를 추출하른 작업을 수행합니다.  아래의 그림은 문자열 데이터에 포함된 단어의 빈도수를 출력해주는 과정입니다.      Splitting : 문자열 데이터를 라인별로 나눕니다.        Mapping : 라인별로 문자열을 입력받아, &lt;key, value&gt; 형태로 출력합니다.        Intermediate Splitting(Shuffling) : 같은 key를 가지는 데이터끼리 분류합니다.        Reducing : 각 key 별로 빈도수를 합산해서 출력합니다.        Combining : Reduce 메소드의 출력 데이터를 합쳐서 HDFS에 저장합니다.  CentOS 7에 Hadoop 설치4대의 서버로 진행합니다.  Hadoop01 : NameNode (host명 : namenode)  Hadoop02 : DataNode (host명 : datanode01)  Hadoop03 : DataNode (host명 : datanode02)  Hadoop04 : DataNode (host명 : datanode03)Hadoop의 설치 모드는 총 3개가 있습니다.  Standalone : 단일 Node로 사용합니다. 테스트 및 디버깅 용도입니다.  Pseudo distributed : 단일 Node에서 Cluster를 구성합니다.  Full distributed : 두 대 이상의 Node를 CLuster로 구성합니다.여기서는 3번째 Full distributed 방식으로 진행하며 Hadoop의 버전은 2.9.2버전을 사용합니다.참고 : 암호화 방식  대칭키 암호화 방식암호화를 위해서는 기본적으로 암호화의 대상이 되는 평서문(Plain Text)과 암호화를 위한 일종의 비밀번호인 암호키(Cryptography Key) 그리고 마지막으로 암호화 알고리즘(Algorithm)이 필요한데, 대칭키 암호화 방식은 문자 그대로 암호화와 복호화를 동일한 암호키를 이용하는 방식입니다.위의 그림을 통해 살펴보면 동일한 암호키를 통해 암호화(Encryption), 복호화(Decryption)하는 것을 볼 수 있는데, 대칭키를 사용하는 암호화 알고리즘은 AES와 DES가 대표적입니다.  RSA를 이용한 암호화RSA는 공개키를 이용하는 대표적인 암호화 방식이며 전자서명이 가능한 최초의 알고리즘으로 알려져 있습니다. AES, DES와 같은 대칭키 암호화 방식에서 발생하는 문제점을 해결하였습니다. 과거의 암호 방식은 암호화를 위한 키뿐만 아니라 알고리즘 역시 노출되지 않기 위해 노력하였으나 현대의 암호에서는 알고리즘을 공개하도록 하고 있습니다. 키 이외에 암호 시스템의 모든 것이 공개되어도 안전해야 한다고 Kerckhoff라는 사람이 주장 했는데 이것을 Kerckhoff의 법칙이라고 합니다.RSA는 수학적인 기법을 통해 한 쌍의 공개키와 비밀키를 생성하는데, 각각의 키는 이론적으로 다음과 같은 용도로사용됩니다.Public Key : 누구에게나 공개될 수 있으며 메세지를 보내는 발신자는 공개키를 통해 정보를 암호화한다.Private Key : 수신자는 비밀키를 암호화된 메세지를 복호화 하는데 사용한다. 외부에 노출되지 않도록 안전하게 보관해야 한다.이와 같이 RSA를 이용한 공개키 암호화 방식은 비밀키(Private Key)를 외부에 노출할 위험이 없어 기존의 대칭키 암호화 방식의 문제를 해결할 수 있습니다.SSH 설정각 서버의 IP address를 알아야 합니다. ifconfig를 이용하여 각 Host의 ip address를 파악합니다.  Hadoop01 : 192.168.64.128  Hadoop02 : 192.168.64.129  Hadoop03 : 192.168.64.130  Hadoop04 : 192.168.64.131각 서버마다 /etc/hosts 파일을 편집해서 아래의 내용을 넣어줍니다.192.168.64.128 namenode192.168.64.129 datanode01192.168.64.130 datanode02192.168.64.131 datanode03각 서버마다 /etc/hostname 파일을 편집해서 각 host의 이름을 입력합니다.  192.168.64.128 =&gt; namenode  192.168.64.129 =&gt; datanode01  192.168.64.130 =&gt; datanode02  192.168.64.131 =&gt; datanode03수정이 끝났으면 재부팅을 해줍니다.(서비스를 다시 시작해도 됩니다.)Hadoop은 클러스터간에 내부 통신에 SSH(Secure Shell) 프로토콜을 이용합니다. 따라서 패스워드 인증과정없이SSH 통신을 하기 위해 SSH 공개키를 설정하고 모든 서버에 통합 공개키를 복사하여 통신을 합니다.각 서버에서 인증키를 생성합니다.  ssh-keygen입력을 요구하는 부분이 있는데 그냥 enter를 입력해도 무방합니다.모든 서버에서 이 작업을 수행하면 각 서버의 /root/.ssh/ 안에 2개의 파일이 생성됩니다.  id_rsa : 생성된 개인키(private key)입니다.  id_rsa.pub : 생성된 공개키(public key)입니다.먼저 namenode에서 다음의 명령을 이용해 authorized_keys 파일을 생성합니다. namenode의 공개키를authorized_keys 파일에 저장합니다.  cp id_rsa.pub authorized_keysnamenode의 .ssh 폴더안에 authorized_keys 파일이 생성됩니다.ssh-copy-id 유틸리티를 이용해서 datanode01 ~ datanode03에서 각자의 공개키를 namenode에 복사합니다.  ssh-copy-id root@namenode (모든 datanode에서 각각 수행해야 합니다.)각 datanode(01~03)에서 namenode로 공개키를 복사하면 namenode의 authorized_keys의 내용은 아래 그림처럼저장되게 됩니다.이제 통합된 key를 각각의 서버에 보내주면 됩니다.  scp -rp authorized_keys root@datanode01:~/.ssh/authorized_keys  scp -rp authorized_keys root@datanode02:~/.ssh/authorized_keys  scp -rp authorized_keys root@datanode03:~/.ssh/authorized_keys다음의 명령을 이용해서 각 서버에서 다른 서버로 SSH Connection을 설정합니다. 정상적으로 Connection이 설정되면 패스워드 없이 ssh 호출이 정상적으로 이루어집니다.  ssh datanode01 date방화벽 설정(방화벽 shutdown)CentOS의 경우 OS를 처음 설치했을 때 기본 포트를 제외한 모든 포트를 방화벽에서 막고 있습니다.Hadoop은 내부 데몬(NameNode, SecondaryNameNode, DataNode, JobTracker, TaskTracker)간에 통신을 위해 다양한 포트를 사용합니다. 만약 Hadoop이 사용하는 포트가 막혀 있다면, Hadoop은 구동했더라도 HDFS 파일 제어나 MapReduce Job이 정상적으로 실행되지 않게 됩니다.이러한 현상을 피하기 위해서는 사용되는 Hadoop의 포트를 열어줘야 합니다.(이 부분은 Hadoop의 공식문서를 참조합니다.)포트를 하나하나 일일이 변경하고 열어주는 일은 상당히 번거로운 작업이고 대부분은 Hadoop이 사내 내부망으로만 설치가 되어 있기 때문에 다음과 같이 방화벽을 내려주시는 게 가장 간단한 방법입니다.  systemctl stop firewalld  systemctl disable firewalldHadoop 다운로드 및 설치Apache site에서 Hadoop 2.9.2 버전을 다운로드 합니다.다운로드 한 binary 압축 파일을 CentOS로 가져옵니다. 이 부분은 namenode에서만 작업합니다.  tar xvf hadoop-2.9.2.tar.gz  mv hadoop-2.9.2 /usr/local/hadoopHadoop에서 사용할 디렉토리를 생성합니다. 디렉토리 생성은 모든 서버에서 수행해야 합니다.  mkdir -p /home/hadoop/hdfs/data  mkdir -p /home/hadoop/hdfs/temp  mkdir -p /home/hadoop/hdfs/name이제 Hadoop의 환경설정을 진행합니다. 이 환경설정은 namenode에서만 진행하고 설정이 다 끝나면 다른 서버로배포하게 됩니다.Hadoop의 환경설정 파일은 /usr/local/hadoop/etc/hadoop/ 안에 위치하고 있습니다.설정이 끝난 환경설정파일은 여기에서 다운로드 받을 수 있습니다.hadoop-env.sh 파일을 vi로 열어서 JAVA_HOME에 대한 환경변수를 우리 환경에 맞게 수정합니다.hadoop-env.sh 파일의 상단에 다음 내용을 추가하여 아래 그림과 같이 환경변수를 설정합니다.export HADOOP_HOME_WARN_SUPPRESS=1export HADOOP_HOME=/usr/local/hadoopexport HADOOP_MAPRED_HOME=$HADOOP_HOMEexport HADOOP_COMMON_HOME=$HADOOP_HOMEexport HADOOP_HDFS_HOME=$HADOOP_HOMEexport YARN_HOME=$HADOOP_HOMEexport HADOOP_CONF_DIR=$HADOOP_HOME/etc/hadoopexport YARN_CONF_DIR=$HADOOP_HOME/etc/hadoopyarn-env.sh 파일의 상단에도 다음 내용을 추가합니다.export HADOOP_HOME=/usr/local/hadoopexport HADOOP_MAPRED_HOME=$HADOOP_HOMEexport HADOOP_COMMON_HOME=$HADOOP_HOMEexport HADOOP_HDFS_HOME=$HADOOP_HOMEexport YARN_HOME=$HADOOP_HOMEexport HADOOP_CONF_DIR=$HADOOP_HOME/etc/hadoopexport YARN_CONF_DIR=$HADOOP_HOME/etc/hadoopmasters 파일이 존재하지 않는데 vi로 만들어서 secondary namenode를 지정해줍니다.datanode01slaves 파일을 vi로 열어서 기존 내용을 삭제하고 datanode 들의 서버를 지정해줍니다.다음의 내용을 입력합니다.datanode01datanode02datanode03core-site.xml 파일을 열어 property 내용을 적어줍니다.(hive사용을 위한 설정도 들어가 있습니다.)&lt;configuration&gt;        &lt;property&gt;                &lt;name&gt;fs.defaultFS&lt;/name&gt;                &lt;value&gt;hdfs://namenode:9000&lt;/value&gt;        &lt;/property&gt;        &lt;property&gt;                &lt;name&gt;hadoop.tmp.dir&lt;/name&gt;                &lt;value&gt;/home/hadoop/hdfs/temp&lt;/value&gt;        &lt;/property&gt;        &lt;property&gt;                &lt;name&gt;hadoop.proxyuser.hive.hosts&lt;/name&gt;                &lt;value&gt;*&lt;/value&gt;        &lt;/property&gt;        &lt;property&gt;                &lt;name&gt;hadoop.proxyuser.hive.groups&lt;/name&gt;                &lt;value&gt;*&lt;/value&gt;        &lt;/property&gt;        &lt;property&gt;                &lt;name&gt;hadoop.proxyuser.root.hosts&lt;/name&gt;                &lt;value&gt;*&lt;/value&gt;        &lt;/property&gt;        &lt;property&gt;                &lt;name&gt;hadoop.proxyuser.root.groups&lt;/name&gt;                &lt;value&gt;*&lt;/value&gt;        &lt;/property&gt;&lt;/configuration&gt;hdfs-site.xml 파일을 열어 다음과 같이 수정합니다.&lt;configuration&gt;        &lt;property&gt;                &lt;name&gt;dfs.replication&lt;/name&gt;                &lt;value&gt;3&lt;/value&gt;        &lt;/property&gt;        &lt;property&gt;                &lt;name&gt;dfs.namenode.name.dir&lt;/name&gt;                &lt;value&gt;/home/hadoop/hdfs/name&lt;/value&gt;        &lt;/property&gt;        &lt;property&gt;                &lt;name&gt;dfs.datanode.name.dir&lt;/name&gt;                &lt;value&gt;/home/hadoop/hdfs/data&lt;/value&gt;        &lt;/property&gt;        &lt;property&gt;                &lt;name&gt;dfs.webhdfs.enabled&lt;/name&gt;                &lt;value&gt;false&lt;/value&gt;        &lt;/property&gt;        &lt;property&gt;                &lt;name&gt;dfs.namenode.http.address&lt;/name&gt;                &lt;value&gt;namenode:50070&lt;/value&gt;        &lt;/property&gt;        &lt;property&gt;                &lt;name&gt;dfs.secondary.http.address&lt;/name&gt;                &lt;value&gt;datanode01:50090&lt;/value&gt;        &lt;/property&gt;&lt;/configuration&gt;mapred-site.xml 파일을 수정합니다. 기본적으로는 mapred-site.xml 파일은 없습니다. mapred-site.xml.template을 복사하여 만든 후 수정합니다.&lt;configuration&gt;        &lt;property&gt;                &lt;name&gt;mapreduce.framework.name&lt;/name&gt;                &lt;value&gt;yarn&lt;/value&gt;        &lt;/property&gt;        &lt;property&gt;                &lt;name&gt;mapred.job.tracker&lt;/name&gt;                &lt;value&gt;namenode:54311&lt;/value&gt;        &lt;/property&gt;&lt;/configuration&gt;yarn-site.xml 파일을 수정합니다.&lt;configuration&gt;        &lt;property&gt;                &lt;name&gt;yarn.nodemanager.aux-services&lt;/name&gt;                &lt;value&gt;mapreduce_shuffle&lt;/value&gt;        &lt;/property&gt;        &lt;property&gt;                &lt;name&gt;yarn.nodemanager.aux-services.mapreduce.shuffle.class&lt;/name&gt;                &lt;value&gt;org.apache.hadoop.mapred.ShuffleHandler&lt;/value&gt;        &lt;/property&gt;        &lt;property&gt;                &lt;name&gt;yarn.resourcemanager.hostname&lt;/name&gt;                &lt;value&gt;namenode&lt;/value&gt;        &lt;/property&gt;        &lt;property&gt;                &lt;name&gt;yarn.resoucemanager.resource-tracker.address&lt;/name&gt;                &lt;value&gt;namenode:8025&lt;/value&gt;        &lt;/property&gt;        &lt;property&gt;                &lt;name&gt;yarn.resourcemanager.scheduler.address&lt;/name&gt;                &lt;value&gt;namenode:8030&lt;/value&gt;        &lt;/property&gt;        &lt;property&gt;                &lt;name&gt;yarn.resourcemanager.address&lt;/name&gt;                &lt;value&gt;namenode:8040&lt;/value&gt;        &lt;/property&gt;&lt;/configuration&gt;파일 수정이 끝났으면 Slave 들에게 설정된 Hadoop을 배포합니다.  cd /usr/local  scp -r hadoop root@datanode01:/usr/local  scp -r hadoop root@datanode02:/usr/local  scp -r hadoop root@datanode03:/usr/local/etc/profile 파일을 각 Slave 들에게 배포합니다.  scp /etc/profile root@datanode01:/etc/profile  scp /etc/profile root@datanode02:/etc/profile  scp /etc/profile root@datanode03:/etc/profile복사가 모두 끝나면 각 서버에서 Java와 Hadoop이 정상적으로 동작하는지 확인합니다.  java -version  hadoop versionHadoop 실행환경 설정 및 설치가 완료되었으니 이제 hadoop 서버를 실행합니다. 우선 실행전에 포맷을 진행합니다.이 작업은 namenode에서만 진행합니다.  hadoop namenode -format포맷이 끝났으면 ~$HADOOP_HOME/sbin/start-all.sh 으로 실행합니다. (중지는 stop-all.sh)namenode에서만 실행 하면 slaves에 등록되어 있는 모든 datanode의 데몬들도 namenode에서 구동시키므로 구동 후 각 서버에서 jps로 데몬 구동을 확인 하면 됩니다.정상적으로 실행되었는지 확인하기 위해 각 서버에서 jps(JVM 위에서 돌아가는 프로세스 확인) 명령을 수행합니다.  jpsmaster에는 ResourceManager가 구동 되어야 하고 slave들에는 NodeManager가 구동 되어야 클러스터가 정상 동작합니다.다음의 URL을 이용하면 HDFS를 확인할 수 있습니다. Live Nodes : 3 ( 3개의 slave 존재 확인 )  localhost:50070간단한 명령어를 이용해 파일 시스템을 다룰 수 있습니다.  디렉토리 생성  hadoop fs -mkdir /test  파일 업로드  hadoop fs -put (업로드 할 파일)  (타겟 디렉토리)  디렉토리 리스트 출력  hadoop fs -ls (타겟 디렉토리)참고로 Hadoop이 비정상 종료 시 safe 모드로 전환되는데 이 경우 에러가 발생합니다.이런 경우 다음의 명령을 이용해서 Safe mode를 OFF해야 합니다.  hdfs dfsadmin -safemode leave현재 모드가 Safe 모드인지 확인 하는 방법은 다음의 명령을 이용하면 됩니다.  hdfs dfsadmin -safemode get마지막으로 파일시스템을 검사할 수 있는데 다음의 명령을 이용하면 됩니다.  hdfs fsck /Hadoop ExampleHadoop File 처리가장 기본적인 예제인 File Read Write를 통해서 Hadoop 사용법을 알아보겠습니다.기본적으로 Hadoop 프로그래밍은 Maven 빌드를 사용하는데 이번에는 Maven을 사용하지 않고 직접 jar file을 다운로드 받아서처리하겠습니다. 필요한 jar파일은 hadoop-core jar파일입니다. 다운받기 위해서는 Maven Repository에 가야합니다.Maven Repository에 가서 검색창에 hadoop core를 입력하고 검색하면 hadoop-core-1.2.1.jar 파일을 다운로드 받을 수 있습니다.이 파일을 우리 Eclipse project의 적당한 곳에 복사한 후 Build Path 설정에서 라이브러리로 등록합니다.다음의 코드를 작성합니다.public class Exam01_SimpleFileReadWrite {\tpublic static void main(String[] args) {            if (args.length != 2) {                System.out.println(\"Usage : Exam01_SimpleFileReadWrite &lt;filename&gt; &lt;contents&gt;\");                System.out.println();            }            Configuration conf = new Configuration();            // Configuration class는 Hadoop의 설정값을 가져온다.             // Hadoop xml 설정값들을 확인.            try {                FileSystem hdfs = FileSystem.get(conf);                // FileSystem은 Hadoop의 FileSystem.                 // Hadoop의 설정값을 보고 파일시스템을 가져온다.                Path path = new Path(args[0]);                if (hdfs.exists(path)) {                    hdfs.delete(path, true);                }                // 파일 시스템을 가져온후 출력 스트림을 열어서 args[0]이름으로 파일을 생성한다.                 // 그후 args[1]을 파일 내용으로 저장한다.                // 그 후 다시 입력 스트림을 열어서 HDFS에서 해당 파일을 가져온 후 그 내용을 출력.                FSDataOutputStream outStream = hdfs.create(path);                outStream.writeUTF(args[1]);                outStream.close();                    FSDataInputStream inputStream = hdfs.open(path);                String inputString = inputStream.readUTF();                inputStream.close();                System.out.println(\"읽은 내용 : \" + inputString);            } catch (IOException e) {                e.printStackTrace();            }\t}}이제 우리 Project를 jar 파일로 export 시킵니다. 해당 jar파일을 yarn을 이용해서 실행하는 과정을 거쳐야 합니다. yarn은 작업을 실행해주는 모듈입니다.yarn (실행시킬 타입) (실행시킬 파일 이름) (실행시킬 클래스경로) [-옵션]  yarn jar FileReadWriteExam.jar javaHadoop.Exam01_SimpleFileReadWrite test.txt HelloWorldMapReduce이번에는 Hadoop의 데이터 처리 기술인 MapReduce에 대해서 알아보겠습니다. 사실 MapReduce개념은 Hadoop의 고유개념은아니고 데이터 처리 솔루션들은 대부분 가지고 있는 기술입니다.MapReduce는 Map과 Reduce 두 개의 기능으로 나뉘며 Map은 특정 데이터를 가져와서 Key와 Value의 쌍으로 만드는일을 합니다. Reduce는 Map에서 묶은 Key와 Value을 이용해서 내가 필요한 정보로 다시 Key와 Value의 쌍으로데이터를 조작하는 것을 의미합니다.여기서는 WordCount라는 아주 유명한 입문 예제를 가지고 MapReduce를 이해해 보도록 하겠습니다.MapReduce작업을 위해서는 반드시 3가지의 클래스가 필요합니다. 이는 각각 Mapper와 Reducer 그리고 Driver입니다.Driver는 자바의 entry point인 main method가 포함된 class를 지칭합니다.먼저 Mapper class를 살펴보겠습니다.class WordCountMapper extends Mapper&lt;LongWritable, Text, Text, IntWritable&gt; {    private final static IntWritable one = new IntWritable(1);    private Text word = new Text();    @Override    protected void map(LongWritable key, Text value,     \t\tMapper&lt;LongWritable, Text, Text, IntWritable&gt;.Context context)            throws IOException, InterruptedException {        StringTokenizer itr = new StringTokenizer(value.toString());        while (itr.hasMoreTokens()) {            word.set(itr.nextToken());            context.write(word, one);        }    }}Mapper class는 4개의 인자를 받습니다.MapReduce에서의 인자는 일반 long형이나 int형, String형을 쓰지 않습니다. 대신 long이나 int형은 각각 LongWritable, IntWritable이라는 Hadoop 전용 자료형을 사용합니다.그리고 String은 Text로 사용합니다.Mapper class의 인자는 순서대로 Input Key, Input Value, Output Key, Output Value를 의미합니다.Input으로 들어오는것 역시 Key와 Value쌍이고 Output 역시 Key와 Value쌍 입니다.일반적으로 Input의 경우 Key는 LongWritable이고 Value는 Text로 고정되는 경향이 있습니다.원래 Input에는 Key값이 있을리가 없습니다. 그런데 값이 들어올때 Hadoop은 개행 단위로 끊어서 값을 받아오고 그 순서대로 번호를 매기게 됩니다. 그리고 그 번호의 값이 Key가 됩니다. 따라서 Key값은 숫자가 되고 빅데이터 처리에서 데이터량이 많을 수 있으므로 LongWritable로 사용하는 것입니다. 받는 값을 Text로 하는 이유는 가공의 편의성 때문입니다.따라서 Input의 경우 Key는 LongWritable이되고 Value는 Text가 됩니다.반면에 Output의 경우는 Key와 Value는 임의로 지정할 수 있습니다.위의 예제에서는 StringTokenizer로 공백단위로 들어온 텍스트를 끊어내고 그 값을 Output Key로 정하고 그 Value는 1로 고정해서 출력합니다.Reducer로 Key,Value 쌍을 보내는 작업은 context.write이 담당합니다.정리하자면, &lt;들어온순서, 라인단위 텍스트&gt;로 Input값이 들어오게 되고 반대로 Output은 &lt;끊은 단어,1&gt;값을 출력하게 됩니다.이번에는 Reducer class를 살펴보겠습니다.class WordCountReducer extends Reducer&lt;Text, IntWritable, Text, IntWritable&gt; {    private IntWritable result = new IntWritable();    @Override    protected void reduce(Text key, Iterable&lt;IntWritable&gt; values,                          Reducer&lt;Text, IntWritable, Text, IntWritable&gt;.Context context)                             throws IOException, InterruptedException {        int sum = 0;        for (IntWritable val : values) {            sum += val.get();        }        result.set(sum);        context.write(key, result);    }}Reduce 작업은 사실 Map 로직과 거의 동일합니다. Reducer는 Mapper의 Output을 가지고 작업을 하게 되며Reducer도 총 4개의 인자를 가지는데 Mapper와 동일합니다. 즉, Input Key, Input Value, Output Key, Output Value 입니다.당연히 Mapper의 Output 인자와 Reducer의 Input 인자는 같아야합니다.한가지 특이한점은 Reducer의 Value는 Mapper와는 다르게 복수형으로 일종의 컬렉션을 받게된다는 것입니다. 그 이유는 Key에 중복이 존재할 수 있기 때문입니다.Reducer 작업이 Mapper와 다른점이 있다면 MApper는 순서대로 값을 받으므로 Input Key는 중복될 수 없습니다.그러나 Reducer는 Mapper의 Output을 받게되는데 Mapper의 Output Key는 중복이 안된다는 제약은 없습니다.따라서 Reducer의 Input Key는 중복될 수 있습니다.Reducer의 실질적은 역활은 중복된 키들을 어떻게 처리하느냐 입니다.Mapper는 의미가 같다고 생각되는 데이터를 같은 Key로 만들어서 출력합니다. 그러면 Reducer에서는 그 동일한 Key를 묶어서 처리를 한다고 보면 됩니다.위의 예제에서 Value들은 모두 1로 고정되어있습니다. 같은 Key의 경우에 계속해서 더하게 됩니다. 즉, 들어가는 데이터에 hello라는 단어가 10개가 들어왔다고 가정해 보면 &lt;hello,1&gt;이라는 Output이 Mapper에 의해 생성될 것이고 Reducer에서는 저 hello라는 Key가 10개가 있으므로 10번 for문을 돌면서 합을 계산해 10이라는 값을 계산하게 됩니다.마지막으로 Driver class를 살펴보겠습니다.public class Exam02_WordCountMapReduce {\tpublic static void main(String[] args) throws Exception {        Configuration conf = new Configuration();        if (args.length != 2) {            System.out.println(\"Usage: Exam02_WordCountMapReduce &lt;input&gt; &lt;output&gt;\");            System.exit(2);            ;        }        Job job = new Job(conf, \"WordCount\");        job.setJarByClass(Exam02_WordCountMapReduce.class);        job.setMapperClass(WordCountMapper.class);        job.setReducerClass(WordCountReducer.class);        job.setInputFormatClass(TextInputFormat.class);        job.setOutputFormatClass(TextOutputFormat.class);        job.setOutputKeyClass(Text.class);        job.setOutputValueClass(IntWritable.class);        FileInputFormat.addInputPath(job, new Path(args[0]));        FileOutputFormat.setOutputPath(job, new Path(args[1]));        job.waitForCompletion(true);    }\t}Driver로 Mapper와 Reducer를 등록하고 실행하면 됩니다.이제 실행을 하기 위해서 샘플로 사용할 입력 파일을 하나 생성합니다. (wow_wordcount.txt)생성한 txt 파일을 Hadoop 파일 시스템에 저장합니다.  hdfs dfs -put wow_wordcount.txt다음의 명령을 이용해서 파일 시스템에 정상적으로 저장되었는지를 확인합니다.  hdfs dfs -ls작성된 프로그램(Java Project)을 jar파일로 생성한 후 yarn으로 실행시킵니다.output 결과는 텍스트가 아니라 폴더로 나오기에 확장자를 붙혀줄 필요는 없습니다.  yarn jar wordCounterExam.jar javaHadoop.Exam02_WordCountMapReduce wow_wordcount.txt output  hdfs dfs -ls outputoutput 디렉토리 안에 파일은 part-r-00000로 저장됩니다. 이 파일은 텍스트 파일이므로 cat으로 읽을 수 있습니다.다음의 명령을 이용하여 결과를 확인합니다.  hdfs dfs -cat output/part-r-00000Hive 설치 및 활용현재 서비스 로그 및 사용자 생성 데이터는 점점 크고 빠르게 늘어나고 있습니다. 우리가 설치한 Hadoop은 이런 매우 큰 데이터를 저장하고 처리하기 적합한 가장 인기 있는 오픈 소스입니다.하지만 데이터 분석을 위해 MapReduce를 직접 구현하기에는 코드가 매우 어려운 형태이며, 따라서 시스템을 구현하기 위해서는 그만한 개발 능력이 되는 개발자가 있어야 하는 등 실제 시스템을 도입해서 사용하는데는어려움도 있는게 사실입니다.그런 이유로 MapReduce 처리를 쉽게 해주기 위한 대안으로 Hive를 사용합니다. (다른 framework도 존재합니다.) Hive는 RDB의 SQL문을 작성해 본 개발자라면 상당히 익숙한 형태로 데이터 분석 작업을 진행할 수 있습니다.정리하자면, Hive는 Hadoop 상의 오픈소스 Data Warehouse 솔루션입니다.DW(Data Warehouse)는 리포팅 및 분석을 위한 Database라고 생각하면 됩니다.간단하게 Hive의 동작방법에 대해 알아보면 다음과 같습니다.Hive는 Hadoop상에서 동작합니다. 당연히 데이터 또한 HDFS에 저장되어 있습니다.Hive는 메타스토어(Metastore)라는 저장소를 만들어 Hadoop에서 처리된 메타데이터의 구조를 메타스토어에 저장합니다.하이브는 Oracle, MySQL 등 JDBC를 지원하는 모든 데이터베이스를 이용해 메타스토어를 구축할 수 있습니다.디폴트로 Apache Derby를 사용하지만, 일반적으로 MySQL이나 Postgres를 많이 사용합니다.  사용자가 제출한 SQL문을 Driver가 Compiler에 요청하여 MetaStore의 정보를 이용해 처리에 적합한 형태로 컴파일  컴파일된 SQL을 실행엔진으로 실행  리소스 매니저가 클러스터의 자원을 적절히 활용하여 실행  실행 중 사용하는 원천데이터는 HDFS등의 저장장치를 이용  실행결과를 사용자에게 반환MySQL 설치MySQL은 Hadoop namenode에 설치하겠습니다.먼저 wget을 이용해서 MySQL을 설치합니다.  wget http://repo.mysql.com/mysql-community-release-el7-5.noarch.rpm  rpm -ivh mysql-community-release-el7-5.noarch.rpm  yum install mysql-server  systemctl start mysqld  systemctl enable mysqld  systemctl status mysqldmysql_secure_installation 명령으로 기본적인 보안 설정을 합니다. 몇가지 설정을 수행합니다.root 권한으로 mysql console에 진입합니다.  mysql -u root -p일단 mysql 버전부터 확인하고 진행하겠습니다.  SHOW VARIABLES LIKE “%version%”;이제 사용자 계정을 생성합니다.  CREATE USER hive IDENTIFIED BY “hive”;  CREATE USER hive@localhost IDENTIFIED BY “hive”;이제 사용할 database를 만들고 hive 계정에 해당 database의 권한을 부여합니다.  CREATE DATABASE hivedb;  GRANT ALL PRIVILEGES ON hivedb.* TO hive;  GRANT ALL PRIVILEGES ON hivedb.* TO hive@localhost;설정된 권한을 바로 적용하고 mysql console을 종료합니다.  FLUSH PRIVILEGES;  EXIT참고 : MySQL 삭제기존 설치되어 있는 MySQL 패키지를 제거하려면 다음과 같은 명령을 사용해야 합니다.  yum remove mysql mysql-server패키지를 삭제한 후 남아있는 MySQL 디렉토리를 삭제합니다.  rm -rf /var/lib/mysqlHIVE 설치http://hive.apache.org에서 2.3.7 버젼을 다운로드 받아 압축을 풀어줍니다.  wget http://apache.mirror.cdnetworks.com/hive/hive-2.3.7/apache-hive-2.3.7-bin.tar.gz  tar -zxvf apache-hive-2.3.7-bin.tar.gz  mv apache-hive-2.3.7-bin /usr/local/hive/etc/profile을 vi로 열어서 아래의 내용을 추가합니다.export HIVE_HOME=/usr/local/hiveexport PATH=$HIVE_HOME/bin:$PATH위에서 설치한 MySQL과 연동하기 위해서 MySQL JDBC Connector를 설치합니다.  wget http://www.java2s.com/Code/JarDownload/mysql/mysql-connector-java-commercial-5.1.7-bin.jar.zip  unzip mysql-connector-java-commercial-5.1.7-bin.jar.zip  cp mysql-connector-java-commercial-5.1.7-bin.jar  $HIVE_HOME/lib/다음은 사용할 HDFS 디렉토리를 생성해야 합니다. 다음의 명령을 이용하여 HDFS 디렉토리를 생성합니다. 당연히 Hadoop이 실행되고 있는 상황이어야 합니다.  hadoop fs -mkdir /tmp  hadoop fs -mkdir -p /user/hive/warehouse  hadoop fs -chmod g+w /tmp  hadoop fs -chmod g+w /user/hive/warehouse$HIVE_HOME/conf안의 hive-env.sh.template를 hive-env.sh로 복사한 후에 HADOOP_HOME을 아래와 같이 수정합니다.  mv $HIVE_HOME/conf/hive-env.sh.template $HIVE_HOME/conf/hive-env.shHADOOP_HOME=/usr/local/hadoop$HIVE_HOME/conf안에 hive-site.xml 파일을 생성하여 생성된 내용을 입력합니다.UserName과 Password는 MySQL에서 사용하게될 UserName과 Password입니다.&lt;?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?&gt;&lt;?xml-stylesheet type=\"text/xsl\" href=\"configuration.xsl\"?&gt;&lt;configuration&gt;        &lt;property&gt;                &lt;name&gt;hive.metastore.local&lt;/name&gt;                &lt;value&gt;false&lt;/value&gt;        &lt;/property&gt;        &lt;property&gt;                &lt;name&gt;hive.metastore.warehouse.dir&lt;/name&gt;                &lt;value&gt;hdfs://namenode:9000/user/hive/warehouse&lt;/value&gt;        &lt;/property&gt;        &lt;property&gt;                &lt;name&gt;javax.jdo.option.ConnectionURL&lt;/name&gt;                &lt;value&gt;jdbc:mysql://localhost:3306/hivedb?createDatabaseIfNotExist=true&lt;/value&gt;        &lt;/property&gt;        &lt;property&gt;                &lt;name&gt;javax.jdo.option.ConnectionUserName&lt;/name&gt;                &lt;value&gt;hive&lt;/value&gt;        &lt;/property&gt;        &lt;property&gt;                &lt;name&gt;javax.jdo.option.ConnectionPassword&lt;/name&gt;                &lt;value&gt;hive&lt;/value&gt;        &lt;/property&gt;        &lt;property&gt;                &lt;name&gt;hive.metastore.schema.verification&lt;/name&gt;                &lt;value&gt;false&lt;/value&gt;        &lt;/property&gt;        &lt;property&gt;                &lt;name&gt;hive.server2.thrift.port&lt;/name&gt;                &lt;value&gt;10000&lt;/value&gt;                &lt;description&gt;TCP port number to listen on, default 10000&lt;/description&gt;        &lt;/property&gt;        &lt;property&gt;                &lt;name&gt;hive.server2.enable.doAs&lt;/name&gt;                &lt;value&gt;false&lt;/value&gt;        &lt;/property&gt;        &lt;property&gt;                &lt;name&gt;hive.server2.authentication&lt;/name&gt;                &lt;value&gt;NONE&lt;/value&gt;        &lt;/property&gt;        &lt;property&gt;                &lt;name&gt;hive.metastore.sasl.enabled&lt;/name&gt;                &lt;value&gt;false&lt;/value&gt;                &lt;description&gt;If true, the metastore Thrift interface will be secured with SASL.                        Clients must authenticate with Kerberos.&lt;/description&gt;        &lt;/property&gt;        &lt;property&gt;                &lt;name&gt;hive.server2.enable.impersonation&lt;/name&gt;                &lt;description&gt;Enable user impersonation for HiveServer2&lt;/description&gt;                &lt;value&gt;true&lt;/value&gt;        &lt;/property&gt;        &lt;property&gt;                &lt;name&gt;hive.server2.thrift.bind.host&lt;/name&gt;                &lt;value&gt;192.168.64.128&lt;/value&gt;        &lt;/property&gt;        &lt;property&gt;                &lt;name&gt;hive.support.concurrency&lt;/name&gt;                &lt;value&gt;true&lt;/value&gt;        &lt;/property&gt;        &lt;property&gt;                &lt;name&gt;hive.enforce.bucketing&lt;/name&gt;                &lt;value&gt;true&lt;/value&gt;        &lt;/property&gt;        &lt;property&gt;                &lt;name&gt;hive.exec.dynamic.partition.mode&lt;/name&gt;                &lt;value&gt;nonstrict&lt;/value&gt;        &lt;/property&gt;        &lt;property&gt;                &lt;name&gt;hive.txn.manager&lt;/name&gt;                &lt;value&gt;org.apache.hadoop.hive.ql.lockmgr.DbTxnManager&lt;/value&gt;        &lt;/property&gt;        &lt;property&gt;                &lt;name&gt;hive.compactor.initiator.on&lt;/name&gt;                &lt;value&gt;true&lt;/value&gt;        &lt;/property&gt;        &lt;property&gt;                &lt;name&gt;hive.compactor.worker.threads&lt;/name&gt;                &lt;value&gt;2&lt;/value&gt;        &lt;/property&gt;&lt;/configuration&gt;HIVE 실행Hive 2.1부터는 초기화 단계로 아래의 코드를 실행해야 합니다.실행한 뒤 schemaTool completed가 출력되면 됩니다.  schematool -dbType mysql -initSchema초기화가 정상적으로 진행되면 hive 명령을 실행합니다.정상적으로 동작하는지 확인하기 위해 Hive QL을 이용하여 Table을 생성하고 조회합니다.  CREATE TABLE mytbl(seq INT, contents STRING);  SELECT * FROM mysqlMySQL Server에 접속해서 생성된 Table이 존재하는지 확인합니다.  show databases;  show tables;  SELECT * FROM hivedb.TBLS;HIVE java 연동먼저 Host PC의 Eclipse에서 작성된 Java 프로그램이 VMware로 생성한 Hadoop01 가상머신에 내부 IP를 이용하여접속이 가능하도록 VMware의 Edit &gt; Virtual Network Editor를 선택합니다.설정을 바꾸기 위해 하단의 change settings를 클릭합니다.아래의 그림과 같이 VMnet8을 선택한 후 connect a host virtual adapter to this network 체크박스를 체크합니다.Host PC의 네트워크 설정을 살펴보면 다음과 같이 표현됩니다.자바 프로그램에서 Hive에 접근할 수 있게 Hive를 기동합니다.  hiveserver2Host PC의 Eclipse에서 Maven Project를 생성합니다.&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"  xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt;  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;  &lt;groupId&gt;test.bbb&lt;/groupId&gt;  &lt;artifactId&gt;SampleTest&lt;/artifactId&gt;  &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;  &lt;packaging&gt;jar&lt;/packaging&gt;  &lt;name&gt;SampleTest&lt;/name&gt;  &lt;url&gt;http://maven.apache.org&lt;/url&gt;  &lt;properties&gt;    &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;  &lt;/properties&gt;  &lt;dependencies&gt;    &lt;dependency&gt;      &lt;groupId&gt;junit&lt;/groupId&gt;      &lt;artifactId&gt;junit&lt;/artifactId&gt;      &lt;version&gt;3.8.1&lt;/version&gt;      &lt;scope&gt;test&lt;/scope&gt;    &lt;/dependency&gt;    &lt;dependency&gt;            &lt;groupId&gt;org.apache.hive&lt;/groupId&gt;            &lt;artifactId&gt;hive-jdbc&lt;/artifactId&gt;            &lt;version&gt;0.12.0&lt;/version&gt;\t&lt;/dependency&gt;\t&lt;dependency&gt;            &lt;groupId&gt;jdk.tools&lt;/groupId&gt;            &lt;artifactId&gt;jdk.tools&lt;/artifactId&gt;            &lt;version&gt;1.8.0_221&lt;/version&gt;\t            &lt;scope&gt;system&lt;/scope&gt;            &lt;systemPath&gt;C:/Program Files/Java/jdk1.8.0_221/lib/tools.jar&lt;/systemPath&gt;\t\t&lt;/dependency&gt;\t&lt;dependency&gt;                                                                                                                                           \t&lt;groupId&gt;org.apache.hadoop&lt;/groupId&gt;                                                                                                               \t&lt;artifactId&gt;hadoop-common&lt;/artifactId&gt;                                                                                                             \t&lt;version&gt;3.2.0&lt;/version&gt;                                                                                            \t&lt;/dependency&gt;    &lt;/dependencies&gt;&lt;/project&gt; 일반적은 JDBC 코드를 작성합니다.public class App {\tpublic static void main(String[] args) {        Connection conn = null;        ResultSet rs = null;               try {                       String driver = \"org.apache.hive.jdbc.HiveDriver\";            Class.forName(driver);                       String url = \"jdbc:hive2://192.168.64.128:10000/hivedb\";            String id = \"hive\";            String pw = \"hive\";                       conn = DriverManager.getConnection(url, id, pw);                       String sql = \"SELECT count(*) FROM mytbl\";            Statement stmt = conn.createStatement();            rs = stmt.executeQuery(sql);                       while(rs.next()){                int col = rs.getInt(1);                                       System.out.println( \"결과 : \" + col);            }                       rs.close();            conn.close();                   } catch(Exception ex){            ex.printStackTrace();        } finally {            try{                if( rs != null ){                    rs.close();                               }                if( conn != null ){                    conn.close();                               }                            } catch(Exception ex){                rs = null;                conn = null;            }        }    }}End.",
        "url": "/hadoop"
    }
    ,
    
    "r-lecture-r-database": {
        "title": "R 기초강의(22) - R 정형데이터 처리",
            "author": "moon9342",
            "category": "",
            "content": "R 강좌는 여러 절로 구성되어 있습니다.     R 기초강의(1) - R 개요    R 기초강의(2) - R Operator    R 기초강의(3) - R Data Type    R 기초강의(4) - R 패키지와 함수    R 기초강의(5) - R 자료구조(vector)    R 기초강의(6) - R 자료구조(matrix)    R 기초강의(7) - R 자료구조(factor, list)    R 기초강의(8) - R 자료구조(data frame)    R 기초강의(9) - R 문자열 처리    R 기초강의(10) - R 데이터 입출력    R 기초강의(11) - R 제어문 및 함수    R 기초강의(12) - R 기초 Exercise    R 기초강의(13) - R Crawling    R 기초강의(14) - R 데이터 조작    R 기초강의(15) - R 데이터 조작 실습    R 기초강의(16) - R 데이터 정제    R 기초강의(17) - R 기초 통계 함수    R 기초강의(18) - R Graph    R 기초강의(19) - R KoNLP    R 기초강의(20) - R 연습문제    R 기초강의(21) - R ggmap    R 기초강의(22) - R 정형데이터 처리R 정형데이터 처리R을 이용하여 분석할 수 있는 데이터의 형태는 정형화 정도에 따라 크게 3가지로분류할 수 있습니다.정형 데이터 : 고정된 필드에 저장된 데이터를 의미합니다. 주로 Database에 저장된데이터를 지칭합니다.반정형 데이터 : 태그를 포함하는 웹문서(HTML,XML)를 의미합니다.비정형 데이터 : 고정된 필드에 저장되어 있지 않은 데이터(일반 텍스트)를 의미합니다.이번에는 DBMS를 이용하여 Database안에 저장된 정형 데이터를 R에서 처리하는 과정을살펴보겠습니다. 사용하는 예제는 기존에 MySQL에 구축한 도서 데이터를 이용하겠습니다.# 정형 데이터 처리# MySQL Database 처리# 기존의 MySQL DBMS server를 기동하자# mysqld# R에서 MySQL DBMS에 연동하기 위해서는 몇가지 package가 필요install.packages(\"rJava\")  # Java 기능을 이용install.packages(\"DBI\")    # R Database Interfaceinstall.packages(\"RJDBC\")  # JDBC 기능을 위한 packagelibrary(rJava)library(DBI)library(RJDBC)# JRE 경로 설정Sys.setenv(JAVA_HOME=\"C:/Program Files/Java/jre1.8.0_221\")# 드라이버 설정drv = JDBC(driverClass = \"com.mysql.jdbc.Driver\",           classPath = \"C:/R_workspace/R_Lecture/mysql-connector-java-5.1.7-bin.jar\")# Database 연결conn &lt;- dbConnect(drv,                  \"jdbc:mysql://localhost:3306/library\",                  \"data\",                  \"data\")# Query 실행sql = \"select btitle from book\"bookTitle &lt;- dbGetQuery(conn, sql)head(bookTitle)sql = \"select btitle,bprice from book\"books &lt;- dbGetQuery(conn, sql)head(books)sql = \"select btitle,bprice from book where bprice &gt; 30000\"books &lt;- dbGetQuery(conn, sql)head(books)library(stringr)sql = str_c(\"select btitle,bprice \",            \"from book \",            \"where bprice &gt; 30000 \",            \"order by bprice desc\")books &lt;- dbGetQuery(conn, sql)head(books)# 데이터베이스 연결 종료dbDisconnect(conn)End.이 포스트의 내용은 아래의 책과 사이트를 참조했습니다.    조금 더 자세한 사항을 알고 싶으시면 책을 참조하거나 해당 사이트를 방문하세요!!    Do It! 쉽게 배우는 R 데이터 분석 저자 GitHub",
        "url": "/R-lecture-R-database"
    }
    ,
    
    "r-lecture-r-ggmap": {
        "title": "R 기초강의(21) - R ggmap",
            "author": "moon9342",
            "category": "",
            "content": "R 강좌는 여러 절로 구성되어 있습니다.     R 기초강의(1) - R 개요    R 기초강의(2) - R Operator    R 기초강의(3) - R Data Type    R 기초강의(4) - R 패키지와 함수    R 기초강의(5) - R 자료구조(vector)    R 기초강의(6) - R 자료구조(matrix)    R 기초강의(7) - R 자료구조(factor, list)    R 기초강의(8) - R 자료구조(data frame)    R 기초강의(9) - R 문자열 처리    R 기초강의(10) - R 데이터 입출력    R 기초강의(11) - R 제어문 및 함수    R 기초강의(12) - R 기초 Exercise    R 기초강의(13) - R Crawling    R 기초강의(14) - R 데이터 조작    R 기초강의(15) - R 데이터 조작 실습    R 기초강의(16) - R 데이터 정제    R 기초강의(17) - R 기초 통계 함수    R 기초강의(18) - R Graph    R 기초강의(19) - R KoNLP    R 기초강의(20) - R 연습문제    R 기초강의(21) - R ggmap    R 기초강의(22) - R 정형데이터 처리R ggmap구글 지도 서비스를 활용할 수 있도록 도와주는 package인 ggmap에 대해서 알아보겠습니다.Google Map Platform은 Googl API Key를 이용해야 합니다. 따라서 추가적인 몇가지 package를 설치하고 로드해야 합니다.## Google Map Platform을 사용해보자# 사용하고 있는 R 버전 확인# 현재 3.6.1을 사용하고 있음.# 현재시점(2019.11)에서 # ggmap을 사용하려면 3.5.x 버전이 필요# 3.5.3 버전을 설치하자sessionInfo()   # 현재 3.5.3 사용# 필요한 package 설치 및 loadinstall.packages(\"devtools\")library(devtools)install_github('dkahle/ggmap', force=T)  # 3.5.3 에서는 force=T 추가library(ggmap)         # API 이용 약관에 동의해야 한다.# 생성한 Google API KeygoogleAPIKey = \"AIzaSyDb8Oqv9AqTVBFWUKyOZh1SkSv_9SeEtKI\"# API Key 인증을 하기 전에 Google Map Platform Console에서# 추가 API항목에 있는 API를 사용 설정된 API로 적용시켜야 한다.# 예) Geocoding API# Google API Key 인증register_google(key=googleAPIKey)# 서울지역의 정보를 가져온다.gg_seoul &lt;- get_googlemap(\"seoul\",maptype = \"roadmap\")ggmap(gg_seoul)################################### 위의 내용이 성공했다면 # 특정위치를 지정해서 library(dplyr)library(ggplot2)geo_code = geocode(enc2utf8(\"공덕역\"))geo_data = as.numeric(geo_code)  # vector로 변환get_googlemap(center = geo_data,              maptype = \"roadmap\",              zoom = 16) %&gt;%  ggmap() +   geom_point(data=geo_code,             aes(x=lon,                 y=lat),             size=5,             color=\"red\")################################### 위치정보를 가져온다addr &lt;- c(\"공덕역\",\"역삼역\")gc &lt;- geocode(enc2utf8(addr))df &lt;- data.frame(lon=gc$lon,                 lat=gc$lat)cen &lt;- c(mean(df$lon),mean(df$lat))map &lt;- get_googlemap(center=cen,                     maptype=\"roadmap\",                     zoom=13,                     size=c(640,640),                     marker=gc)ggmap(map)Goolge Map Platform과 공공데이터 포털에서 제공하는 데이터를 이용하면다양한 분석내용을 지도에 표현할 수 있습니다.예를 들면지하철역 주소 정보 : 서울 열린 데이터 광장아파트 실 거래금액 데이터 : 국토교통부 실거래가 공개시스템데이터를 이용하여 서울시 지도에 가격별로 아파트 가격에 대한정보를 표현할 수 있습니다.R interactive graph인터렉티브 그래프란, 마우스 움직임에 반응하여 실시간으로 형태가 변하는 그래프를의미합니다. 인터렉티브 그래프를 이용하면 그래프를 자유롭게 조작하면서 관심있는부분을 자세히 볼 수 있습니다.이런 그래프를 HTML형식으로 저장하면 일반 사용자들도 분석된 그래프를 웹 브라우져를이용하여 그래프를 조작할 수 있습니다.사용하는 package는 plotly 입니다.# interactive graph# 필요한 package를 설치합니다.install.packages(\"plotly\")library(plotly)# ggplot2를 이용하여 만든 그래프를 plotly의 ggplotly() 함수를# 이용하면 인터렉티브 그래프가 생성됩니다. # 기존에 했던 mpg data set을 이용하여 배기량과 고속도로 연비에 대한# 산점도를 먼저 그려보겠습니다. library(ggplot2)df &lt;- as.data.frame(mpg)head(df)g &lt;- ggplot(data=df,            aes(x=displ,                y=hwy)) +   geom_point(size=2, color=\"red\")ggplotly(g) ####################### ggmap으로 처리했던 내용을 ggplotly()를 이용하여# interactive하게 만들어보자!addr &lt;- c(\"공덕역\",\"역삼역\")gc &lt;- geocode(enc2utf8(addr))df &lt;- data.frame(lon=gc$lon,                 lat=gc$lat)cen &lt;- c(mean(df$lon),mean(df$lat))map &lt;- get_googlemap(center=cen,                     maptype=\"roadmap\",                     zoom=13,                     size=c(640,640),                     marker=gc)result &lt;- ggmap(map)ggplotly(result)일반적인 그래프와는 다르게 시계열 그래프는 interactive graph를 생성할 때단순 확대, 축소 기능이 필요한게 아니라 시간축을 움직이면서 시간에 따라데이터가 어떻게 변하는지 확인하는 기능이 필요합니다.따라서 시계열 그래프는 다른 package를 이용하여 interactive graph를 생성합니다.# 시계열 그래프를 interactive하게 만들어보자# 필요한 package를 설치합니다.install.packages(\"dygraphs\")library(dygraphs)# 사용할 데이터는 시계열 데이터가 있어야 하므로# economics data set을 이용합니다.head(economics)# dygraphs를 이용하려면 데이터가 시간 순서 속성을# 지니는 xts data type으로 되어 있어야 합니다.# economics의 개인별 저축율을 xts type으로 변환합니다.library(xts)save_rate &lt;- xts(economics$psavert,                 order.by = economics$date)head(save_rate)# 시계열 그래프를 그린다.dygraph(save_rate)# 그래프 아래에 날짜 범위를 선택할 수 있는 selector를# 추가할 수 있습니다.dygraph(save_rate) %&gt;% dyRangeSelector()# 한번에 하나의 그래프를 그리는 것뿐 아니라# 여러개의 그래프를 그릴 수 있습니다.# 실업자수와 개인저축률을 시간순으로 interactive하게# 그래프로 표현해보자!# unemploy와 psavert를 xts type으로 변경# 비율을 맞춰야 한다.unemp_xts &lt;- xts(economics$unemploy/1000,                 order.by = economics$date)savert_xts &lt;- xts(economics$psavert,                  order.by = economics$date)# cbind()를 이용하여 가로로 병합하자unemp_save &lt;- cbind(unemp_xts,savert_xts)colnames(unemp_save) &lt;- c(\"실업자수\",\"개인저축률\")head(unemp_save)dygraph(unemp_save) %&gt;% dyRangeSelector()End.이 포스트의 내용은 아래의 책과 사이트를 참조했습니다.    조금 더 자세한 사항을 알고 싶으시면 책을 참조하거나 해당 사이트를 방문하세요!!    Do It! 쉽게 배우는 R 데이터 분석 저자 GitHub",
        "url": "/R-lecture-R-ggmap"
    }
    ,
    
    "r-lecture-r-exercise": {
        "title": "R 기초강의(20) - R 연습문제",
            "author": "moon9342",
            "category": "",
            "content": "R 강좌는 여러 절로 구성되어 있습니다.     R 기초강의(1) - R 개요    R 기초강의(2) - R Operator    R 기초강의(3) - R Data Type    R 기초강의(4) - R 패키지와 함수    R 기초강의(5) - R 자료구조(vector)    R 기초강의(6) - R 자료구조(matrix)    R 기초강의(7) - R 자료구조(factor, list)    R 기초강의(8) - R 자료구조(data frame)    R 기초강의(9) - R 문자열 처리    R 기초강의(10) - R 데이터 입출력    R 기초강의(11) - R 제어문 및 함수    R 기초강의(12) - R 기초 Exercise    R 기초강의(13) - R Crawling    R 기초강의(14) - R 데이터 조작    R 기초강의(15) - R 데이터 조작 실습    R 기초강의(16) - R 데이터 정제    R 기초강의(17) - R 기초 통계 함수    R 기초강의(18) - R Graph    R 기초강의(19) - R KoNLP    R 기초강의(20) - R 연습문제    R 기초강의(21) - R ggmap    R 기초강의(22) - R 정형데이터 처리R 연습문제지금까지 배운 내용을 기본으로 데이터 분석 연습문제를 풀어겠습니다.실습데이터는 한국복지패널데이터를 이용합니다. 이 데이터는 한국보건사회연구원에서전국 7000여 가구를 선정해 2006년부터 매년 추적 조사한 자료로, 경제활동, 생활실태,복지욕구등 천여 개 변수로 구성되어 있습니다.해당 데이터에는 우리나라의 다양한 삶에 대한 데이터가 들어있고 이를 분석하면 대한민국사람들이 어떻게 살아가고 있는가를 분석할 수 있습니다.# 한국복지패널데이터를 이용한 데이터 분석 연습# 1. 데이터 준비# 제공된 데이터를 이용합니다. # Koweps_hpc10_2015_beta1.sav (128M)# 상용 통계분석 소프트웨어인 SPSS 전용파일로 제공# 해당 데이터 파일은 SPSS 전용파일이기 때문에 R에서 사용하기 # 위해서 foreign package를 이용해야 합니다. install.packages(\"foreign\")library(foreign)# 사용할 package loadlibrary(dplyr)library(stringr)library(ggplot2)library(xlsx)# 데이터 불러오기# raw data 불러오기data_file = \"C:/R_workspace/R_Lecture/data/한국복지패널데이터/Koweps_hpc10_2015_beta1.sav\"raw_welfare &lt;- read.spss(file=data_file,                         to.data.frame = TRUE)head(raw_welfare)welfare &lt;- raw_welfare   # 원본 데이터 보존# 데이터 특성 확인str(welfare)   # 16664 row, 957 column # 코드북을 이용해 분석에 필요한 column의 이름을 변경합니다.welfare &lt;- rename(welfare,                  gender = h10_g3,         # 성별                  birth = h10_g4,          # 태어난 연도                  marriage = h10_g10,      # 혼인 상태                   religion = h10_g11,      # 종교                  income = p1002_8aq1,     # 월급                  code_job = h10_eco9,     # 직업 코드                  code_region = h10_reg7)  # 지역 코드# 해당 내용을 이용하여 데이터 분석을 진행해보자################################################## 1. 성별에 따른 월급 차이# 과거에 비해 여성의 사회 진출이 활발하지만 직장에서의# 위상에서는 여전히 차별이 존재하고 있는것이 사실.# 실제로 그러한지 월급의 차이를 이용하여 사실을 확인해보자table(welfare$gender)  # 남자 1, 여자 2# 1은 male, 2는 female로 변환welfare$gender &lt;- ifelse(welfare$gender == 1,\"male\",\"female\")table(welfare$gender)  # 남자 male, 여자 femaleclass(welfare$income)  # numericsummary(welfare$income) # 월평균임금. 만원단위                        # 전체적으로 122만원과 316만원 사이에 위치.                        # 중간값이 평균보다 작기 때문에 전체적으로 낮은 값 쪽으로 치우쳐 있다.# 그래프로 확인해보자( 확인할 때는 qplot이용 )qplot(welfare$income) + xlim(0,1000)# 0~250만원 사이에 가장 많은 사람이 분포하고 있다.# 결측치가 12030 존재 =&gt; 월급을 받지 않은 응답자.# 결측치부터 제거해야 한다.# 또한 값이 0 이거나 무응답에 해당하는 9999는 이상치 처리welfare$income &lt;- ifelse(welfare$income %in% c(0,9999), NA,                         welfare$income)table(is.na(welfare$income)) # NA값이 12044개gender_income &lt;- welfare %&gt;%  filter(!is.na(income)) %&gt;%  group_by(gender) %&gt;%  summarise(mean_income = mean(income))gender_income &lt;- as.data.frame(gender_income)gender_income# 그래프 그리기ggplot(data=gender_income,       aes(x=gender, y=mean_income)) +  geom_col(width=0.5) +   labs(x=\"성별\",        y=\"평균 월급\",        title=\"성별에 따른 월급차이\",       subtitle = \"남성이 여성보다 평균 월급이 150만원 많다\",       caption=\"(Example 1)\")# 결과# 남성 평균 월급 : 312.2932# 여성 평균 월급 : 163.2471# 남성이 여성보다 월급이 약 150만원 많다.# 해당 결과를 ggplot2를 이용하여 그래프로 표현하자########################################### 2. 나이와 월급의 관계# 몇 살 때 월급을 가장 많이 받을까? 또 그때의 월급은 얼마인가?# 월급을 가장 많이 받는 나이는 : 53살 월급 : 318.6777# 나이에 따른월급을 선 그래프로 표현하자class(welfare$birth)head(welfare$birth)summary(welfare$birth)qplot(welfare$birth)  # 빈도를 알아보자# 코드북에 따르면 출생연도는 1900~2014이며 무응답은 9999# 먼저 결측치가 존재하는지 확인table(is.na(welfare$birth))  # 결측치는 존재하지 않는다# 이상치를 확인한다.welfare$birth &lt;- ifelse(welfare$birth == 9999,                        NA,                        welfare$birth)table(is.na(welfare$birth))  # 이상치도 존재하지 않는다.# 나이를 구해야 하니 파생변수 age를 생성welfare &lt;- welfare %&gt;%  mutate(age = 2015 - birth + 1)summary(welfare$age)  # 나이 확인qplot(welfare$age)    # 나이 빈도 확인# 전처리가 끝났으니 이제 나이에 따른 월급의 관계를 분석# 나이별 평균월급을 구하자age_income &lt;- welfare %&gt;%  filter(!is.na(income)) %&gt;%   # 월급이 있는 사람만 filtering  group_by(age) %&gt;%  summarise(mean_income = mean(income))head(age_income)age_income &lt;- as.data.frame(age_income)# 가장 월급을 많이 받는 나이는?age_income %&gt;% arrange(desc(mean_income)) %&gt;%  head(1)# 결과에 대한 선 그래프를 그려보자ggplot(data=age_income,       aes(x=age,           y=mean_income)) +   geom_line() +  geom_hline(yintercept = mean(age_income$mean_income))# 20초반에는 100만원가량# 40대부터 50대 중반까지 300만원 으로 가장많은 월급# 60대 이후로는 급격히 감소하는 추세# 평균 이상의 월급을 받는 나이는 20대 말에서 60대 초반까지################################## 3. 연령대에 따른 월급 차이# 30세 미만을 초년(young), # 30~59세 : 중년(middle), # 60세 이상 : 노년(old)# 위의 범주로 연령대에 따른 월급의 차이를 알아보자# 연령대(age_group) column을 조건에 맞게 추가하자welfare &lt;- welfare %&gt;%  mutate(age_group = ifelse(age &lt; 30,\"young\",                            ifelse(age &lt;60,\"middle\",\"old\")))         table(welfare$age_group)qplot(welfare$age_group)# 연령대별 평균 월급을 구해보자age_group_income &lt;- welfare %&gt;%  filter(!is.na(income)) %&gt;%  group_by(age_group) %&gt;%  summarise(mean_income = mean(income))age_group_income &lt;- as.data.frame(age_group_income)age_group_income# 초년(young) : 163.5953# 중년(middle) : 281.8871# 노년(old) : 125.3295# 해당 결과를 그래프로 표현하자ggplot(data=age_group_income,       aes(x=age_group,           y=mean_income)) +  geom_col(width=0.5)# ggplot은 기본적으로 막대변수를 알파벳 순으로 오름차순# 정렬. 막대가 young, middle, old 순으로 정렬해보자# scale_x_discrete(limits=c(\"young\",\"middle\",\"old\")) 이용ggplot(data=age_group_income,       aes(x=age_group,           y=mean_income)) +  geom_col(width=0.5) +  scale_x_discrete(limits=c(\"young\",\"middle\",\"old\"))############################################# 4. 연령대 및 성별 월급 차이# 성별 월급 차이는 연령대에 따라 다른 양상을 보일 수 있습니다.# 성별 월급 차이가 연령대에 따라 다른지 분석해보자# 기존에는 3그룹(초년,중년,노년)이었지만 이젠 6그룹으로# 그룹핑을 해야 한다.(초년남성,초년여성,..)gender_income &lt;- welfare %&gt;%  filter(!is.na(income)) %&gt;%  group_by(age_group,gender) %&gt;%  summarise(mean_income = mean(income))gender_income &lt;- as.data.frame(gender_income)gender_income# 초년 남성 : 170.81737# 초년 여성 : 159.50518# 중년 남성 : 353.07574# 중년 여성 : 187.97552# 노년 남성 : 173.85558# 노년 여성 : 81.52917# 그래프로 표현해 보자ggplot(data=gender_income,       aes(x=age_group,           y=mean_income,           fill=gender)) +    # 누적 그래프  geom_col() +   scale_x_discrete(limits=c(\"young\",\"middle\",\"old\"))# 다르게 표현하면 다음과 같이 표현해도 된다.plot.new()ggplot(data=gender_income,       aes(x=age_group,           y=mean_income)) +      geom_col(aes(fill=gender)) +   scale_x_discrete(limits=c(\"young\",\"middle\",\"old\"))# 누적 그래프는 우리가 원하는 정보를 얻기가 힘들다# 누적시키지 않고 옆으로 따로 막대를 분리# position = \"dodge\" 이용ggplot(data=gender_income,       aes(x=age_group,           y=mean_income)) +      geom_col(aes(fill=gender), position=\"dodge\") +   scale_x_discrete(limits=c(\"young\",\"middle\",\"old\"))# 사회초년생일때는 남녀의 월급이 큰 차이가 없지만# 중년으로 들어서면 월급의 차이가 크게 벌어진다.# 남성의 경우 초년과 노년의 월급차이가 크지 않다는 것을# 파악할 수 있다.############################################### 5. 나이 및 성별 월급 차이 분석# 연령대를 구분하지 않고 나이 및 성별 월급 평균표를 만들어서# 그래프로 표현해 보자# 선 그래프로 표현하고 월급 평균 선이 성별에 따라 다른 색으로# 표현되도록 한다.gender_age &lt;- welfare %&gt;%  filter(!is.na(income)) %&gt;%  group_by(age,gender) %&gt;%  summarise(mean_income=mean(income))gender_age &lt;- as.data.frame(gender_age)gender_ageggplot(data=gender_age,       aes(x=age,           y=mean_income,           col=gender)) +  geom_line(size=1)# 30살 이후가 되면 여성과 남성의 월급차가 급격히 벌어진다.# 남성의 경우 60세 이후가 되면 월급이 급격히 감소하는 현상################################################ 6. 직업별 월급 차이# 어떤 직업이 월급을 가장 많이 받을까?# 직업별 월급을 분석해 보자# 직업코드는 제공된 PDF에서 직업분류코드(제6차 개정)에 명시되어# 있습니다.# 하지만 조금 편하게 코드작업을 하기 위해서 # 제공된 Koweps_Codebook.xlsx을 이용하면 편하게 코드값을 이용# 할 수 있습니다.class(welfare$job_code)table(welfare$job_code)code_job_file = \"C:/R_workspace/R_Lecture/data/한국복지패널데이터/Koweps_Codebook.xlsx\"# 직업 code값이 들어 있는 excel파일 불러오기raw_code_job &lt;- read.xlsx(file=code_job_file, sheetIndex=2,                          encoding=\"UTF-8\")code_job &lt;- raw_code_jobhead(code_job)# 두 data frame을 join해서 welface에 결합welfare &lt;- left_join(welfare,code_job,                     by=\"code_job\")# 정상적으로 결합되었는지 확인해보자welfare %&gt;%  filter(!is.na(code_job)) %&gt;%  select(code_job,job) %&gt;%  head(10)# 직업별 월급 평균을 구하자# 직업이 없거나 월급이 없는 사람은 제외job_income &lt;- welfare %&gt;%  filter(!is.na(job) &amp; !is.na(income)) %&gt;%  group_by(job) %&gt;%  summarise(mean_income=mean(income))job_income = as.data.frame(job_income)head(job_income)top10 &lt;- job_income %&gt;%  arrange(desc(mean_income)) %&gt;%  head(10)top10# 작성된 내용을 그래프로 표현해보자# 직업이름이 길기 때문에 일반 막대그래프로는# 표현이 힘들다. 가로로 90도 회전시켜서 표현# 월급이 많은 순으로 reorder시켜서 표현ggplot(data=top10,       aes(x=reorder(job,mean_income),           y=mean_income)) +  geom_col() +   coord_flip()# 추가로 월급이 적은 하위 10개의 직업도 추출해보자bottom10 &lt;- job_income %&gt;%  arrange(desc(mean_income)) %&gt;%  tail(10)bottom10ggplot(data=bottom10,       aes(x=reorder(job,-mean_income),           y=mean_income)) +  geom_col() +   coord_flip()############################################ 7. 성별 직업 빈도# 성별로 어떤 직업이 가장 많을까?# 원자료를 이용한 빈도는 geom_bar()를 이용하고# 요약표를 이용한 빈도는 geom_col()를 이용합니다.table(is.na(welfare$code_job))#남성 직업 빈도를 구해보자job_male &lt;- welfare %&gt;%  filter(!is.na(job),         gender==\"male\") %&gt;%  group_by(job) %&gt;%  summarise(n = n()) %&gt;%  arrange(desc(n)) %&gt;%  head(10)job_malejob_female &lt;- welfare %&gt;%  filter(!is.na(job),         gender==\"female\") %&gt;%  group_by(job) %&gt;%  summarise(n = n()) %&gt;%  arrange(desc(n)) %&gt;%  head(10)job_femaleggplot(data=job_male,       aes(x=reorder(job,n),           y=n)) +  geom_col() +  coord_flip()# 8. 종교 유무에 따른 이혼율# 종교가 있는 사람들이 이혼을 덜 할까??class(welfare$religion)table(welfare$religion)  # 1 : 종교있음. 2: 종교없음                         # 3 : 무응답# 이상치와 결측치가 없다welfare$religion &lt;- ifelse(welfare$religion == 1,                           \"yes\",\"no\")qplot(welfare$religion)# 결혼여부를 알아보자table(welfare$marriage)# 0 : 비해당(18세 미만), 1: 유배우, 2: 사별# 3 : 이혼, 4 : 별거, 5: 미혼(18세이상, 미혼모포함)# 6 : 기타# 이혼율의 정의는 모든 결혼한 사람들중에 이혼한 사람 비율# 이혼여부를 나타내는 column을 만들어 처리하자welfare &lt;- welfare %&gt;%  mutate(group_marriage = ifelse(marriage %in% c(1,2,4), \"marriage\",                             ifelse(marriage == 3,\"divorce\", NA)))table(welfare$group_marriage)qplot(welfare$group_marriage)# 종교유무에 따른 이혼율 표를 만들자religion_marriage &lt;- welfare %&gt;%  filter(!is.na(group_marriage)) %&gt;%  group_by(religion, group_marriage) %&gt;%  summarise(n = n()) %&gt;%  mutate(total_group = sum(n)) %&gt;%  mutate(pct = round(n/total_group*100,1))religion_marriage# 이혼 추출divorce &lt;- religion_marriage %&gt;%  filter(group_marriage == \"divorce\") %&gt;%  select(religion,pct)divorce = as.data.frame(divorce)divorceggplot(data=divorce,       aes(x=religion,           y=pct)) +  geom_col(width=0.5)# 이전에는 전체를 대상으로 종교 유무에 따른 이혼율을# 분석했지만 이번에는 종교 유무에 따른 이혼율이 연령대별로# 다른지 알아보자!# 9. 지역별 연령대 비율# 노년층이 많은 지역은 어디일까?# 이 이외의 변수들을 이용하여 어떠한 데이터를 추출할 수 있는지# 개인적으로 한번 생각해보자!End.이 포스트의 내용은 아래의 책과 사이트를 참조했습니다.    조금 더 자세한 사항을 알고 싶으시면 책을 참조하거나 해당 사이트를 방문하세요!!    Do It! 쉽게 배우는 R 데이터 분석 저자 GitHub",
        "url": "/R-lecture-R-exercise"
    }
    ,
    
    "r-lecture-r-konlp": {
        "title": "R 기초강의(19) - R KoNLP",
            "author": "moon9342",
            "category": "",
            "content": "R 강좌는 여러 절로 구성되어 있습니다.     R 기초강의(1) - R 개요    R 기초강의(2) - R Operator    R 기초강의(3) - R Data Type    R 기초강의(4) - R 패키지와 함수    R 기초강의(5) - R 자료구조(vector)    R 기초강의(6) - R 자료구조(matrix)    R 기초강의(7) - R 자료구조(factor, list)    R 기초강의(8) - R 자료구조(data frame)    R 기초강의(9) - R 문자열 처리    R 기초강의(10) - R 데이터 입출력    R 기초강의(11) - R 제어문 및 함수    R 기초강의(12) - R 기초 Exercise    R 기초강의(13) - R Crawling    R 기초강의(14) - R 데이터 조작    R 기초강의(15) - R 데이터 조작 실습    R 기초강의(16) - R 데이터 정제    R 기초강의(17) - R 기초 통계 함수    R 기초강의(18) - R Graph    R 기초강의(19) - R KoNLP    R 기초강의(20) - R 연습문제    R 기초강의(21) - R ggmap    R 기초강의(22) - R 정형데이터 처리R 한글 형태소 분석R의 KoNLP package는 Korean Natural Language Process의 약자로 package안에 포함된사전을 통해 문서에 포함된 품사를 분석해 주는 기능을 합니다. R언어에서 유일하게한글 형태소(뜻을 가진 가장 작은 단위)를 분석할 수 있는 기능을 제공합니다.KoNLP에는 총 3가지 사전(시스템 사전, 세종 사전, NIADic 사전)이 포함되어 있습니다.시스템 사전에는 28만개의 단어, 세종 사전에는 37만개의 단어, NIADic 사전에는 98만개의 단어가 포함되어 있습니다.영문을 분석하는 package 중 유명한 것들로는 openNLP, RKEA, Snowball등이 있습니다.KoNLP는 Java의 기능을 이용하기 때문에 JDK를 설치해야만 합니다.형태소를 분석한 후 분석결과를 표현하기 위해서 가장 쉽게 접근하는 방법은 wordcloud를 이용하는 것입니다.먼저 이 두가지 package를 설치하고 진행하도록 하겠습니다.# 한글 형태소 분석install.packages(\"KoNLP\")library(KoNLP)#useSystemDic() # 시스템 사전 설정#useSejongDic() # 세종 사전 설정useNIADic() # NIADic 사전 설정   # 이놈을 사용하자library(dplyr)# JRE 경로를 설정해야 한다.Sys.setenv(JAVA_HOME=\"C:/Program Files/Java/jre1.8.0_221/\")# 분석할 Text data를 준비하자# 해당 파일은 제공# 가요가사!!(봄날, 에라 모르겠다, etc)txt &lt;- readLines(\"C:/R_workspace/R_Lecture/data/hiphop.txt\",                 encoding = \"UTF-8\")head(txt)# 특수문자 제거library(stringr)# \\\\W은 특수문자를 의미하는 정규식txt &lt;- str_replace_all(txt,\"\\\\W\",\" \")head(txt)# 명사 추출 연습tmp &lt;- \"이것은 소리없는 아우성\"extractNoun(tmp)nouns &lt;- extractNoun(txt)head(nouns)# 결과가 list로 추출되는데 이를 vector형태로 변환words &lt;- unlist(nouns)head(words)# 빈도를 조사해보자wordcount &lt;- table(words)head(wordcount)# 빈도를 가지고 있는 데이터를 data frame으로 변환df &lt;- as.data.frame(wordcount,                    stringsAsFactors = F)head(df)# 한글자로 된 단어는 의미가 없으므로 두 글자 이상으로 된 단어만# 추출한 후 빈도로 내림차순 정렬한 후 상위 20개만 추출word_df &lt;- df %&gt;%  filter(nchar(words) &gt;= 2) %&gt;%  arrange(desc(Freq)) %&gt;%  head(20)word_dfR wordcloud워드 클라우드(word cloud)는 단어의 빈도를 구름 모양으로 표현한 그래프 입니다. 워드 클라우드는 단어의 빈도에 따라서 단어의 크기와 색상이 다르게 표현되기 때문에 어떤 단어가얼마나 많이 사용되었는가를 시각적으로 파악하기 좋습니다.앞에서 얻은 데이터를 이용하여 워드 클라우드를 만들어 보겠습니다.install.packages(\"wordcloud\")     # 워드 클라우드 패키지library(wordcloud)# 단어 색상 목록 생성pal &lt;- brewer.pal(8,\"Dark2\")   # Dark2 색상 목록에서 8개의 색상 추출# 난수 seed 설정# 워드 클라우드는 생성 시 난수를 이용하여 매번 다른 모양의# 그래프를 생성. 항상 동일한 그래프가 생성되도록(재현성)# 난수의 seed를 지정set.seed(1)wordcloud(words=word_df$words,    # 단어          freq=word_df$Freq,      # 빈도          min.freq = 2,           # 최소 빈도          max.words = 200,        # 최대 단어           random.order = F,       # 고빈도 단어 중앙 배치          rot.per = .1,           # 단어 회전 비율          scale = c(4,0.3),       # 단어 크기 범위          colors = pal)           # 색상 목록실습네이버 영화 댓글 사이트에서 특정 영화에 대한 review data를 crawling하여wordcloud를 생성해보자!!## 네이버 영화 댓글을 이용한 워드 클라우드 생성## Crawling &amp; Scraping 작업library(stringr)library(rvest)url &lt;- \"https://movie.naver.com/movie/point/af/list.nhn?target=after&amp;st=mcode\"movie_code = \"88426\"  # 건축학개론 영화 codesword &lt;- \"sword=\"page &lt;- \"page=\"result &lt;- vector(mode=\"character\")for(p in 1:100) {  request_url &lt;- str_c(url,\"&amp;\",                       sword,movie_code,                       \"&amp;\",                       page,p)    page_html &lt;- read_html(request_url,  encoding=\"CP949\")  page_html;    movie_review = vector(mode=\"character\", length=10)    for(i in 1:10) {    myPath = str_c('//*[@id=\"old_content\"]/table/tbody/tr[',                   i,                   ']/td[2]/text()')    nodes &lt;- html_nodes(page_html, xpath=myPath)    comment &lt;- html_text(nodes, trim=TRUE);    movie_review[i] = comment[3]  }  result = c(result,movie_review)}result  # 문자열 vectorlibrary(KoNLP)#useSystemDic() # 시스템 사전 설정#useSejongDic() # 세종 사전 설정useNIADic() # NIADic 사전 설정   # 이놈을 사용하자# 특수문자 제거library(stringr)library(dplyr)# JRE 경로를 설정해야 한다.Sys.setenv(JAVA_HOME=\"C:/Program Files/Java/jre1.8.0_221/\")txt &lt;- resulthead(txt)# \\\\W은 특수문자를 의미하는 정규식txt &lt;- str_replace_all(txt,\"\\\\W\",\" \")head(txt)nouns &lt;- extractNoun(txt)head(nouns)# 결과가 list로 추출되는데 이를 vector형태로 변환words &lt;- unlist(nouns)head(words)# 빈도를 조사해보자wordcount &lt;- table(words)head(wordcount)# 빈도를 가지고 있는 데이터를 data frame으로 변환df &lt;- as.data.frame(wordcount,                    stringsAsFactors = F)head(df)# 한글자로 된 단어는 의미가 없으므로 두 글자 이상으로 된 단어만# 추출한 후 빈도로 내림차순 정렬한 후 상위 20개만 추출word_df &lt;- df %&gt;%#  filter(nchar(words) &gt;= 2) %&gt;%  # CP949로 인한 인코딩 오류  arrange(desc(Freq)) %&gt;%  head(100)word_df# wordcloud를 이용한 그래프 출력library(wordcloud)# 단어 색상 목록 생성pal &lt;- brewer.pal(8,\"Dark2\")   # Dark2 색상 목록에서 8개의 색상 추출# 난수 seed 설정# 워드 클라우드는 생성 시 난수를 이용하여 매번 다른 모양의# 그래프를 생성. 항상 동일한 그래프가 생성되도록(재현성)# 난수의 seed를 지정set.seed(1)wordcloud(words=word_df$words,    # 단어          freq=word_df$Freq,      # 빈도          min.freq = 2,           # 최소 빈도          max.words = 50,        # 최대 단어           random.order = F,       # 고빈도 단어 중앙 배치          rot.per = .1,           # 단어 회전 비율          scale = c(4,0.3),       # 단어 크기 범위          colors = pal)           # 색상 목록End.이 포스트의 내용은 아래의 책과 사이트를 참조했습니다.    조금 더 자세한 사항을 알고 싶으시면 책을 참조하거나 해당 사이트를 방문하세요!!    Do It! 쉽게 배우는 R 데이터 분석 저자 GitHub",
        "url": "/R-lecture-R-KoNLP"
    }
    ,
    
    "r-lecture-r-graph": {
        "title": "R 기초강의(18) - R Graph",
            "author": "moon9342",
            "category": "",
            "content": "R 강좌는 여러 절로 구성되어 있습니다.     R 기초강의(1) - R 개요    R 기초강의(2) - R Operator    R 기초강의(3) - R Data Type    R 기초강의(4) - R 패키지와 함수    R 기초강의(5) - R 자료구조(vector)    R 기초강의(6) - R 자료구조(matrix)    R 기초강의(7) - R 자료구조(factor, list)    R 기초강의(8) - R 자료구조(data frame)    R 기초강의(9) - R 문자열 처리    R 기초강의(10) - R 데이터 입출력    R 기초강의(11) - R 제어문 및 함수    R 기초강의(12) - R 기초 Exercise    R 기초강의(13) - R Crawling    R 기초강의(14) - R 데이터 조작    R 기초강의(15) - R 데이터 조작 실습    R 기초강의(16) - R 데이터 정제    R 기초강의(17) - R 기초 통계 함수    R 기초강의(18) - R Graph    R 기초강의(19) - R KoNLP    R 기초강의(20) - R 연습문제    R 기초강의(21) - R ggmap    R 기초강의(22) - R 정형데이터 처리R Graph데이터를 보기 쉽게 그림으로 표현하는 것을 Graph라고 합니다. 숫자나 문자로 구성된 데이터는의미를 파악하기 어렵지만 Graph로 표현하면 추세와 경향성이 드러나기 때문에 데이터의 특징을 쉽게이해할 수 있습니다.R을 선호하는 이유 중 하나가 바로 Graph기능입니다. R에는 기본 2차원 Graph부터 3차원 Graph, 지도,네트워크, interactive graph등 다양한 Graph package가 존재합니다.ggplot2는 reshape2 package와 dplyr package를 만든 해들리 위컴이 만든 R 시각화 1순위 package입니다. 그래프를 만들 때 가장 많이 사용하는 package로 기본적으로 산점도, 막대그래프,선 그래프, 상자 그림을 포함해서 다양한 그래프를 만들 수 있습니다.산점도 - 변수간의 관계 표현데이터를 x축과 y축에 점으로 표현한 그래프를 산점도(scatter plot) 라고 합니다. 산점도는나이와 소득처럼 연속 값으로 된 두 변수의 관계를 표현할 때 사용됩니다.잠깐 변수의 종류에 대해서 간단히 알아보도록 하겠습니다.변수는 크게 수량적 특성에 의한 분류와 자료의 특성에 따른 분류로 나누어집니다. 수량적 특성에 의한 분류에 따르면 변수는 크게 정성적 변수와 정량적 변수로 구분됩니다.정성적 변수 : 질적변수, Qualitative Variable, Categorical Variable 이라고도 합니다. 정성적 변수는 비서열 질적 변수(unordered qualitative variable)와 서열 질적 변수(ordered qualitative variable)로 다시 나누어 집니다.정성적 변수의 분류  비서열 질적 변수`의 예 : 성별, 인종, 직업, 전공  서열 질적 변수`의 예 : 학력, 군대의 계급, 회사의 직급정량적 변수 : 양적변수, Quantitative Variable, Numerical Variable 이라고도 합니다.정량적 변수는 연속 변수(continuous variable)와 비연속 변수(discrete variable)로 다시 나누어 집니다.정량적 변수의 종류  연속 변수 : 주어진 범위에서 어떠한 값도 가질 수 있는 변수(키, 몸무게, 나이)  비연속 변수 :  대상에 대해 측정하면 정수로 표현되는 변수. 즉, 셀수 있으며 정해지 몇 개의 값만을가지는 변수(아파트 층수, 퀴즈를 맞춘 개수)자료의 특성에 따른 분류에 따르면 변수는 이산형 변수와 연속형 변수로 구분됩니다. 여기서 이산형 변수는 다시 명목척도 변수, 순서 척도 변수로 구분되고 연속형 변수는 구간 척도 변수와 비율철도 변수로구분됩니다.ggplot2 문법은 layer 구조로 되어 있습니다.1단계 : 배경을 설정합니다. 즉, x축과 y축에 대한 설정을 합니다.2단계 : 그래프를 추가합니다. (점, 막대, 선등)3단계 : 축 범위, 색, 표식등의 설정 추가# mpg data set을 이용하여 그래프를 생성합니다# ggplot2를 이용한 그래프 생성install.packages(\"ggplot2\")library(ggplot2)df &lt;- as.data.frame(mpg)# 1. 배경 설정# data 속성 : 그래프를 그리는데 사용할 데이터 # aes 속성 : x축과 ㅛ축에 사용할 변수를 지정# mpg data set의 displ(배기량)을 x축에 hwy(고속도로 연비)를 # y축으로 지정ggplot(data=df,       aes(x=displ, y=hwy))    # 배경 생성# 2. 그래프 추가# 배경을 생성했으니 그 위에 그래프를 그린다# + 기호를 이용하여 그래프 유형을 지정하는 함수를 추가# 산점도를 그리는 함수는 geom_point()# dplyr에서 연결기호는 %&gt;%, ggplot2의 연결기호는 +ggplot(data=df,       aes(x=displ, y=hwy)) +geom_point()      # 산점도 추가# 그래프를 보면 배기량이 클수록 연비가 떨어지는 것을 확인할 수 있다.# 3. 설정 추가# 축 범위를 조절하는 설정을 추가할 수 있다# 기본적으로 축은 최소값에서 최대값을 표현할 수 있도록 기본 설정# 일부 데이터만 표현하고 싶을 때 축 범위 조절# 축 범위 조절 함수 : xlim(), ylim()ggplot(data=df,       aes(x=displ, y=hwy)) +  geom_point() +  xlim(3,6) +  ylim(10,30)# plots 창의 export menu를 이용하면 해당 그래프를 이미지나 PDF로# 저장할 수 있다.# 그래프를 그릴때 그래프의 option을 줄 수 있습니다.ggplot(data=df,       aes(x=displ, y=hwy)) +  geom_point(size=3, color=\"red\")      # 산점도 추가plot.new()   # 작성한 그래프를 지울 때 사용막대 그래프 - 집단간의 차이 표현막대 그래프는 데이터의 크기를 막대의 길이로 표현한 그래프입니다. 성별 소득차이처럼집단 간 차이를 표현할 때 주로 사용됩니다.mpg data set을 이용하여 drv(구동방식)별 평균 hwy(고속도록 연비) 막대 그래프를그려보겠습니다.# mpg data set을 이용한 drv별 평균 hwy 막대 그래프 그리기# 1. 집단별 평균표로 구성된 data frame 생성library(ggplot2)library(dplyr)df &lt;- as.data.frame(mpg)head(df)result &lt;- df %&gt;%  group_by(drv) %&gt;%  summarise(mean_hwy = mean(hwy))result     # 구동방식별 고속도로 평균 연비# 2. 그래프 생성ggplot(data=result,       aes(x=drv, y=mean_hwy)) +  geom_col(width=0.3)# 3. 크기순으로 정렬# 기본적으로 알파벳 오름차순으로 범주가 정렬# reorder를 이용하면 막대를 값의 크기순으로 정렬할 수 있다# reorder()의 기본 정렬은 오름차순, - 기호를 이용하면 내림차순ggplot(data=result,       aes(x=reorder(drv, -mean_hwy), y=mean_hwy)) +  geom_col()################################# 빈도 막대 그래프 - geom_col() 대신 geom_bar()를 이용# 빈도 막대 그래프는 별도의 data frame을 만들지 않고 # raw data frame을 이용하여 바로 생성# drv 항목의 빈도 그래프를 그려보자ggplot(data = df,       aes(x=drv)) +  geom_bar(width=0.5)# 빈도 막대 그래프에 추가해서 누적 막대 그래프를 표현해보자# 이전 그래프는 구동방식(drv)에 따른 빈도는 알 수 있으나# 각 구동방식내에서 cyl(실린더의 개수)의 빈도까지 파악 할 수는# 없습니다.# geom_bar() 함수내에 aes()를 이용하여 누적할 열을 지정합니다.ggplot(data = df,       aes(x=drv)) +  geom_bar(aes(fill=factor(cyl)),width=0.5)# 도수분포를 막대 모양 그래프(히스토그램)로 표현할 수 있습니다.# 아래의 예시는 오류입니다. 연속형 변수를 이용해야 하는데 drv는# 범주로 구분되는 discret변수를 사용해서 그렇습니다.ggplot(data = df,       aes(x=drv)) +  geom_histogram()# 연속형 변수를 이용해서 히스토그램을 그려보겠습니다.ggplot(data = df,       aes(x=hwy)) +  geom_histogram()# 히스토그램의 bin의 값을 설정하지 않아서 30으로 설정# 만약 bin값을 다시 설정하려면 다음과 같이 설정(비율지정)ggplot(data = df,       aes(x=hwy)) +  geom_histogram(binwidth = 1)선 그래프 - 시간에 따라 달라지는 데이터 표현데이터를 선으로 표현한 그래프를 선 그래프(Line Chart)라고 합니다. 일반적으로 시간에 따라달라지는 데이터(환율, 주가등 경제지표등)를 표현할 때 많이 사용합니다.일정 시간 간격을 두고 나열된 데이터를 시계열 데이터(Time Series Data)라고 하고, 시계열 데이터를 선으로 표현한 그래프를 시계열 그래프(Time Series Chart)라고 합니다.mpg data set은 시계열 데이터가 없기 때문에 다른 data set을 이용해야 합니다.ggplot2 package안에는 economics data set은 미국의 경제 지표들을 월별로 나타낸 data set입니다.# 시계열 데이터를 이용하여 선 그래프를 그려보자!# 사용 data seteconomicseconomics_long# 컬럼설명# date : 날짜(년도별 월)# psavert : personal savings rate(개인 저축률)# pce : personal consumption expenditures(개인소비지출)#       경기선행지수로 사용된다. in billions of dollars(십억달러)# unemploy : number of unemployed in thousands( 실업자 수 - 천단위)# uempmed : median duration of unemployment, in weeks#           비고용기간의 중앙값 (주단위)# pop : total population, in thousands (전체인구 - 천단위)help(economics)# 시간에 따른 실업자수 추이를 생성해보자ggplot(data=economics,       aes(x=date, y=unemploy)) +  geom_line()# 5년을 주기로 등락을 거듭하고 있다.# 2008년 리먼 브라더스 사태로 실업률 대량 증가# scatter를 이용한 산점도를 그린 후 그 위에 선 그래프를# 추가해서 그래프에 그래프를 추가해 보자ggplot(data=economics,       aes(x=date, y=unemploy)) +  geom_point(color = \"red\") +   geom_line()상자 그래프 - 집단간의 분포 차이 표현상자 그림(boxplot)은 데이터의 분포를 직사각형 상자 모양으로 표현한 그래프 입니다. 데이터의분포를 파악할 수 있기 때문에 평균만을 볼 때 보다 데이터 특징을 더 잘 이해할 수 있습니다.다시 mpg data set으로 돌아와서 drv(구동방식)별 hwy(고속도로 연비)를 상자 그림으로 표현해보겠습니다.# mpg data set을 이용하여 drv(구동방식)별 hwy(고속도로 연비)를 # 상자 그림으로 표현ggplot(data=df,       aes(x=drv, y=hwy)) +  geom_boxplot()# 그래프를 보고 파악할 수 있는 점# 4륜 구동은 hwy가 약 17~22사이에 자동차가 모여있다.# 전륜 구동은 연비가 극단적인 형태의 자동차가 많다.# 후륜 구동은 대부분의 자동차가 사분위 범위에 해당한다.그래프에 객체 추가ggplot2에는 그래프를 그리는 함수와 도형이나 텍스트 같은 다양한 객체를 그리는 함수도포함되어 있습니다. 그래프에 선이나 도형을 포함시키면 그래프의 가독성이 높아지기 때문에많이 이용되는 기능입니다.# ggplot2 그래프에 객체 추가# 사용할 data set은 ecomonicsdf &lt;- economicshead(df)# 날짜별 개인 저축률에 대한 선 그래프를 그려보자ggplot(data=df,       aes(x=date, y=psavert)) +  geom_line()# 직선을 추가해보자ggplot(data=df,       aes(x=date, y=psavert)) +  geom_line() +  geom_abline(intercept=12.1, slope=-0.0003444)# 여기서 잠깐!!# 만약 데이터를 가장 잘 표현하는 직선을 우리가 찾을 수# 있다면 해당 그래프를 이용해서 미래의 값을 예측할 수 있다.# 이 직선을 얻기 위해서는 기울기와 절편의 값을 구해야 하는데# 이 값은 회귀분석을 통해서 얻을 수 있다.# 평행선을 추가해보자# geom_hline()을 이용해서 평행선을 그릴 수 있다.# 기존 시간에 따른 개인저축률 그래프에 개인 저축률의 # 평균값을 이용하여 평행선을 그려보자ggplot(data=df,       aes(x=date, y=psavert)) +  geom_line() +  geom_hline(yintercept=mean(df$psavert))# geom_vline()을 이용하여 수직선을 그릴 수 있다.# 개인 저축률이 가장 낮은 시기를 바로 알 수 있도록 수직선을# 그려보자# 먼저 개인 저축률이 가장 낮은 날짜를 알아야 한다.tmp &lt;-   df %&gt;% filter(psavert == min(psavert)) %&gt;%  select(date)tmp &lt;- as.data.frame(tmp)$dateggplot(data=df,       aes(x=date, y=psavert)) +  geom_line() +   geom_vline(xintercept = tmp)## 만약 날짜를 직접입력하려면??ggplot(data=df,       aes(x=date, y=psavert)) +  geom_line() +   geom_vline(xintercept = as.Date(\"2009-10-01\"))# 그래프에 텍스트를 추가하려면??# geom_text()를 이용하면 그래프에 텍스트를 입력할 수 있습니다.# 그래프의 범례나 제목과는 다르게 그래프 위에 직접 표현# geom_text(aes(label=\"라벨명\", vjust=세로위치, hjust=가로위치))ggplot(data=df,       aes(x=date, y=psavert)) +  geom_point() +   xlim(as.Date(\"1990-01-01\"),       as.Date(\"1992-12-01\")) +  ylim(7,10) +  geom_text(aes(label=psavert, vjust=0, hjust=-0.5)) #geom_text(aes(label=psavert, vjust=0, hjust=0)) # 숫자의 의미 : + 아래, 왼쪽 , - 위 , 오른쪽을 의미  # 도형 및 화살표를 추가하는 annotate() 함수# annotate()함수는 그래프 위에 사각형이나 화살표 등으로# 특정 영역을 강조할 때 많이 사용됩니다.# annotate(\"모양\",#          xmin=x축시작,#          xmax=x축 끝,#          ymin=y축 시작,#          ymax=y축 끝)ggplot(data=df,       aes(x=date, y=psavert)) +  geom_point() +   xlim(as.Date(\"1990-01-01\"),       as.Date(\"1992-12-01\")) +  ylim(7,10) +   annotate(\"rect\",           xmin=as.Date(\"1991-01-01\"),           xmax=as.Date(\"1991-12-31\"),           ymin=8,           ymax=9,           alpha=0.3,           fill=\"red\")# 여기에 추가적으로 화살표를 표시할 수 있습니다.# 화살표 역시 annotate()를 이용하여 표현합니다.ggplot(data=df,       aes(x=date, y=psavert)) +  geom_point() +   xlim(as.Date(\"1990-01-01\"),       as.Date(\"1992-12-01\")) +  ylim(7,10) +   annotate(\"rect\",           xmin=as.Date(\"1991-01-01\"),           xmax=as.Date(\"1991-12-31\"),           ymin=8,           ymax=9,           alpha=0.3,           fill=\"red\") +  annotate(\"segment\",           x = as.Date(\"1990-05-01\"),           xend=as.Date(\"1991-05-01\"),           y = 7.5,           yend=8.5,           color=\"blue\",           arrow=arrow()) +  annotate(\"text\",           x=as.Date(\"1991-05-01\"),           y=8.5,           label=\"글자도 쓸수 있어요!!\")# 마지막으로 그래프의 제목과 각 축의 이름, 배경색등을 설정해보자# 테마는 총 8가지를 기본으로 제공하며 기본 테마는 theme_gray()# labs(x=x축 이름, y=y축 이름, title=그래프 제목)ggplot(data=df,       aes(x=date, y=psavert)) +  geom_point() +   xlim(as.Date(\"1990-01-01\"),       as.Date(\"1992-12-01\")) +  ylim(7,10) +   labs(x=\"연도\", y=\"개인저축률\", title=\"날짜별 개인 저축률\") +   theme_classic()End.이 포스트의 내용은 아래의 책과 사이트를 참조했습니다.    조금 더 자세한 사항을 알고 싶으시면 책을 참조하거나 해당 사이트를 방문하세요!!    Do It! 쉽게 배우는 R 데이터 분석 저자 GitHub",
        "url": "/R-lecture-R-graph"
    }
    ,
    
    "r-lecture-r-descriptive-statistics": {
        "title": "R 기초강의(17) - R 기초 통계 함수",
            "author": "moon9342",
            "category": "",
            "content": "R 강좌는 여러 절로 구성되어 있습니다.     R 기초강의(1) - R 개요    R 기초강의(2) - R Operator    R 기초강의(3) - R Data Type    R 기초강의(4) - R 패키지와 함수    R 기초강의(5) - R 자료구조(vector)    R 기초강의(6) - R 자료구조(matrix)    R 기초강의(7) - R 자료구조(factor, list)    R 기초강의(8) - R 자료구조(data frame)    R 기초강의(9) - R 문자열 처리    R 기초강의(10) - R 데이터 입출력    R 기초강의(11) - R 제어문 및 함수    R 기초강의(12) - R 기초 Exercise    R 기초강의(13) - R Crawling    R 기초강의(14) - R 데이터 조작    R 기초강의(15) - R 데이터 조작 실습    R 기초강의(16) - R 데이터 정제    R 기초강의(17) - R 기초 통계 함수    R 기초강의(18) - R Graph    R 기초강의(19) - R KoNLP    R 기초강의(20) - R 연습문제    R 기초강의(21) - R ggmap    R 기초강의(22) - R 정형데이터 처리R 기술 통계량데이터를 분석할 때는 다양한 요약 값으로 데이터의 특성을 파악할 수 있고 요약값을 표나그래프를 이용하여 시각적으로 표현할 수 있습니다.이때 특성을 파악하기 위해 데이터를 요약한 값을 기술 통계량(Descriptive Statistics)이라고 합니다. 즉, 보유한 데이터를 의미 있는 수치로 요약하여 데이터의 특성을 파악할 수 있도록 한 정보를의미합니다.기술 통계량 분석을 위한 함수  mean() : 일반적인 평균.  median() : 중간값(중위수)  max() : 최대값  min() : 최소값  range() : 최대값과 최소값의 범위  quantile() : 분위수  var() : 분산. 데이터가 평균으로부터 퍼진 정도를 설명하는 통계량  sd() : 표준편차  skew() : 왜도. 데이터의 비대칭을 설명하는 통계량. 절대값이 클수록 비대칭이 심하고, 양수이면 오른쪽으로 꼬리가 길고, 음수이면 왼쪽으로 꼬리가 긴 형태  kurtosi() : 첨도. 데이터 분포가 뾰족한 정도를 설명하는 통계량. 통계량이 0보다 크면 정규분포대비뾰족하며, 0보다 작으면 정규분포대비 평평한 형태이런 기술 통계량은 summary(), describe(), stat.desc()함수를 이용하면 한번에 확인이 가능합니다. 단, describe() 함수는 psych package를 설치해야 하고 stat.desc() 함수는 pastecs package를 설치해야 합니다.      psych describe()        pastecs  많이 사용하는 기능 중 빈도를 계산하는 함수가 있습니다. table()을 이용해도 되지만 descr package의 freq() 함수가많이 사용됩니다.실습  기본 통계함수에 대한 예제를 실습합니다.library(xlsx)df &lt;- read.xlsx(file=\"C:/R_workspace/R_Lecture/data/sample_data.xlsx\",                sheetIndex = 1,                encoding = \"UTF-8\")df# 기본 통계량summary(df$Y16_CNT)# 기본 통계 함수mean(df$Y16_CNT)median(df$Y16_CNT)max(df$Y16_CNT)min(df$Y16_CNT)      range(df$Y16_CNT)    # 최소값 최대값quantile(df$Y16_CNT) # 사분위var(df$Y16_CNT)      # 분산  sd(df$Y16_CNT)       # 표준편차skew(df$Y16_CNT)     # 왜도kurtosi(df$Y16_CNT)  # 첨도install.packages(\"psych\")  # psychometrics(심리측정학)library(psych)describe(df)# Package for Analysis of Space-Time Ecological Seriesinstall.packages(\"pastecs\") library(pastecs)stat.desc(df)# 빈도를 구하기 위한 함수install.packages(\"descr\")library(descr)freq(df$SEX, plot = T)freq(df$AREA, plot = T)End.이 포스트의 내용은 아래의 책과 사이트를 참조했습니다.    조금 더 자세한 사항을 알고 싶으시면 책을 참조하거나 해당 사이트를 방문하세요!!    Do It! 쉽게 배우는 R 데이터 분석 저자 GitHub",
        "url": "/R-lecture-R-descriptive-statistics"
    }
    ,
    
    "r-lecture-r-data-preprocessing": {
        "title": "R 기초강의(16) - R 데이터 정제",
            "author": "moon9342",
            "category": "",
            "content": "R 강좌는 여러 절로 구성되어 있습니다.     R 기초강의(1) - R 개요    R 기초강의(2) - R Operator    R 기초강의(3) - R Data Type    R 기초강의(4) - R 패키지와 함수    R 기초강의(5) - R 자료구조(vector)    R 기초강의(6) - R 자료구조(matrix)    R 기초강의(7) - R 자료구조(factor, list)    R 기초강의(8) - R 자료구조(data frame)    R 기초강의(9) - R 문자열 처리    R 기초강의(10) - R 데이터 입출력    R 기초강의(11) - R 제어문 및 함수    R 기초강의(12) - R 기초 Exercise    R 기초강의(13) - R Crawling    R 기초강의(14) - R 데이터 조작    R 기초강의(15) - R 데이터 조작 실습    R 기초강의(16) - R 데이터 정제    R 기초강의(17) - R 기초 통계 함수    R 기초강의(18) - R Graph    R 기초강의(19) - R KoNLP    R 기초강의(20) - R 연습문제    R 기초강의(21) - R ggmap    R 기초강의(22) - R 정형데이터 처리R 결측치 정제현장에서 만들어진 raw 데이터는 오류를 포함하고 있기 때문에 분석하기 전에 오류를 수정해야 합니다.결측치는 누락된 값, 즉 비어있는 값을 의미합니다. 이런 결측치가 존재하면 함수가 적용되지 않거나 분석결과가 왜곡되기 때문에 결측치가 있는지 확인한 후 제거 혹은 정제과정을 거쳐야 합니다.is.na() 함수  is.na() 함수를 이용하면 데이터에 결측치(NA)가 포함되어 있는지 확인할 수 있습니다.실습  결측치가 포함된 데이터를 생성합니다.  is.na()와 table()을 이용하여 결측치가 몇개 있는지 확인합니다.  dplyr package를 이용하여 결측치가 포함된 행을 제거합니다.  na.omit()를 이용하여 결측치가 포함된 모든 행을 제거합니다.# 결측치가 포함된 데이터 생성df &lt;- data.frame(id=c(1,2,NA,4,NA,6),                 score=c(20,30,NA,50,67,NA))df# is.na() 함수 이용is.na(df)  # 결과는 logical type의 data frame # table() 함수는 빈도를 계산하는 함수table(is.na(df))      # data frame 전체에 대한 빈도table(is.na(df$id))   # 특정 column에 대한 빈도table(is.na(df$score))   # 특정 column에 대한 빈도# 결측치가 있는 행 제거library(dplyr)result_df &lt;- df %&gt;% filter(!is.na(df$id)) # id 결측치 제거result_dfresult_df &lt;- df %&gt;% filter(!is.na(df$score)) # score 결측치 제거result_dfmean(df$score)            # NAmean(result_df$score)# 모든 column에 존재하는 결측치 제거result_df &lt;- df %&gt;% filter(!is.na(df$score),                           !is.na(df$id))result_df# 결측치가 하나라도 있으면 해당 행 제거result_df &lt;- na.omit(df)  # 간편하지만 좋은 방식은 아님.result_dfR 함수의 결측치 제외 기능mean()과 같은 수치 연산 함수들은 결측치를 제외하고 연산하도록 설정하는 na.rm 파라미터를지원합니다. 하지만 모든 수치 연산 함수가 na.rm 파라미터를 지원하는것은 아니기 때문에 filter() 함수등을 이용하여 결측치를 제거한 후 연산을 해야 합니다.데이터가 많고 결측치가 많지 않은 경우에는 결측치를 제거하고 분석해도 괜찮지만 데이터가 적고결측치가 많을 경우 결측치를 제거하면 너무 많은 데이터가 유실될 수 있습니다. 이런 경우 결측치를제거하는 대신 다른 값으로 대체해서 사용할 수 있습니다.실습# 함수의 결측치 제외 기능df &lt;- data.frame(id=c(1,2,NA,4,NA,6),                 score=c(20,30,NA,50,67,NA))dfmean(df$score, na.rm=TRUE)   # 결측치를 제외하고 연산수행sum(df$score, na.rm=TRUE)   # 결측치를 제외하고 연산수행# 결측치를 평균 값으로 대체df$score &lt;- ifelse(is.na(df$score),                    mean(df$score, na.rm=T),                   df$score)dfR 이상치 정제결측치는 아니지만 존재할 수 없는 값이 사용되거나 정상 범주에서 크게 벗어난 값을 이상치(outlier)라고 합니다. 이런 이상치 역시 분석 결과를 왜곡 시키기 때문에 분석에 앞서 이상치를 제거하는 작업이 필요합니다.이상치 제거 실습  이상치 제거 - 존재할 수 없는 값이 존재할 경우# 이상치 정제# 성별에 존재할 수 없는 값이 있을 경우# table() 함수를 이용하여 빈도수를 알아보면 확인할 수 있다df &lt;- data.frame(id=c(1,2,NA,4,NA,6),                 score=c(20,30,NA,50,67,NA),                 gender=c(\"^^\",\"F\",\"M\",\"F\",\"M\",\"M\"),                 stringsAsFactors = F)dfstr(df)table(df$gender)# 이상치를 결측치로 변환df$gender = ifelse(df$gender %in% c(\"M\",\"F\"),                   df$gender,                   NA)table(df$gender)df논리적으로 존재할 수 있지만 극단적으로 크거나 작은 값을 극단치라고 합니다.극단치 역시 데이터 분석 결과를 왜곡시킬 수 있기 때문에 이 역시 제거해야 합니다.극단치를 제거하려면 정상 범위를 정해야 합니다. 논리적으로 판단해 정상범위를지정 할 수 있고 통계적인 기준(표준편차등)을 이용해 정상범위를 지정할 수 있습니다.또한 Boxplot을 이용해서 중심에서 크게 벗어난 값을 극단치로 간주하는 방법도 있습니다.Boxplot을 사용할 때 극단치를 분류하는 기준은 IQR이라는 단위를 이용합니다.IQR(interquartile range) : 1사분위와 3사분위 사이의 범위. 1사분위수보다 1.5IQR 초과로 작은 값과3사분위수보다 1.5IQR 초과로 큰 값은 극단치로 분류됩니다.실습  mpg data set에 대해 boxplot을 이용하여 극단치 처리를 해 보자.# 극단치를 확인하기 위한 sample codedata = c(1,2,3,4,5,6,7,8,9,10,11,12,13,14,22.1)summary(data)# IQR(데이터 중간 위쪽의 mid point - 중간 아래쪽의 mid point)median_value = summary(data)[3]; median_valuelower_data = c(1,2,3,4,5,6,7,8)upper_data = c(8,9,10,11,12,13,14,22.1)mid_lower = median(lower_data); mid_lowermid_upper = median(upper_data); mid_upperIQR_value = mid_upper - mid_lower; IQR_value# 기준치 =&gt; IQR * 1.5deter_value = IQR_value * 1.5# 3사분위 값 + 기준치 =&gt; summary(data)[5] + deter_valueoutlier_value = summary(data)[5] + deter_value; outlier_valueboxplot(data)# mpg data를 이용한 극단치 처리library(ggplot2)mpgclass(mpg)mpg &lt;- as.data.frame(mpg)class(mpg)boxplot(mpg$hwy)# 상자그림의 통계치 추출boxplot(mpg$hwy)$stats# 통계치의 결과는 위에서 아래 순으로# 아래쪽 극단치 경계, 1산분위수, 중앙값, 3사분위수# 위쪽 극단치 경계를 의미# 즉, 12~37을 벗어나면 극단치로 분류된다# 해당 범위를 벗어난 값을 결측치 처리한다.mpg$hwy &lt;- ifelse(mpg$hwy &lt; 12 | mpg$hwy &gt; 37,                  NA,                  mpg$hwy)table(is.na(mpg$hwy))result &lt;- mpg %&gt;%          group_by(drv) %&gt;%          summarise(hwy_mean=mean(hwy, na.rm=T))result실습문제지금까지 배운 내용을 토대로 간단한 연습문제를 풀어보도록 합니다.사용하는 data set  예제 data set##################################### 연습문제!!##################################### data : excel 파일(exec1105.xlsx)# 만약 결측값이 존재하면 결측값은 결측값을 제외한 # 해당 과목의 평균을 이용합니다.# 만약 극단치가 존재하면 하위 극단치는 극단치값을 제외한# 해당 과목의 1사분위 값을 이용하고 상위 극단치는# 해당 과목의 3사분위 값을 이용합니다.# 1. 전체 평균이 가장 높은 사람은 누구이며 평균값은 얼마인가요?# 2. 남자와 여자의 전체 평균은 각각 얼마인가요?# 3. 수학성적이 전체 수학 성적 평균보다 높은 남성은 누구이며#    수학성적은 얼마인가요?library(xlsx)library(stringr)library(dplyr)library(reshape2)file_name = \"C:/R_workspace/R_Lecture/data/exec1105.xlsx\"score_df &lt;- read.xlsx(file=file_name,                      header = F,                      sheetIndex = 1,                      encoding = \"UTF-8\",                      stringsAsFactors=F)names(score_df) &lt;- c(\"s_num\",\"subject\",\"score\")score_dfstr(score_df)student_df &lt;- read.xlsx(file=file_name,                        header = F,                        sheetIndex = 2,                        encoding = \"UTF-8\",                        stringsAsFactors=F)names(student_df) &lt;- c(\"s_num\",\"s_name\",\"s_gender\")student_dfstr(student_df)join_df &lt;- inner_join(student_df,                      score_df,                      by=\"s_num\")join_dfdf &lt;- dcast(join_df,            formula = s_num + s_name + s_gender ~ subject,            value.var = \"score\")df## 결측치 처리for(i in 1:length(df)) {  col_value = df[[i]]  if(sum(is.na(col_value)) &gt; 0) {    df[[i]] = ifelse(is.na(col_value),                     mean(col_value, na.rm=T),                     col_value)  }}df## 극단치 처리for(i in 1:length(df)) {  if(!(names(df[i]) %in% c(\"s_num\",\"s_name\",\"s_gender\"))) {    min_val = boxplot(df[[i]])$stats[1,1]    max_val = boxplot(df[[i]])$stats[5,1]                first_4 = summary(df[[i]], na.rm=T)[2]  # NA 해결 필요    third_4 = summary(df[[i]], na.rm=T)[5]        df[[i]] = ifelse(df[[i]] &gt; max_val,                     third_4,                     df[[i]])        df[[i]] = ifelse(df[[i]] &lt; min_val,                     first_4,                     df[[i]])  }}df# 1. 전체 평균이 가장 높은 사람은 누구이며 평균값은 얼마인가요?answer_1 &lt;- df %&gt;% mutate(avg=(eng+kor+math)/3) %&gt;%  arrange(desc(avg)) %&gt;%  head(1)answer_1# 김연아 81.11111# 2. 남자와 여자의 전체 평균은 각각 얼마인가요?answer_2 &lt;- df %&gt;%   mutate(avg=(eng+kor+math)/3) %&gt;%  group_by(s_gender) %&gt;%  summarise(total_avg = mean(avg))answer_2# 남자 : 40.7# 여자 : 54.6# 3. 수학성적이 전체 수학 성적 평균보다 높은 남성은 누구이며#    수학성적은 얼마인가요?answer_3 &lt;- df %&gt;%   filter(s_gender == \"남자\",         math &gt; mean(df$math))answer_3# 이순신 : 68# 강감찬 : 78.66667End.이 포스트의 내용은 아래의 책과 사이트를 참조했습니다.    조금 더 자세한 사항을 알고 싶으시면 책을 참조하거나 해당 사이트를 방문하세요!!    Do It! 쉽게 배우는 R 데이터 분석 저자 GitHub",
        "url": "/R-lecture-R-data-preprocessing"
    }
    ,
    
    "r-lecture-r-dplyr-exercise": {
        "title": "R 기초강의(15) - R 데이터 조작 실습",
            "author": "moon9342",
            "category": "",
            "content": "R 강좌는 여러 절로 구성되어 있습니다.     R 기초강의(1) - R 개요    R 기초강의(2) - R Operator    R 기초강의(3) - R Data Type    R 기초강의(4) - R 패키지와 함수    R 기초강의(5) - R 자료구조(vector)    R 기초강의(6) - R 자료구조(matrix)    R 기초강의(7) - R 자료구조(factor, list)    R 기초강의(8) - R 자료구조(data frame)    R 기초강의(9) - R 문자열 처리    R 기초강의(10) - R 데이터 입출력    R 기초강의(11) - R 제어문 및 함수    R 기초강의(12) - R 기초 Exercise    R 기초강의(13) - R Crawling    R 기초강의(14) - R 데이터 조작    R 기초강의(15) - R 데이터 조작 실습    R 기초강의(16) - R 데이터 정제    R 기초강의(17) - R 기초 통계 함수    R 기초강의(18) - R Graph    R 기초강의(19) - R KoNLP    R 기초강의(20) - R 연습문제    R 기초강의(21) - R ggmap    R 기초강의(22) - R 정형데이터 처리R 데이터 조작 실습 1ggplot2 package의 mpg data set을 이용하여 데이터 셋 조작 실습실습# ggplot2 package의 mpg data 활용install.packages(\"ggplot2\")library(ggplot2)require(dplyr)df = as.data.frame(mpg)   # mpg data frameView(df)help(df)    # mpg data set reference# 주요컬럼# manufacturer : 제조회사# displ : 배기량# cyl : 실린더 개수# drv : 구동 방식# hwy : 고속도로 연비# class : 자동차 종류# model : 자동차 모델명# year : 생산연도# trans : 변속기 종류# cty : 도시 연비# fl : 연료 종류# 1. 자동차 배기량에 따라 고속도로 연비가 다른지 알아보려 한다. # displ(배기량)이 4 이하인 자동차와 4 초과인 자동차 중 # 어떤 자동차의 hwy(고속도로 연비)가 평균적으로 더 높은지 확인하세요.result &lt;- df %&gt;%          mutate(displ_4_higher = ifelse(displ &gt; 4,\"배기량4초과\",\"배기량4이하\")) %&gt;%          group_by(displ_4_higher) %&gt;%          summarise(mean_hwy = mean(hwy))result  # 2. 자동차 제조 회사에 따라 도시 연비가 다른지 알아보려고 한다. # \"audi\"와 \"toyota\" 중 어느 manufacturer(제조회사)의 cty(도시 연비)가 # 평균적으로 더 높은지 확인하세요.result &lt;- df %&gt;%          filter(manufacturer %in% c(\"audi\",\"toyota\")) %&gt;%          group_by(manufacturer) %&gt;%          summarise(mean_cty = mean(cty))result# 3. \"chevrolet\", \"ford\", \"honda\" 자동차의 고속도로 연비 평균을 알아보려고 한다. # 이 회사들의 데이터를 추출한 후 hwy(고속도로 연비) 전체 평균을 구하세요.result &lt;- df %&gt;%          filter(manufacturer %in% c(\"chevrolet\",\"ford\",\"honda\")) %&gt;%          summarise(mean_hwy = mean(hwy))result# 4. \"audi\"에서 생산한 자동차 중에 어떤 자동차 모델의 hwy(고속도로 연비)가 # 높은지 알아보려고 한다. \"audi\"에서 생산한 자동차 중 hwy가 1~5위에 해당하는 # 자동차의 데이터를 출력하세요.result &lt;- df %&gt;%          filter(manufacturer == \"audi\") %&gt;%          arrange(desc(hwy)) %&gt;%          head(5)result# 5. mpg 데이터는 연비를 나타내는 변수가 2개입니다. # 두 변수를 각각 활용하는 대신 하나의 통합 연비 변수를 만들어 사용하려 합니다. # 평균 연비 변수는 두 연비(고속도로와 도시)의 평균을 이용합니다. # 회사별로 \"suv\" 자동차의 평균 연비를 구한후 내림차순으로 정렬한 후 1~5위까지 데이터를 출력하세요.result &lt;- df %&gt;%          mutate(avg_rate = (cty+hwy)/2) %&gt;%          filter(class == \"suv\") %&gt;%          group_by(manufacturer) %&gt;%          summarise(mean_avg_rate = mean(avg_rate)) %&gt;%          arrange(desc(mean_avg_rate)) %&gt;%          head(5)result# 6. mpg 데이터의 class는 \"suv\", \"compact\" 등 자동차의 특징에 따라 # 일곱 종류로 분류한 변수입니다. 어떤 차종의 도시 연비가 높은지 비교하려 합니다. # class별 cty 평균을 구하고 cty 평균이 높은 순으로 정렬해 출력하세요.result &lt;- df %&gt;%          group_by(class) %&gt;%          summarise(mean_cty = mean(cty)) %&gt;%          arrange(desc(mean_cty))result# 7. 어떤 회사 자동차의 hwy(고속도로 연비)가 가장 높은지 알아보려 합니다. # hwy(고속도로 연비) 평균이 가장 높은 회사 세 곳을 출력하세요.result &lt;- df %&gt;%          group_by(manufacturer) %&gt;%          summarise(mean_hwy = mean(hwy)) %&gt;%          arrange(desc(mean_hwy)) %&gt;%          select(manufacturer) %&gt;%          head(3)result# 8. 어떤 회사에서 \"compact\" 차종을 가장 많이 생산하는지 알아보려고 합니다. # 각 회사별 \"compact\" 차종 수를 내림차순으로 정렬해 출력하세요.result &lt;- df %&gt;%          filter(class == \"compact\") %&gt;%          group_by(manufacturer) %&gt;%          summarise(ncount = n()) %&gt;%          arrange(desc(ncount))resultR 데이터 조작 실습 2MovieLens DataSet을 이용하여 데이터 조작 실습. MovieLens DataSet은 Group Lens(미네소타 대학 컴퓨터과의 research lab)에서 수집한 영화 데이터 입니다.영화의 선호 정보를 1~5사이의 점수로 표현한 데이터입니다.(5에 가까울수록 선호)아래의 링크를 통해 데이터를 다운로드 할 수 있습니다.  MovieLens DataSet실습# MovieLens DataSet 활용# 1. 사용자가 평가한 모든 영화의 전체 평균 평점# 2. 각 사용자별 평균 평점# 3. 각 영화별 평균 평점# 4. 평균 평점이 가장 높은 영화의 제목# ( 동률이 있을 경우 모두 출력)# 5. Comedy영화 중 가장 평점이 낮은 영화의 제목# 6. 2015년도에 평가된 모든 Romance 영화의 평균 평점은?End.이 포스트의 내용은 아래의 책과 사이트를 참조했습니다.    조금 더 자세한 사항을 알고 싶으시면 책을 참조하거나 해당 사이트를 방문하세요!!    Do It! 쉽게 배우는 R 데이터 분석 저자 GitHub",
        "url": "/R-lecture-R-dplyr-exercise"
    }
    ,
    
    "r-lecture-r-dplyr": {
        "title": "R 기초강의(14) - R 데이터 조작",
            "author": "moon9342",
            "category": "",
            "content": "R 강좌는 여러 절로 구성되어 있습니다.     R 기초강의(1) - R 개요    R 기초강의(2) - R Operator    R 기초강의(3) - R Data Type    R 기초강의(4) - R 패키지와 함수    R 기초강의(5) - R 자료구조(vector)    R 기초강의(6) - R 자료구조(matrix)    R 기초강의(7) - R 자료구조(factor, list)    R 기초강의(8) - R 자료구조(data frame)    R 기초강의(9) - R 문자열 처리    R 기초강의(10) - R 데이터 입출력    R 기초강의(11) - R 제어문 및 함수    R 기초강의(12) - R 기초 Exercise    R 기초강의(13) - R Crawling    R 기초강의(14) - R 데이터 조작    R 기초강의(15) - R 데이터 조작 실습    R 기초강의(16) - R 데이터 정제    R 기초강의(17) - R 기초 통계 함수    R 기초강의(18) - R Graph    R 기초강의(19) - R KoNLP    R 기초강의(20) - R 연습문제    R 기초강의(21) - R ggmap    R 기초강의(22) - R 정형데이터 처리R 데이터 조작데이터 분석 업무에서는 데이터 모델링이나 시각화에 적합한 데이터를 얻기위해복잡한 과정을 거치게 됩니다. 실제 분석 프로젝트에서 절반 이상의 시간을 데이터 구축과 변환과 조작, 필터링과 전처리 작업에 할당합니다.이번에는 데이터 조작에 특화된 몇 가지 package를 살펴보도록 하겠습니다.데이터 분석을 하기 위해서는 먼저 데이터의 구조를 파악해야 하며 R은 분석할 데이터의 구조를 쉽게 파악할 수 있도록 몇가지 함수를 제공합니다.데이터 구조를 파악하기 위해 사용하는 기본 함수  class() : 자료구조(메모리구조)를 파악하기 위한 함수.  head() : 데이터의 앞부분을 추출하는 함수. 기본값은 data frame일 경우 앞에서 6행까지 추출.  tail() : 데이터의 뒷부분을 추출하는 함수. 기본값은 data frame일 경우 뒤에서 6행까지 추출.  View() : View 창에서 데이터 출력.  dim() : data frame의 행과 열의 개수를 구하는 함수. 선형구조에 적용 불가능.  nrow() : data frame의 행의 개수를 구하는 함수. 선형구조에 적용 불가능.  ncol() : data frame의 column의 개수를 구하는 함수. 선형구조에 적용 불가능.  str() : 데이터에 들어있는 column들의 속성을 확인하기 위한 함수.  summary() : 요약 통계량을 산출하는 함수.  ls() : data frame의 column 항목을 vector로 추출하는 함수.  length() : 벡터의 길이, data frame일 경우 column의 개수를 구하는 함수.실습  위에서 언급된 각 함수를 이용해 데이터 구조를 파악해 보자.  사용하는 데이터 셋은 ggplot2 package의 mpg data set, hflights package의 hflights data set, 그리고간단한 엑셀파일을 사용하자.  mpg : 1999년에서 2008년 까지 인기 차종 38개에 대한 연비데이터.  hflights : 2011년도 미국 휴스턴에서 출발하는 모든 비행기의 이륙과 착륙 정보가 기록된것으로 약 22만건의 관측치와 21개의 column으로 구성된 데이터 셋  mpg reference manual  hflights package reference manual# ggplot2 설치install.packages(\"ggplot2\")library(ggplot2)# mpg data set 이용mpgmpg = as.data.frame(mpg)   # mpg data frameclass(mpg)ls(mpg)# 주요컬럼# 컬럼의 명세 : R Document(https://www.rdocumentation.org/)# manufacturer : 제조회사# displ : 배기량(Displacement)# cyl : 실린더 개수# drv : 구동 방식( f: 전륜구동, r : 후륜구동, 4 : 4륜구동)# hwy : 고속도로 연비 (miles per gallon) #                     1gal : 3.8리터, 1mile : 1609.34m# class : 자동차 종류# model : 자동차 모델명# year : 생산연도# trans : 변속기 종류# cty : 도시 연비# fl : 연료 종류head(mpg)tail(mpg)View(mpg)dim(mpg)         # 234행, 11 columnnrow(mpg)ncol(mpg)str(mpg)ls(mpg)length(mpg)      # data frame인 경우 column의 개수summary(mpg)rev(head(mpg))   # vector인 경우 원소의 순서를 역순으로# data frame인 경우 column을 역순으로# 여기서 잠깐!! 4분위에 대해서 실습하고 넘어가자# 사분위수 : 측정값을 오름차순으로 정렬한 후 4등분했을 때# 각 등위에 해당하는 값을 의미.# 중앙값(중위수)는 2사분위값에 해당.# 총 13개의 데이터data = c(1, 3, 5, 7, 9, 10, 11, 13, 14, 17, 20, 23, 25)summary(data)# 1사분위 =&gt; 1 + (0.25 * 12) = 4(번째 값) =&gt; 7# 3사분위 =&gt; 1 + (0.75 * 12) = 10(번째 값) =&gt; 17########################################################## hflights package설치# 주요컬럼# Year(년), Month(일), DayofMonth(일), DayofWeek(요일)# AirTime(비행시간), DepTime(출발시간), ArrTime(도착시간)# TailNum(항공기 일련번호), DepDelay(출발지연시간)# ArrDelay(도착지연시간), Distance(비행거리)# 다른컬럼의 의미는 reference 참조install.packages(\"hflights\")library(hflights)class(hflights)   # data framehead(hflights)    # 상위 6행 출력tail(hflights)    # 하위 6행 출력View(hflights)    # View 창으로 출력dim(hflights)     # 행,열 (227496,21)     str(hflights)     # 변수의 속성확인summary(hflights) # 요약 통계                  # mean : 평균                  # median : 중앙값# 평균은 편향된 데이터와 이상치 때문에 그릇된 정보를# 제공하는 경우가 있음. 이런 경우 값을 작은수에서# 큰 수로 정렬한 후 중앙에 있는 값을 계산해서 사용ls(hflights)      # column명을 vector로 출력nrow(hflights)    # 행의 개수ncol(hflights)    # 열의 개수length(hflights)  # 열의 개수# matrix에 length()를 적용하면 열의 개수가 아니라# 모든 원소의 개수를 리턴한다.rev()             # vector인 경우 원소의 순서를 역순으로# data frame인 경우 column을 역순으로####################################################### iris dataset# 통계학자인 피셔(Fisher) 가 소개한 데이터.# 붓꽃(iris)의 3가지 종(setosa, versicolor, virginica)에 대해 # 꽃받침(sepal)과 꽃잎(petal)의 길이를 정리한 데이터# R에 기본으로 내장# Species : 붓꽃의 종. setosa, versicolor, virginica (Factor)# Sepal.Width : 꽃받침의 너비 (numeric)# Sepal.Length : 꽃받침의 길이 (numeric)# Petal.Width : 꽃잎의 너비 (numeric)# Petal.Length : 꽃잎의 길이 (numeric)head(iris)rev(head(iris))View(iris)str(iris)summary(iris)rev(iris)# 2016년 2017년 ATM 이용건수와 이용금액# 제공된 2016_2017_이용건수_및_이용금액.xlsx 파일 이용install.packages(\"xlsx\")library(xlsx)df &lt;- read.xlsx(file.choose(),                sheetIndex = 1,                encoding = \"UTF-8\")head(df)View(df)str(df)summary(df)rev(ls(df))plyr packageplyr package는 두 개 이상의 data frame을 대상으로 Key 값을 이용하여 하나의 data frame으로병합하거나 집단변수를 기준으로 data frame 변수에 함수를 적용하여 요약집계 결과를 구할 때 유용한 함수를 제공하는 package입니다.실습# plyr package# 1. data frame 병합install.packages(\"plyr\")library(plyr)x &lt;- data.frame(id=c(1,2,3,4,6),                height=c(160,175,180,177,194))y &lt;- data.frame(id=c(5,4,1,3,2),                weight=c(55,73,80,94,77))# join() : key값을 기준으로 두 개의 data frame을 하나로 병합# left join이 defaultinner_df = join(x,y, by=\"id\", type=\"inner\")  # inner joininner_dfleft_df = join(x,y, by=\"id\", type=\"left\") # left joinleft_dfright_df = join(x,y, by=\"id\", type=\"right\") # right joinright_dffull_df = join(x,y, by=\"id\", type=\"full\") # full joinfull_dfx &lt;- data.frame(id=c(1,2,3,4,6),                gender=c(\"M\",\"F\",\"M\",\"F\",\"M\"),                height=c(160,175,180,177,194))y &lt;- data.frame(id=c(5,4,1,3,2),                gender=c(\"M\",\"F\",\"M\",\"F\",\"M\"),                weight=c(55,73,80,94,77))df &lt;- join(x,y, by=c(\"id\",\"gender\"), type=\"inner\")df# 2. 그룹별 기술 통계량 구하기# tapply() : 집단별 통계치를 구해주며 한번에 1개의 통계치만 구할 수 있다.str(iris)unique(iris$Species)result = tapply(iris$Sepal.Length, iris$Species, FUN=mean)resultresult = tapply(iris$Sepal.Length, iris$Species, FUN=sd)result# ddply() : 한번에 여러개의 통계치를 구할 수 있다.result = ddply(iris,                .(Species),                summarise,               avg=round(mean(Sepal.Length),2),               sd=round(sd(Sepal.Length),2),               max=max(Sepal.Length))resultView(result)    # data framedplyr packagedplyr package는 기존의 plyr package의 성능과 기능을 개선한 package입니다. plyr package는 R 언어로 구현되었기 때문에속도가 느렸으나 dplyr package는 C++로 개발되어서 속도가 빠른 장점이 있습니다.또한 data frame을 제어하는데 특화된 함수를 제공함으로 정형화된 데이터를 처리하는데 적합하며 %&gt;% 기호를 이용하여 함수들을 나열하는 방식(chaining)으로 코드를 작성할 수 있습니다.dplyr package에서 제공되는 주요 함수  tbl_df() : 데이터 셋에서 console창의 크기만큼 데이터 셋을 추출하는 기능  rename() : 데이터 셋의 column명을 수정하는 기능  filter() : 데이터 셋에서 조건에 맞는 데이터 셋을 추출하는 기능  select() : 데이터 셋을 대상으로 특정 column들을 추출하는 기능  arrange() : 데이터 셋을 특정 column으로 정렬하는 기능  mutate() : 데이터 셋에 새로운 column을 추가하는 기능  group_by() : 데이터 셋의 범주형 column을 대상으로 그룹화하는 기능  summaries() : 데이터 셋의 특정 column으로 요약 집계하는 기능  left_join() : 데이터 셋 left join 기능(다른 join도 함수로 제공)  bind_rows() : 데이터 셋을 행 기준으로 합치는 기능  bind_cols() : 데이터 셋을 열 기준으로 합치는 기능실습  실습에 사용할 엑셀파일은 아래의 링크에서 다운로드해서 사용합니다.  2016_2017_이용건수_및_이용금액.xlsx# dplyr packageinstall.packages(\"dplyr\")library(dplyr)library(xlsx)excel_data &lt;- read.xlsx(file.choose(),                        sheetIndex = 1,                        encoding = \"UTF-8\")excel_data# 1. tbl_df()df &lt;- tbl_df(excel_data)df    # 현재 R의 console 크기에서 볼 수 있는 만큼 결과 출력      View(df)# 2. rename(data frame, newVar = var, ...)df &lt;- rename(excel_data,              Y17_AMT = AMT17,             Y16_AMT = AMT16)df    # column명 변경# 3. filter(data frame, 조건1, 조건2, ... )df &lt;- filter(excel_data,              AREA == \"서울\" &amp; AMT17 &gt;500000)dfdf &lt;- filter(excel_data,              AREA == \"서울\",              SEX == \"M\",             AMT16 &gt; 350000)dfdf &lt;- filter(excel_data,              AREA %in% c(\"서울\",\"경기\"),              SEX == \"M\",             AMT16 &gt; 350000)df# 4. arrange(data frame, column1, desc(column2), ...)df &lt;- filter(excel_data,              SEX != \"M\") %&gt;%      arrange(AREA,               desc(AMT17))df# 5. select(data frame, column1, column2, ...)df &lt;- filter(excel_data,              SEX == \"M\") %&gt;%      arrange(AREA,               desc(AMT17)) %&gt;%      select(ID,AREA:Y17_CNT)dfdf &lt;- filter(excel_data,              SEX == \"M\") %&gt;%      arrange(AREA,               desc(AMT17)) %&gt;%      select(-SEX)df# 6. 새로운 column 생성df &lt;- filter(excel_data,              SEX == \"M\") df$AMT15 = df$AMT16 + 10000dfdf$VIP = ifelse(df$AMT15 &gt; 500000, TRUE, FALSE)df# 7. mutate(data fame, column명1=수식1, column명2=수식2)df &lt;- filter(excel_data,              SEX == \"M\") %&gt;%      mutate(AMT15=AMT16 + 10000,              AMT14=AMT15+10000,             VIP=ifelse(AMT15 &gt; 500000, TRUE, FALSE))df# 8. summaries(data frame, 추가할column명1=함수(column명))df &lt;- filter(excel_data,              SEX == \"M\") %&gt;%      mutate(AMT15=AMT16 + 10000,              AMT14=AMT15+10000) %&gt;%      summarise(sum=sum(AMT14, na.rm=T), cnt=n())df# 9. group_by(data frame, 범주형 column)df &lt;- filter(excel_data,              AMT17 &gt; 300000) %&gt;%      group_by(SEX) %&gt;%      summarise(sum=sum(AMT17, na.rm=T), cnt=n()) df# 10. bind_rows(), bind_cols()df1 &lt;- data.frame(x=c(1,2,3))df1df2 &lt;- data.frame(y=c(4,5,6))df2bind_rows(df1,df2)df2 = rename(df2, x = y)bind_rows(df1,df2)bind_cols(df1,df2)reshape2 packagereshape2 package를 설명하기 전에 다음의 파일을 data frame으로 읽어들여보자.sample_mpg &lt;- read.csv(file=\"C:/R_workspace/R_Lecture/data/sample_mpg.csv\",               sep = \",\",               header = T,               fileEncoding = \"UTF-8\") sample_mpg   # 일반적인 data frame 형태melt_sample_mpg &lt;- read.csv(file=\"C:/R_workspace/R_Lecture/data/melt_sample_mpg.csv\",                            sep = \",\",                            header = T,                            fileEncoding = \"UTF-8\")melt_sample_mpg   # column이 row로 표현된 형태!!# raw data의 데이터 형태가 읽어들인 형태처럼 되어 있을 경우# 어떻게 처리해야 하는가?# 평균 도시연비는?# 1. 일반적인 data frame인 경우mean(sample_mpg$cty)# 2. column이 row로 표현된 경우melt_sample_mpg %&gt;%   filter(variable == \"cty\") %&gt;%  summarise(avg_cty = mean(value))# 평균 연비를 구해서 새로운 column을 구하려면?# 1. 일반적인 data frame인 경우sample_mpg %&gt;%  mutate(avg_rate = (cty+hwy)/2)       # 2. column이 row로 표현된 경우## 감도 안온다!!reshape2 package는 수집한 데이터를 분석하기 편한 형태로 가공할 때 사용하는대표적인 package입니다.reshape2 package안에는 대표적인 2개의 함수가 존재하며 주로 이 함수를 이용합니다.melt() 함수  column을 행(row)으로 바꾸어서 가로로 긴 형태의 데이터를 세로로 길게 전환하는 함수입니다.  melt는 변수(variable)에 대해 값(value)를 매칭하는 방식으로 넓게 퍼진 데이터를 길게 변형합니다.  melt의 기본 동작방식은 numeric data를 포함하고 있는 모든 열들을 variable로 만드는 것입니다.  melt(data frame, id.var=”기준 열”, measure.vars=c(“…”,”…”)실습  R에 기본으로 내장되어 있는 data set인 airquality를 이용하여 melt() 함수를 실습해보자.install.packages(\"reshape2\")library(reshape2)df = airqualityclass(df)str(df)     # 153행 6열dfView(df)# melt()의 기본은 기준이 될 열을 지정하지 않으면 # numeric data type의 모든 열을 행으로 변환melt(df)       melt(df, na.rm = T)         # value값이 NA인 것은 제외nrow(melt(df))              # 생성된 총 row수 : 153 * 6 = 918# month를 기준으로 데이터를 행으로 변환melt(df,id.vars=\"Month\")    nrow(melt(df,id.vars=\"Month\"))  # 생성된 총 row수 : 153 * 5 = 765# month와 day를 기준으로 데이터를 행으로 변환melt(df,id.vars=c(\"Month\",\"Day\"))nrow(melt(df,id.vars=c(\"Month\",\"Day\"))) # 생성된 총 row수 : 153 * 4 = 612# month와 day를 기준으로 ozone데이터만 행으로 변환melt(df,     id.vars=c(\"Month\",\"Day\"),     measure.vars=\"Ozone\")# smiths data set을 이용하여 melt를 실습해보자smithsmelt_smiths &lt;- melt(smiths,                    id.vars=c(\"subject\"))melt_smiths   # 8행melt_smiths &lt;- melt(smiths,                    id.vars=c(\"subject\",\"time\"))melt_smiths   # 6행melt_smiths &lt;- melt(smiths,                    id.vars=c(\"subject\",\"time\",\"age\"))melt_smiths   # 4행melt_smiths &lt;- melt(smiths,                    id.vars=c(\"subject\",\"time\",\"age\"),                    na.rm = T)melt_smiths   # 3행# 다른 데이터 셋으로 실습install.packages(\"ggplot2\")library(ggplot2)library(reshape2)library(dplyr)mpgdf &lt;- as.data.frame(mpg)melt(df)melt(df, id.vars=\"model\")melt(df, id.vars=c(\"manufacturer\",\"model\"),     measure.vars=\"cty\")dcast() 함수  세로로 길게 늘어진 데이터(melt된 데이터)를 가로로 변행해야 하는 경우에 사용  cast() 함수 종류 중 data frame의 형태를 반환하는 경우에는 dcast()를 사용합니다.  melt된 데이터를 원상 복구하거나 통계 함수를 이용한 변형에 사용됩니다.실습df = airquality; dfmelt_df &lt;- melt(df,id.vars=c(\"Month\",\"Day\")); head(melt_df)# Month를 기준으로 각 값들의 meandcast_df &lt;- dcast(melt_df,                  formula=Month ~ variable,                  fun=mean,                  na.rm=T)dcast_df# 모든 column 원상 복구dcast_df &lt;- dcast(melt_df,                  formula=Month + Day ~ ...)dcast_df#############################df &lt;- as.data.frame(mpg)melt_df &lt;- melt(df, id.vars=c(\"manufacturer\",\"model\"),                measure.vars=\"cty\")melt_df;dcast_df &lt;- dcast(melt_df,                  formula=manufacturer ~ variable,                  fun=mean)dcast_df## cf. 각 제조사별 cty의 평균df &lt;- as.data.frame(mpg)df %&gt;% group_by(manufacturer) %&gt;%       summarise(avg_cty=mean(cty))## 입력받은 데이터파일을 정상적인 data frame으로 변환melt_sample_mpgresult &lt;- dcast(melt_audi_df,                manufacturer + model + year +                   cyl + trans + drv + fl + class ~ d_name,                value.var = \"d_value\")resultEnd.이 포스트의 내용은 아래의 책과 사이트를 참조했습니다.    조금 더 자세한 사항을 알고 싶으시면 책을 참조하거나 해당 사이트를 방문하세요!!    Do It! 쉽게 배우는 R 데이터 분석 저자 GitHub",
        "url": "/R-lecture-R-dplyr"
    }
    ,
    
    "r-lecture-r-crawling": {
        "title": "R 기초강의(13) - R Crawling",
            "author": "moon9342",
            "category": "",
            "content": "R 강좌는 여러 절로 구성되어 있습니다.     R 기초강의(1) - R 개요    R 기초강의(2) - R Operator    R 기초강의(3) - R Data Type    R 기초강의(4) - R 패키지와 함수    R 기초강의(5) - R 자료구조(vector)    R 기초강의(6) - R 자료구조(matrix)    R 기초강의(7) - R 자료구조(factor, list)    R 기초강의(8) - R 자료구조(data frame)    R 기초강의(9) - R 문자열 처리    R 기초강의(10) - R 데이터 입출력    R 기초강의(11) - R 제어문 및 함수    R 기초강의(12) - R 기초 Exercise    R 기초강의(13) - R Crawling    R 기초강의(14) - R 데이터 조작    R 기초강의(15) - R 데이터 조작 실습    R 기초강의(16) - R 데이터 정제    R 기초강의(17) - R 기초 통계 함수    R 기초강의(18) - R Graph    R 기초강의(19) - R KoNLP    R 기초강의(20) - R 연습문제    R 기초강의(21) - R ggmap    R 기초강의(22) - R 정형데이터 처리R CrawlingWeb Crawling의 일반적인 개념은 인터넷 상에서 필요한 정보를 읽어와서 수집하는 작업이라고 할 수 있습니다.하지만 좀 더 구체적으로 다음과 같은 두 가지 작업으로 정의할 수 있습니다.Web Scraping (웹 스크래핑)  웹 스크래핑은 웹사이트상에서 원하는 부분에 위치한 정보를 컴퓨터로 하여금 자동으로 추출하여 수집하도록 하는 기술을 의미합니다.Web Crawling (웹 크롤링)  자동화 봇인 웹 크롤러가 정해진 규칙에 따라 복수개의 웹페이지를 browsing하는 행위를 의미하며 다른 말로 Web spidering 이라고도 합니다.여기서는 Web Scraping을 위해 CSS(혹은 jQuery)의 selector와 XPATH를 이용하는 방법을 알아보겠습니다.아래는 많이 사용되는 Selector에 대한 예시 입니다.실습  네이버 영화 사이트 댓글 정보를 Scraping 및 Crawling 처리를 해 보겠습니다.# 네이버 영화 사이트 댓글정보 스크래핑# 필요한 package 설치 및 loadinginstall.packages(\"rvest\"); library(rvest)# 네이버 영화 검색 후 평점,리뷰 부분url &lt;- \"http://movie.naver.com/movie/point/af/list.nhn\"page &lt;- \"page=\"request_url &lt;- str_c(url,\"?\",page,\"1\")page_html &lt;- read_html(request_url,  encoding=\"CP949\")page_html;# 영화제목 추출nodes &lt;- html_nodes(page_html, \"td.title &gt; a.movie\")nodesmovie_title &lt;- html_text(nodes)movie_title# 기존에는 영화 평점도 있었지만 지금은 공개하지 않음.# 영화리뷰 추출# CSS를 이용(완전하지 않음-영화제목이 포함됨)# nodes &lt;- html_nodes(page_html, \"td.title\")# movie_review &lt;- html_text(nodes, trim=TRUE);# movie_review# 문자열 처리필요(데이터 정제)# movie_review &lt;- str_remove_all(movie_review,\"\\t\")# movie_review &lt;- str_remove_all(movie_review,\"\\n\")# movie_review &lt;- str_remove_all(movie_review,\"신고\")# movie_review# XPATH를 이용movie_review = vector(mode=\"character\", length=10)for(i in 1:10) {  myPath = str_c('//*[@id=\"old_content\"]/table/tbody/tr[',                 i,                 ']/td[2]/text()')  nodes &lt;- html_nodes(page_html, xpath=myPath)  comment &lt;- html_text(nodes, trim=TRUE);  movie_review[i] = comment[3]}movie_reviewresult_page &lt;- cbind(movie_title, movie_review)write.csv(result_page,           file=\"C:/R_workspace/R_Lecture/data/movie_reviews.csv\",          row.names = FALSE,          quote = FALSE,          fileEncoding = \"CP949\")실습  위의 코드를 이용해서 Crawling 처리까지 진행해 보겠습니다.extract_comment &lt;- function(idx) {  url &lt;- \"http://movie.naver.com/movie/point/af/list.nhn\"  page &lt;- \"page=\"    request_url &lt;- str_c(url,\"?\",page,idx)    page_html &lt;- read_html(request_url,  encoding=\"CP949\")    # 영화제목 추출  nodes &lt;- html_nodes(page_html, \"td.title &gt; a.movie\")  movie_title &lt;- html_text(nodes)    # 영화리뷰 추출  movie_review = vector(mode=\"character\", length=10)  for(i in 1:10) {    myPath = str_c('//*[@id=\"old_content\"]/table/tbody/tr[',                   i,                   ']/td[2]/text()')    nodes &lt;- html_nodes(page_html, xpath=myPath)    comment &lt;- html_text(nodes, trim=TRUE);    movie_review[i] = comment[3]  }    result_page &lt;- cbind(movie_title, movie_review)  return(result_page)}result_df = data.frame();for(i in 1:10) {  result_df = rbind(result_df,extract_comment(i))}View(result_df)실습  로튼토마토 사이트에서 2019년 가장 인기있는 영화 100개의 영화제목, User Rating, Genre를 추출해서 data frame으로 구축해보자# 개인별 수행R에서 Kakao Open API 활용이번에는 Kakao 검색 API를 이용하여 이미지 검색을 하고 검색된 이미지를 파일로 저장하는 R 코드를 작성해 보도록 하겠습니다.install.packages(\"httr\")library(httr)url &lt;- \"https://dapi.kakao.com/v2/search/image\"keyword &lt;- \"query=\"#request_url = str_c(url,\"?\",keyword,scan(what=character()))request_url = str_c(url,\"?\",keyword,\"아이유\")request_url = URLencode(request_url)   # 한글처리request_urlapiKey &lt;- \"1bf8c91dbc8dd1814aa97f2614a1d730\"result &lt;- GET(request_url,              add_headers(Authorization = paste(\"KakaoAK\", apiKey)))http_status(result)   # 접속 상태result_data &lt;- content(result)  # 결과데이터View(result_data)for(i in 1:length(result_data$documents)) {  res = GET(result_data$documents[[i]][[\"thumbnail_url\"]])  writeBin(content(res, 'raw'),            paste('C:/R_workspace/R_Lecture/img/image',                 i,                 \".png\",                 sep=\"\"))}RSelenium을 이용한 동적 데이터 CrawlingAJAX를 이용해 화면을 Rendering하는 Front-End Web Application은 위의 방법으로는Crawling이 불가능합니다.이런 경우 RSelenium을 이용해 Crawling을 수행할 수 있습니다.Selenium Standalone ServerChrome DriverR 코드를 실행하기 전에 다음의 코드를 실행 해 Selenium Server를 실행해야 합니다.(Java가 설치되어 있어야 합니다.)java -jar selenium-server-standalone.jar -port 4445# Seleniuminstall.packages(\"RSelenium\")library(RSelenium)# Selenium 서버에 접속하고 remoteDriver 객체 리턴remDr &lt;- remoteDriver(remoteServerAddr=\"localhost\",                       port = 4445,                       browserName = \"chrome\")# Chrome browser OpenremDr$open()# 특정 page 랜더링remDr$navigate(\"http://localhost:8080/bookSearch/index.html\")# 입력 상자를 CSS를 이용해서 찾기webElem &lt;- remDr$findElement(using=\"css\", \"[type=text]\")# 검색어를 입력하고 enter key 입력#webElem$sendKeysToElement(list(\"여행\", key=\"enter\"))webElem$sendKeysToElement(list(\"여행\"))# click을 할element를 xpath를 이용해서 찾기# CSS로 찾으면 잘 수행되지 않음.btn &lt;- remDr$findElement(using=\"xpath\",                          value='//*[@id=\"inputText\"]')# 찾은 element click event 처리btn$clickElement()# AJAX 호출로 나온 결과 데이터 추출liElem &lt;- remDr$findElements(using=\"xpath\",                              value='//*[@id=\"myList\"]/li')myList = sapply(liElem,function(x){x$getElementText()})class(myList)for(idx in 1:length(myList)) {  print(myList[[idx]])}공공데이터 포탈의 Open API를 활용한 데이터 구축공공데이터 포털의 데이터를 이용하여 데이터를 구축할 수 있다.서울특별시 버스노선경로 목록정보를 제공하는 Open API를 이용하여 데이터를 구축해보자.REST API를 이용해야 하며 결과가 XML로 리턴된다.# 개인별 수행End.이 포스트의 내용은 아래의 책과 사이트를 참조했습니다.    조금 더 자세한 사항을 알고 싶으시면 책을 참조하거나 해당 사이트를 방문하세요!!    Do It! 쉽게 배우는 R 데이터 분석 저자 GitHub",
        "url": "/R-lecture-R-crawling"
    }
    ,
    
    "r-lecture-r-basic-exercise": {
        "title": "R 기초강의(12) - R 기초 Exercise",
            "author": "moon9342",
            "category": "",
            "content": "R 강좌는 여러 절로 구성되어 있습니다.     R 기초강의(1) - R 개요    R 기초강의(2) - R Operator    R 기초강의(3) - R Data Type    R 기초강의(4) - R 패키지와 함수    R 기초강의(5) - R 자료구조(vector)    R 기초강의(6) - R 자료구조(matrix)    R 기초강의(7) - R 자료구조(factor, list)    R 기초강의(8) - R 자료구조(data frame)    R 기초강의(9) - R 문자열 처리    R 기초강의(10) - R 데이터 입출력    R 기초강의(11) - R 제어문 및 함수    R 기초강의(12) - R 기초 Exercise    R 기초강의(13) - R Crawling    R 기초강의(14) - R 데이터 조작    R 기초강의(15) - R 데이터 조작 실습    R 기초강의(16) - R 데이터 정제    R 기초강의(17) - R 기초 통계 함수    R 기초강의(18) - R Graph    R 기초강의(19) - R KoNLP    R 기초강의(20) - R 연습문제    R 기초강의(21) - R ggmap    R 기초강의(22) - R 정형데이터 처리R 기초 Exercise연습문제# 다음의 데이터를 사용해 문제를 해결하세요!!# 사용할 데이터 : 2 3 5 6 7 10# 1. 데이터 벡터 x를 만드시오x &lt;- c(2,3,5,6,7,10); x# 2. 각 데이터의 제곱으로 구성된 벡터 x2를 만드시오x2 &lt;- c(2,3,5,6,7,10)^2; x2# 3. 각 데이터의 제곱의 합을 구하시오sum(c(2,3,5,6,7,10)^2)# 4. 각 데이터에서 2를 뺀 값을 구하시오var1 &lt;- c(2,3,5,6,7,10)-2; var1# 5. 최대값과 최소값을 구하시오maxValue = max(c(2,3,5,6,7,10))minValue = min(c(2,3,5,6,7,10))cat(\"최대 :\",maxValue,\", 최소 :\",minValue)# 6. 5보다 큰 값들로만 구성된 데이터 벡터 x_up을 만드시오var1 = c(2,3,5,6,7,10); var1var2 = c(2,3,5,6,7,10) &gt; 5; var2var1[var2]              # fancy indexing# 7. 벡터 x의 길이를 구하시오length(x)# UsingR 패키지를 인스톨한 후 내장되어 있는 데이터셋 primes를 이용하여 답하시오. # primes는 1부터 2003 까지의 소수(prime number)들의 집합이다.install.packages(\"UsingR\")library(UsingR)data(\"primes\")  # primes 데이터 셋을 불러옵니다.head(primes)    # 처음 6개만 출력# 8. 1부터 2003까지 몇 개의 소수가 있는가?length(primes)  # 304# 9. 1부터 200까지 몇 개의 소수가 있는가?sum(primes &lt;= 200)   # 46# 10. 평균은 얼마인가?mean(primes)         # 917.9375# 11. 1000 이상의 소수는 몇 개인가?sum(primes &gt;= 1000)  # 136# 12. 500 부터 1000 사이의 소수만을 포함한 벡터 pp를 만드시오pp = primes[primes &gt; 500 &amp; primes&lt;1000]; pp# 13. 벡터를 입력을 받아 그 원소들의 값을 모두 더해서 결과를 반환하는 # mysum 함수를 작성하시오.mysum &lt;- function(var) {  result = sum(var)  return(result)}var1 = c(1:10)mysum(var1)# 다음과 같은 형태의 데이터를 이용하여 다음의 문제를 해결하세요# x =# [ 1, 5, 9,#   2, 6, 10,#   3, 7, 11,#   4, 8, 12 ]# 14. 행렬(matrix) x를 만드시오.var1 = c(1,5,9,2,6,10,3,7,11,4,8,12)x = matrix(data=var1,           nrow=4,           byrow=T)x# 15. x의 전치행렬 xt를 만드시오.xt = t(x); xt# 16. x의 첫번째 행(row)만 뽑아낸 xr1을 만드시오xr1 = x[1,]; xr1# 17. x의 세번째 열(col)만 뽑아낸 xc3을 만드시오xc3 = x[,3]; xc3# 18. x에서 6,7,10,11을 원소로 가지는 부분행렬 xs를 만드시오xs = x[2:3,2:3]; xs# 19. x의 두번째 열(col)의 원소가 홀수인 행(row)들만 뽑아서 부분행렬 xs2를 만드시오xs2 = x[x[,2] %% 2 == 1,]; xs2# 20. 20. matrix x의 각 행(row)의 평균을 구하시오apply(X=x, MARGIN = 1, FUN=mean)# 21. 20. matrix x의 각 열(col)의 평균을 구하시오apply(X=x, MARGIN = 2, FUN=mean)# DMwR라는 패키지를 설치후, 패키지에 포함된 데이터셋인 algae를 로딩하시오. # algae의 속성 중 NH4 의 값들에 대해,# 22. NA(결측치)가 몇개인지 구하시오install.packages(\"DMwR\")library(DMwR)data(algae)head(algae)var1 = algae[,\"NH4\"]var1sum(is.na(var1))   # 2# 23. 결측치를 제거하고 평균을 구하시오.mean(var1[!is.na(var1)])    # 501.2958End.이 포스트의 내용은 아래의 책과 사이트를 참조했습니다.    조금 더 자세한 사항을 알고 싶으시면 책을 참조하거나 해당 사이트를 방문하세요!!    Do It! 쉽게 배우는 R 데이터 분석 저자 GitHub",
        "url": "/R-lecture-R-basic-exercise"
    }
    ,
    
    "r-lecture-r-control-function": {
        "title": "R 기초강의(11) - R 제어문 및 함수",
            "author": "moon9342",
            "category": "",
            "content": "R 강좌는 여러 절로 구성되어 있습니다.     R 기초강의(1) - R 개요    R 기초강의(2) - R Operator    R 기초강의(3) - R Data Type    R 기초강의(4) - R 패키지와 함수    R 기초강의(5) - R 자료구조(vector)    R 기초강의(6) - R 자료구조(matrix)    R 기초강의(7) - R 자료구조(factor, list)    R 기초강의(8) - R 자료구조(data frame)    R 기초강의(9) - R 문자열 처리    R 기초강의(10) - R 데이터 입출력    R 기초강의(11) - R 제어문 및 함수    R 기초강의(12) - R 기초 Exercise    R 기초강의(13) - R Crawling    R 기초강의(14) - R 데이터 조작    R 기초강의(15) - R 데이터 조작 실습    R 기초강의(16) - R 데이터 정제    R 기초강의(17) - R 기초 통계 함수    R 기초강의(18) - R Graph    R 기초강의(19) - R KoNLP    R 기초강의(20) - R 연습문제    R 기초강의(21) - R ggmap    R 기초강의(22) - R 정형데이터 처리R 제어문R은 Java나 Python과 마찬가지로 조건문이나 반복문을 사용할 수 있습니다. 각각의 제어문을 예를 들어 알아보겠습니다.if  Java언어의 if문 사용과 유사합니다.# if문var1 = 30var2 = 40if(var1 &gt; var2) {  cat(\"큰 수는 :\",var1)} else {  cat(\"큰 수는 :\",var2)}ifelse  Java언어의 3항 연산자 사용과 유사합니다.var1 = 30var2 = 40ifelse(var1 &gt; var2,var1,var2)switch  비교문의 결과에 따라 여러 개의 실행문장 중 하나를 선택할 수 있습니다.# switchemp_name = scan(what=character())switch(emp_name,       \"홍길동\"=30,       \"김길동\"=40,       \"최길동\"=50)which  vector를 대상으로 특정 데이터를 검색하는 용도로 사용됩니다. 조건식을 만족하는 경우 vector 원소의 index가 리턴되며, 조건식이 거짓이면 0을 리턴합니다.# whichname &lt;- c(\"최길동\",\"강감찬\",\"이순신\")which(name == \"강감찬\")       # 2which(name != \"강감찬\")       # 1 3 which(name == \"신사임당\")     # integer(0)for  반복문으로 일반적인 for-each구문처럼 사용됩니다.# forfor(n in seq(1,5)) {  print(n)}while  Java의 while문과 유사합니다.# whileidx = 1sum &lt;- 0while(idx &lt;= 10) {  sum = sum + idx    idx = idx + 1}cat(\"숫자의 합은 :\",sum)R 사용자 정의 함수함수는 코드의 집합입니다. 일반적으로 패키지로 제공되는 함수를 이용하지만 사용자가 직접 필요한 코드를 작성하여사용자 정의 함수를 만들어 사용할 수 있습니다.사용자 정의 함수  함수명 &lt;- function(매개변수) { 실행문 } 의 형태로 선언합니다.# 사용자 정의 함수myFunc &lt;- function(k) {  cat(\"인자의 값은 :\",k)  return(k+100)}result = myFunc(100)resultEnd.이 포스트의 내용은 아래의 책과 사이트를 참조했습니다.    조금 더 자세한 사항을 알고 싶으시면 책을 참조하거나 해당 사이트를 방문하세요!!    Do It! 쉽게 배우는 R 데이터 분석 저자 GitHub",
        "url": "/R-lecture-R-control_function"
    }
    ,
    
    "r-lecture-r-data-io": {
        "title": "R 기초강의(10) - R 데이터 입출력",
            "author": "moon9342",
            "category": "",
            "content": "R 강좌는 여러 절로 구성되어 있습니다.     R 기초강의(1) - R 개요    R 기초강의(2) - R Operator    R 기초강의(3) - R Data Type    R 기초강의(4) - R 패키지와 함수    R 기초강의(5) - R 자료구조(vector)    R 기초강의(6) - R 자료구조(matrix)    R 기초강의(7) - R 자료구조(factor, list)    R 기초강의(8) - R 자료구조(data frame)    R 기초강의(9) - R 문자열 처리    R 기초강의(10) - R 데이터 입출력    R 기초강의(11) - R 제어문 및 함수    R 기초강의(12) - R 기초 Exercise    R 기초강의(13) - R Crawling    R 기초강의(14) - R 데이터 조작    R 기초강의(15) - R 데이터 조작 실습    R 기초강의(16) - R 데이터 정제    R 기초강의(17) - R 기초 통계 함수    R 기초강의(18) - R Graph    R 기초강의(19) - R KoNLP    R 기초강의(20) - R 연습문제    R 기초강의(21) - R ggmap    R 기초강의(22) - R 정형데이터 처리R 데이터 입출력데이터 분석을 하기 위해서는 가장 먼저 분석에 필요한 데이터들을 준비해야 합니다. 이번에는 R의 데이터입출력에 대해서 알아보겠습니다.키보드 입력  scan()함수와 edit()함수를 이용하여 키보드로 직접 데이터를 입력할 수 있습니다.# scan() 함수myNum = scan()    # console창의 prompt를 이용하여 숫자 데이터 입력myNummyStr = scan(what=character())  # 문자열 데이터 입력myStr# data frame에 edit()를 이용해 데이터 입력df = data.frame();my_df = edit(df)    # 데이터 편집기 실행R 로컬 파일 사용파일에 저장된 데이터를 가져오기 위해 R은 다양한 함수를 제공하고 있습니다.read.table() 함수  테이블 형태로 작성되어 있으며 각 컬럼이 구분자로 구분된 자료 파일을 불러 올 수 있는 함수# read.table() 함수 이용# header가 있는 경우 \"header=TRUE\"를 이용getwd()setwd(str_c(getwd(),\"/data\"))# text 파일 데이터 최 하단에 개행이 1줄 있어야 한다.student_midterm = read.table(file=\"student_midterm.txt\", sep=\",\")student_midterm  # 한글이 있는 경우 encoding 설정이 필요# header가 있는 경우 header=T 필요student_midterm = read.table(file=\"student_midterm.txt\",                              sep=\",\",                             fileEncoding = \"UTF-8\",                             header = T)student_midterm names(student_midterm) = c(\"학번\",\"반\",\"국어\",\"영어\")student_midterm      # 만약 탐색기를 실행해서 파일을 선택하려면 file.choose() 사용student_midterm = read.table(file.choose(), sep=\",\")student_midterm# 파일의 특정 문자열을 NA로 처리하여 파일을 불러올 수 있다.student_midterm = read.table(file=\"student_midterm_na.txt\", sep=\",\", na.strings=\"-\")student_midtermread.csv() 함수 이용  CSV(Comma Separated Value)파일은 comma(“,”)를 기준으로 각 column을 구분하여 저장한 데이터 형식을 의미합니다. read.csv() 함수는 “,”가 sep의 기본값이며 header=TRUE가 기본값입니다.# read.csv() 함수 이용getwd()setwd(str_c(getwd(),\"/data\"))student_midterm = read.csv(file=\"student_midterm.csv\", sep=\",\")student_midterm      read.xlsx() 함수 이용  엑셀 파일을 R에서 불러올 수 있습니다. 일단 먼저 xlsx 패키지를 설치해야 합니다. (xlsx 패키지는 rJava 패키지와dependency가 있습니다. )# read.xlsx() 함수 이용install.packages(\"xlsx\")Sys.setenv(JAVA_HOME=\"C:\\\\Program Files\\\\Java\\\\jre1.8.0_221\")library(xlsx)student_midterm = read.xlsx(file.choose(), sheetIndex=1, encoding=\"UTF-8\")student_midterm텍스트 파일에 출력  텍스트 파일에 출력하기 위해서는 3가지 함수를 이용할 수 있습니다.  write.table() : data frame을 텍스트 파일에 저장할 때 사용합니다.  cat() : 분석결과(vector)를 텍스트 파일에 저장할 때 사용합니다.  capture.output() : 분석결과(list,table)를 텍스트 파일에 저장할 때 사용합니다.  write.table() 함수 이용      R 스크립트에서 처리된 data frame을 저장할 수 있는 함수입니다. 행 번호를제거하는 속성은 row.names=FALSE 이고 따옴표를 제거하는 속성은 quote=FALSE 입니다.  # # write.table() 함수 이용 - data frame 저장getwd()setwd(str_c(getwd(),\"/data\"))student_midterm = read.table(file=\"student_midterm.txt\", sep=\",\")student_midterm      names(student_midterm) = c(\"학번\",\"반\",\"국어\",\"영어\")student_midterm    write.table(student_midterm, file=\"student_write_table.txt\")write.table(student_midterm, file=\"student_write_table.txt\", row.names=FALSE, quote=FALSE)  텍스트 파일 처리 예# cat() 함수 이용cat(\"계산된 결과값은 :\",    \"\\n\",\"\\n\",    file=\"c:/R_workspace/R_Lecture/data/final_result.txt\",    append=TRUE)# data frame을 출력 write.table(student_midterm,             file=\"c:/R_workspace/R_Lecture/data/final_result.txt\",             row.names=FALSE,             quote=FALSE,             append = T)# data frame의 summary를 파일에 출력capture.output(summary(student_midterm),    file=\"c:/R_workspace/R_Lecture/data/final_result.txt\",    append=TRUE)  write.xlsx() 함수 이용      R에서 처리된 결과를 엑셀 파일로 저장할 수 있습니다.  # write.xlsx() 함수 이용 - 데이터 저장libray(xlsx)getwd()setwd(str_c(getwd(),\"/data\"))df = data.frame(x=c(1:5),                y=seq(2,10,2),                z=c(\"a\",\"b\",\"c\",\"d\",\"e\"))write.xlsx(df,\"df_write.xlsx\")R에서 JSON 처리이번에는 jsonlite package를 사용해서 JSON 데이터를 R DataFrame 으로 변환하거나 R DataFrame 을 JSON 데이터로 변환하는 방법을 살펴보겠습니다.사용하는 데이터는 Servlet으로 작성한 도서검색 프로그램을 실행해서 결과로 나온 JSON을이용하도록 하겠습니다.도서검색 프로그램에서 사용할 MySQL DB Script도서검색 프로그램에서 사용할 Server Side Web Application# JSON 처리# jsonlite package의 fromJSON() 함수를 사용install.packages(\"jsonlite\")library(jsonlite)# install.packages(\"httr\")# library(httr)library(stringr)url &lt;- \"http://localhost:8080/bookSearch/search\"keyword &lt;- \"keyword=\"request_url = str_c(url,\"?\",keyword,scan(what=character()))request_urldf = fromJSON(request_url) # 키워드가 영문일경우df = fromJSON(URLencode(request_url)) # 키워드가 한글일 경우 encoding처리 필요str(df)names(df)View(df)# 찾은 도서 제목 출력for(i in 1:nrow(df)) {  print(df$title[i])}# data frame을 CSV 파일로 저장write.csv(df,          file=\"C:/R_workspace/R_Lecture/data/df.csv\",          quote=FALSE,          row.names=FALSE)# data frame을 JSON 파일로 저장help(toJSON)df_json &lt;- toJSON(df)df_jsonlibrary(stringr)getwd()setwd(str_c(getwd(),\"/data\"));      write(df_json,file = \"df_json.json\");write(prettify(df_json),      file = \"df_json_prettify.json\");비슷한 예로 영화진흥위원회에서 제공하는 Open API를 이용하여 일별 Box Office 순위에 대한정보를 data frame으로 변환해 보겠습니다.영화진흥위원회 Open APIurl = \"http://www.kobis.or.kr/kobisopenapi/webservice/rest/boxoffice/searchDailyBoxOfficeList.json\"key = \"key=bb9595efebb93c44b9f1271e52bcdf74\"date = \"targetDt=20191010\"library(stringr)request_url = str_c(url,\"?\",key,\"&amp;\",date)df = fromJSON(request_url)View(df)class(df[[1]])class(df[[1]][[\"dailyBoxOfficeList\"]])class(df[[1]][[\"dailyBoxOfficeList\"]]$movieNm)for(i in 1:10) {  print(df[[1]][[\"dailyBoxOfficeList\"]]$movieNm[i])}End.이 포스트의 내용은 아래의 책과 사이트를 참조했습니다.    조금 더 자세한 사항을 알고 싶으시면 책을 참조하거나 해당 사이트를 방문하세요!!    Do It! 쉽게 배우는 R 데이터 분석 저자 GitHub",
        "url": "/R-lecture-R-data_io"
    }
    ,
    
    "r-lecture-r-stringr-package": {
        "title": "R 기초강의(9) - R 문자열 처리",
            "author": "moon9342",
            "category": "",
            "content": "R 강좌는 여러 절로 구성되어 있습니다.     R 기초강의(1) - R 개요    R 기초강의(2) - R Operator    R 기초강의(3) - R Data Type    R 기초강의(4) - R 패키지와 함수    R 기초강의(5) - R 자료구조(vector)    R 기초강의(6) - R 자료구조(matrix)    R 기초강의(7) - R 자료구조(factor, list)    R 기초강의(8) - R 자료구조(data frame)    R 기초강의(9) - R 문자열 처리    R 기초강의(10) - R 데이터 입출력    R 기초강의(11) - R 제어문 및 함수    R 기초강의(12) - R 기초 Exercise    R 기초강의(13) - R Crawling    R 기초강의(14) - R 데이터 조작    R 기초강의(15) - R 데이터 조작 실습    R 기초강의(16) - R 데이터 정제    R 기초강의(17) - R 기초 통계 함수    R 기초강의(18) - R Graph    R 기초강의(19) - R KoNLP    R 기초강의(20) - R 연습문제    R 기초강의(21) - R ggmap    R 기초강의(22) - R 정형데이터 처리R 문자열 처리빅데이터를 처리하기 위해서 필요한 문자열을 자르거나 교체 혹은 추출하는 작업은항상 빈번하게 발생합니다. 문자열을 효과적으로 처리하기 위한 패키지인 stringr을 설치하고제공되는 함수를 알아보도록 하겠습니다.stringr package가 제공하는 함수  str_length() : 문자열 길이 반환  str_c() : 문자열 연결, str_join()의 개선형  str_sub() : 범위에 해당하는 부분 문자열 생성  str_split() : 구분자를 기준으로 문자열을 분리하여 부분 문자열 생성  str_replace() : 기존 문자열을 특정 문자열로 교체  str_extract() : 문자열에서 특정 문자열 패턴의 첫번째 문자열 추출  str_extract_all() : 문자열에서 특정 문자열 패턴의 모든 문자열 추출  str_locate() : 문자열에서 특정 문자열 패턴의 첫번째 위치 찾기  str_locate_all() : 문자열에서 특정 문자열 패턴의 모든 위치 찾기# 패캐지 설치와 로드install.packages('stringr')library(\"stringr\")# 문자열 길이와 위치myStr &lt;- \"Hongkd1051Leess1002YOU25홍길동2005\"str_length(myStr)       # 31str_locate(myStr,\"홍길동\")# 부분문자열 str_sub(myStr,1,str_length(myStr)-7)# 대소문자 변경str_to_upper(myStr)str_to_lower(myStr)# 문자열 교체, 결합, 분리myStr &lt;- \"Hongkd1051,Leess1002,YOU25,홍길동2005\"str_replace(myStr,\"Hong\",\"KIM\")str_c(myStr,\",이순신2019\")str_split(myStr,\",\")str1 &lt;- c(\"홍길동\",\"김길동\",\"이순신\",\"강감찬\")paste(str1,collapse=\",\")R 정규표현식문자열 처리를 쉽고 간단하게 하기 위해서는 정규표현식 사용이 필수입니다. 정규표현식은약속된 기호들에 의해서 표현됩니다.정규표현식에서 [] 기호는 대괄호 안의 문자가 한 번만 반복되고 {n}은 n만큼 반복됩니다. 예를들면,[a-z]의 의미는 a에서 z까지 범위 중에서 한 개의 영문 소문자를 의미하며 [a-z]{3}은 영문 소문자가연속으로 3개 발생한다는 의미입니다.실습  여러가지 정규표현식을 이용해 문자열을 제어해보자myStr &lt;- \"Hongkd1051,Leess1002,YOU25,홍길동2005\"str_extract_all(myStr,\"[a-z]{3}\")  # 영문소문자 연속 3문자 추출str_extract_all(myStr,\"[a-z]{3,}\") # 영문소문자 연속 3문자 이상 추출str_extract_all(myStr,\"[a-z]{3,5}\") # 영문소문자 연속 3~5문자 추출str_extract_all(myStr,\"Hong\")  # 해당 문자열 추출str_extract_all(myStr,\"[가-힣]{3}\") # 연속된 3개의 한글 문자 추출str_extract_all(myStr,\"[0-9]{4}\") # 연속된 4개의 숫자문자 추출str_extract_all(myStr,\"[^a-z]\") # 영문 소문자 제외한 나머지 추출str_extract_all(myStr,\"[^가-힣]{5}\") # 한글을 제외한 나머지 연속된 5개 추출str_extract_all(myStr,\"[^0-9]{3}\") # 숫자를 제외한 나머지 연속된 3개 추출myId &lt;- \"901010-1000432\"str_extract_all(myId,\"[0-9]{6}-[1234][0-9]{6}\") #주민번호 검사str_extract_all(myId,\"\\\\d{6}-[1234]\\\\d{6}\")myStr &lt;- \"Hongkd1051,Leess1002,YOU25,홍길동2005\"str_extract_all(myStr,\"\\\\w{6}\") # w는 한글,영문자,숫자문자를 포함하지만 특수문자는 제외End.이 포스트의 내용은 아래의 책과 사이트를 참조했습니다.    조금 더 자세한 사항을 알고 싶으시면 책을 참조하거나 해당 사이트를 방문하세요!!    Do It! 쉽게 배우는 R 데이터 분석 저자 GitHub",
        "url": "/R-lecture-R-stringr_package"
    }
    ,
    
    "r-lecture-r-dataframe": {
        "title": "R 기초강의(8) - R 자료구조(data frame)",
            "author": "moon9342",
            "category": "",
            "content": "R 강좌는 여러 절로 구성되어 있습니다.     R 기초강의(1) - R 개요    R 기초강의(2) - R Operator    R 기초강의(3) - R Data Type    R 기초강의(4) - R 패키지와 함수    R 기초강의(5) - R 자료구조(vector)    R 기초강의(6) - R 자료구조(matrix)    R 기초강의(7) - R 자료구조(factor, list)    R 기초강의(8) - R 자료구조(data frame)    R 기초강의(9) - R 문자열 처리    R 기초강의(10) - R 데이터 입출력    R 기초강의(11) - R 제어문 및 함수    R 기초강의(12) - R 기초 Exercise    R 기초강의(13) - R Crawling    R 기초강의(14) - R 데이터 조작    R 기초강의(15) - R 데이터 조작 실습    R 기초강의(16) - R 데이터 정제    R 기초강의(17) - R 기초 통계 함수    R 기초강의(18) - R Graph    R 기초강의(19) - R KoNLP    R 기초강의(20) - R 연습문제    R 기초강의(21) - R ggmap    R 기초강의(22) - R 정형데이터 처리R data frame데이터 프레임(Data Frame)은 R에서 가장 많이 사용하는 데이터 형태로 행과 열로 구성된 2차원 형태의 표를 지칭합니다.data frame의 특징  데이터베이스의 테이블 구조와 유사.  column 단위로 서로 다른 데이터의 저장이 가능.  list와 vector의 혼합형으로 column은 list, column내의 데이터는 vector형태.Data Frame에서 열(column), 속성, 변수는 모두 같은 표현이고 행(row), case 역시 같은 표현입니다.  행의 개수가 중요한가? 열의 개수가 중요한가?      데이터가 크다는 의미는 행 혹은 열이 많다는 것을 의미하고 데이터 분석 관점에서 본다면 행의 개수보다 열의 개수가 많은 것이 더 중요합니다. 행의 개수가 늘어나면 같은 로직으로 처리 시간이 늘어나는 것을 의미하지만 열이 늘어나면 변수들의 상관 관계를 분석하는 경우의 수가 늘어나는 것을 의미하기 때문입니다.  Data Frame 사용에 대한 이해를 돕기 위해 Data Frame을 생성하고 분석하는 코드를 간단히 작성합니다.실습  여러 개의 vector를 이용하여 data frame을 생성할 수 있다. 이때 모든 column은 길이가 같아야 한다.  list에서 $는 key를 의미하지만 data frame의 $는 column을 의미한다.# data frame 생성# vector를 이용한 data frame 생성no = c(1,2,3)name = c(\"홍길동\",\"최길동\",\"김길동\")pay = c(250,150,300)df = data.frame(NO=no,Name=name,Pay=pay)df# matrix를 이용한 data frame 생성mat1 = matrix(data = c(1,\"홍길동\",150,                       2,\"최길동\",150,                       3,\"김길동\",300),              nrow = 3,              by=T)           # 행 우선mat1memp = data.frame(mat1)memp# 3개의 vector를 이용하여 data frame 생성df = data.frame(x=c(1:5),                y=seq(2,10,2),                z=c(\"a\",\"b\",\"c\",\"d\",\"e\"))df# data frame의 column을 참조하기 위해서는 $ 이용df$x           # 1 2 3 4 5R data frame 데이터 처리 함수str()함수는 data frame의 구조를 보여주는 함수입니다.실습  data frame을 생성하고 str()함수로 구조를 파악해보자.# str() 함수의 사용df = data.frame(x=c(1:5),                y=seq(2,10,2),                z=c(\"a\",\"b\",\"c\",\"d\",\"e\"))str(df)# 'data.frame':\t5 obs. of  3 variables:# $ x: int  1 2 3 4 5# $ y: num  2 4 6 8 10# $ z: Factor w/ 5 levels \"a\",\"b\",\"c\",\"d\",..: 1 2 3 4 5df = data.frame(x=c(1:5),                y=seq(2,10,2),                z=c(\"a\",\"b\",\"c\",\"d\",\"e\"),                stringsAsFactors = F)dfstr(df)    # factor가 아닌 문자열 형태로 사용summary()함수는 data frame의 데이터를 대상으로 간단한 통계를 보여주는 함수입니다.# summary() 함수의 사용summary(df)apply()함수는  apply(data frame,행/열,함수)의 형식으로 사용되며 data frame의 데이터를 대상으로특정 함수를 적용해 연산을 할 수 있습니다.실습  주어진 data frame의 1,2번째 column에 대해 각각 합계를 구하시오.# apply() 함수의 사용df = data.frame(x=c(1:5),                y=seq(2,10,2),                z=c(\"a\",\"b\",\"c\",\"d\",\"e\"))apply(df[,c(1,2)],2,sum)        subset()함수는 data frame의 데이터를 대상으로 조건에 만족하는 행을 추출하여 독립된 data frame을생성하는 함수입니다.# subset() 함수의 사용df = data.frame(x=c(1:5),                y=seq(2,10,2),                z=c(\"a\",\"b\",\"c\",\"d\",\"e\"))sub1 &lt;- subset(df, x&gt;=3)   # x가 3이상인 행 추출sub1sub2 &lt;- subset(df, x&gt;=3 &amp; y&lt;=8)sub2연습문제# 연습문제# 1. 4,6,5,7,10,9,4,15를 R의 숫자형 벡터 x로 만드세요.x &lt;- c(4,6,5,7,10,9,4,15)x# 2. 아래의 두 벡터의 계산 결과는?x1 = c(3,5,6,8)x2 = c(3,3,3)x1+x2                 # 6 8 9 11# 3. Data Frame과 subset을 이용하여 다음의 결과를 도출하세요Age &lt;- c(22, 25, 18, 20)Name &lt;- c(\"James\", \"Mathew\", \"Olivia\", \"Stella\")Gender &lt;- c(\"M\", \"M\", \"F\", \"F\")##   Age   Name Gender## 1  22  James      M## 2  25 Mathew      Mdf = data.frame(Age=Age,                Name=Name,                Gender=Gender)dfdf_subset = subset(df,Gender != \"F\")df_subset# 4. 다음의 계산 결과는?의미없는 문제 삭제# 5. 아래의 R코드를 실행한 결과는?x &lt;- c(2, 4, 6, 8)y &lt;- c(TRUE, TRUE, FALSE, TRUE)sum(x[y])           # 14# 6. 아래의 계산결과는?x &lt;- c(1,2,3,4)(x+2)[(!is.na(x)) &amp; x &gt; 2] -&gt; kk         # 5 6# 7. 아래의 벡터에서 결측치의 수를 구하는 R코드를 작성하세요x &lt;- c(34, 56, 55, 87, NA, 4, 77, NA, 21, NA, 39)is.na(x)sum(is.na(x))# 8. 아래 두 벡터를 결합하는 코드이다. 결과는?a=c(1,2,4,5,6)b=c(3,2,4,1,9)cbind(a,b)# 9. 아래 두 벡터를 결합하는 코드이다. 결과는?a=c(10,2,4,15)b=c(3,12,4,11)rbind(a,b)# 10. 아래 R 코드의 결과는?x=c(1:12)length(x)# 11. 아래 R 코드의 결과는?x=c('blue',10,'green',20)is.character(x)          # TRUE# 12. 아래의 세개의 벡터를 이용하여 아래의 결과가 나오도록 리스트(Date)를 만들어라.year=c(2005:2016)month=c(1:12)day=c(1:31)# Date# $year#  [1] 2005 2006 2007 2008 2009 2010 2011 2012 2013 2014 2015 2016# $month#  [1] 1 2 3 4 5 6 7 8 9 10 11 12# $day#  [1] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31Date = list(year=year,            month=month,            day=day)Date# 13. 아래의 행렬계산 결과는?M=matrix(c(1:9),3,3,byrow=T)N=matrix(c(1:9),3,3)M%*%N# 14. 아래의 데이터를 데이터프레임(Department)으로 만들어라.#DepartmentID\tDepartmentName#31\t          영업부#33\t          기술부#34\t          사무부#35\t          마케팅End.이 포스트의 내용은 아래의 책과 사이트를 참조했습니다.    조금 더 자세한 사항을 알고 싶으시면 책을 참조하거나 해당 사이트를 방문하세요!!    Do It! 쉽게 배우는 R 데이터 분석 저자 GitHub",
        "url": "/R-lecture-R-dataframe"
    }
    ,
    
    "r-lecture-r-factor-list": {
        "title": "R 기초강의(7) - R 자료구조(factor, list)",
            "author": "moon9342",
            "category": "",
            "content": "R 강좌는 여러 절로 구성되어 있습니다.     R 기초강의(1) - R 개요    R 기초강의(2) - R Operator    R 기초강의(3) - R Data Type    R 기초강의(4) - R 패키지와 함수    R 기초강의(5) - R 자료구조(vector)    R 기초강의(6) - R 자료구조(matrix)    R 기초강의(7) - R 자료구조(factor, list)    R 기초강의(8) - R 자료구조(data frame)    R 기초강의(9) - R 문자열 처리    R 기초강의(10) - R 데이터 입출력    R 기초강의(11) - R 제어문 및 함수    R 기초강의(12) - R 기초 Exercise    R 기초강의(13) - R Crawling    R 기초강의(14) - R 데이터 조작    R 기초강의(15) - R 데이터 조작 실습    R 기초강의(16) - R 데이터 정제    R 기초강의(17) - R 기초 통계 함수    R 기초강의(18) - R Graph    R 기초강의(19) - R KoNLP    R 기초강의(20) - R 연습문제    R 기초강의(21) - R ggmap    R 기초강의(22) - R 정형데이터 처리R factorR에서의 factor는 범주형 데이터를 표현하기 위한 데이터 형태입니다. 범주형 자료로 표현되면 집단별로 통계분석과같은 작업을 수행할 수 있습니다.부연설명하자면, 범주형 데이터란 데이터가 사전에 정의된 특정 유형으로만 분류되는 경우를 의미합니다. 방의 크기를“대”, “중”, “소”로 나누어 표현하고 있을 때 특정 방의 크기를 “대” 라고 명시한다면 이는 범주형 데이터 입니다.그리고 범주형 변수가 담을 수 있는 값의 목록(“대”, “중”, “소”)을 level이라고 합니다.의미를 잘 생각해보면 factor는 저장할 값 뿐만 아니라 값의 level도 명시해야 합니다. 범주형 데이터는 또 다시명목형과 순서형이 있습니다. 명목형은 값들 크기 비교가 불가능한 경우를 의미하고(좌파,우파) 순서형 데이터는 순서를둘 수 있는 경우를 의미합니다.(대, 중, 소)factor()의 특징  입력 인자는 일반적으로 vector를 사용합니다.  levels : 그룹으로 지정할 문자형 vector를 지정합니다. 만약 사용하지 않으면오름차순으로 데이터를 자체적으로 그룹지정 합니다.  ordered : TRUE면 순서형, FALSE면 명목형 데이터를 뜻합니다. 기본값은 FALSE입니다.             level에 지정한 순서대로 값의 크기가 정해집니다.실습  6명의 혈액형 데이터를 vector에 저장하고 vector를 factor로 변환, 확인하는 코드를 작성해보자.# factor 생성var1 = c(\"A\", \"O\", \"AB\", \"B\", \"A\", \"O\", \"A\")var1var1_factor = factor(var1)var1_factor                   # factor이기 때문에                               # data와 level이 같이 출력nlevels(var1_factor)          # factor의 level개수                              # 4 levels(var1_factor)           # factor의 level 목록                              # \"A\"  \"AB\"  \"B\"  \"O\"is.factor(var1_factor)        # factor인지를 판단ordered(var1)                 # 순서형 factor 생성# level과 order 지정# level에 지정이 안되면 NA로 처리var1_factor = factor(var1,                      levels = c(\"O\",\"A\",\"B\"),                      ordered = T)var1_factorvar1_factor = factor(var1,                      levels = c(\"O\",\"A\",\"B\",\"AB\"),                      ordered = T)var1_factorlevels(var1_factor) = c(\"A형\",\"AB형\",\"B형\",\"O형\")levels(var1_factor)           var1_factor                  # 결과를 꼭 확인해보자실습  남성과 여성의 데이터로 factor를 생성한 후 빈도수에 대한 chart를 그려보자# 남성과 여성의 데이터르 factor 생성 후 chart 그리기gender = c(\"MAN\", \"WOMAN\", \"MAN\", \"MAN\", \"WOMAN\")genderfactor_gender = as.factor(gender)factor_gendertable(factor_gender)     # 빈도수 구하기plot(factor_gender)      # 빈도수로 막대그래프 생성R listlist는 일반적으로 통계분석의 결과를 저장할 때 많이 사용하는 데이터 형태입니다. list의원소로 scalar, vector, matrix, array, data frame, factor, 또 다른 list를 가질 수 있습니다.list는 vector와 유사한 선형 자료구조입니다. list 하나의 메모리 영역에는 key와 value가 한 쌍으로저장됩니다. Python의 dict와 유사한 자료구조라고 생각하시면 됩니다. 단, list는 dict와는 다르게 순서가존재합니다.실습  지금까지 배운 자료구조들을 list안에 저장해보자.# list var_scalar = 100                            # scalarvar_scalarvar_vector = c(10,20,30)                    # vectorvar_vectorvar_matrix = matrix(1:4,nrow = 2,ncol = 2)  # matrixvar_matrixvar_array = array(1:8, dim=c(2,2,2))        # arrayvar_arrayvar_df = data.frame(id=1:3, age=c(10,15,20)) # data framevar_dfvar_factor = factor(c(\"A\",\"B\",\"C\",\"A\",\"B\",\"A\")) # factorvar_factormy_list = list(var_scalar,               var_vector,               var_matrix,               var_array,               var_df,               var_factor)my_list위의 예에서 처럼 list() 함수를 이용하여 list를 생성합니다. list에 저장된 데이터를 출력하면[[n]]과 [n] 형식으로 출력되는데 [[n]]은 리스트를 구성하는 하나의 원소에서 key에 해당하고[n]은 value에 해당합니다.# list 생성myList &lt;- list(\"Hong\",\"길동\",20)myList# list 자료구조를 vector 자료구조로 변환myVector = unlist(myList)myVector# key와 value형식으로 list 생성member = list(name=c(\"홍길동\",\"김길동\"),              age=c(20,30),              address=c(\"서울\",\"수원\"),              gender=c(\"남자\",\"여자\"))member# list에서 key는 $를 이용해서 표시member$age                    # 20 30member$age[1]                 # 20member[[1]]                   # \"홍길동\" \"김길동\"member[[\"name\"]]              # \"홍길동\" \"김길동\"member$name                   # \"홍길동\" \"김길동\"member[2:3]End.이 포스트의 내용은 아래의 책과 사이트를 참조했습니다.    조금 더 자세한 사항을 알고 싶으시면 책을 참조하거나 해당 사이트를 방문하세요!!    Do It! 쉽게 배우는 R 데이터 분석 저자 GitHub",
        "url": "/R-lecture-R-factor_list"
    }
    ,
    
    "r-lecture-r-matrix": {
        "title": "R 기초강의(6) - R 자료구조(matrix)",
            "author": "moon9342",
            "category": "",
            "content": "R 강좌는 여러 절로 구성되어 있습니다.     R 기초강의(1) - R 개요    R 기초강의(2) - R Operator    R 기초강의(3) - R Data Type    R 기초강의(4) - R 패키지와 함수    R 기초강의(5) - R 자료구조(vector)    R 기초강의(6) - R 자료구조(matrix)    R 기초강의(7) - R 자료구조(factor, list)    R 기초강의(8) - R 자료구조(data frame)    R 기초강의(9) - R 문자열 처리    R 기초강의(10) - R 데이터 입출력    R 기초강의(11) - R 제어문 및 함수    R 기초강의(12) - R 기초 Exercise    R 기초강의(13) - R Crawling    R 기초강의(14) - R 데이터 조작    R 기초강의(15) - R 데이터 조작 실습    R 기초강의(16) - R 데이터 정제    R 기초강의(17) - R 기초 통계 함수    R 기초강의(18) - R Graph    R 기초강의(19) - R KoNLP    R 기초강의(20) - R 연습문제    R 기초강의(21) - R ggmap    R 기초강의(22) - R 정형데이터 처리R matrixMatrix 자료구조는 동일한 자료형을 갖는 2차원의 배열 구조를 의미합니다.matrix 생성방법 - matrix() 함수  c() 함수를 이용하여 matrix를 생성할 수 있습니다. c()함수는 기본적으로 열을 기준으로 matrix를생성합니다.  예시를 통해 matrix를 생성하는 다양한 방법을 익히도록 합니다.# matrix 생성var1 = matrix(c(1:5))   # 열을 기준으로 matrix 생성var1                    # 5행 1열 matrix# nrow 속성을 이용해여 지정된 행을 가지는 matrix 생성# 열 기준으로 데이터가 채워진다. var2 = matrix(c(1:10), nrow=2)var2                            # 2행 5열의 matrix                                # nrow 속성 사용시 만약 행과 열의 수가 일치하지 않는 경우var3 = matrix(c(1:13), nrow=3)var3                          # matrix 생성 시 행 우선으로 데이터를 생성하는 경우var4 = matrix(c(1:10), nrow=2, byrow=T)var4                      # vector를 대상으로 rbind()는 행 묶음으로 matrix를 생성# vector를 대상으로 cbind()는 열 묶음으로 matrix를 생성var5 = c(1,2,3,4)var6 = c(5,6,7,8)mat1 = rbind(var5, var6)mat1         mat2 = cbind(var5, var6)mat2# 데이터 타입과 데이터 구조 확인mode(mat1)             # numericclass(mat1)            # matrixmatrix 접근 방법  matrix의 원소를 참조하기 위해서는 변수명[첨자,첨자] 형식으로 행과 열을 지정하여 원소에 접근합니다.  특정 행이나 특정 열만을 접근하는 경우 변수명[행첨자,], 변수명[,열첨자] 형식으로 지정할 수 있습니다.# matrix의 원소 접근var1 = matrix(1:21, nrow=3, ncol=7)var1var1[2,2]             # 2행 2열 : 5var1[2,]              # 2행var1[,3]              # 3열var1[c(1,3), c(5:7)]     # 1,3행 &amp; 5~7열length(var1)             # 모든 원소 개수 : 21nrow(var1)               # 행 개수 : 3ncol(var1)               # 열 개수 : 7# matrix적용 함수 : apply()# X : matrix, MARGIN : 1이면 행, 2면 열# FUN : 행렬 자료구조에 적용할 함수apply(X=var1, MARGIN=1, FUN=max)    # 행단위 최대값apply(X=var1, MARGIN=2, FUN=min)    # 열단위 최소값matrix 연산  matrix의 element단위의 곱 연산을 수행할 수 있습니다.  matrix의 전치행렬을 쉽게 구할 수 있습니다.  matrix product(행렬곱)을 쉽게 구할 수 있습니다.  matrix inversion(역행렬)을 쉽게 구할 수 있습니다.# matrix 연산var1 = matrix(c(1:6), ncol=3)var1var2 = matrix(c(1,-1,2,-2,1,-1), ncol=3)var2var1*var2   # elementwise product(element단위의 곱연산)t(var1)     # transpose matrix (전치행렬)var3 = matrix(c(1,-1,2,-2,1,-1), ncol=2)var3var1 %*% var3   # matrix product (행렬곱)# 역행렬 : matrix A가 nxn matrix일 때, # 아래를 만족하는 nxn matrix B가 존재하면 B를 A의 역행렬이라 한다.# AB = BA = I(단위행렬 E)# 가우스 조던 소거법을 이용하여 계산.var1 = matrix(c(1,2,3,3,0,1,5,4,2), ncol=3)var1solve(var1)     # matrix inversion (역행렬)R arrayArray 자료구조는 동일한 자료형을 갖는 다차원의 배열 구조를 의미합니다. 행렬과 유사하게첨자로 접근해서 사용합니다. 하지만 다른 자료구조에 비해 활용도는 낮습니다.간단하게 array를 생성하는 방법만 알아보겠습니다.# array 생성var1 = array(c(1:24), dim=c(3,2,4)) # 1~24의 데이터를 이용                                # 3행 2열 4면의 3차원 array 생성var1 End.이 포스트의 내용은 아래의 책과 사이트를 참조했습니다.    조금 더 자세한 사항을 알고 싶으시면 책을 참조하거나 해당 사이트를 방문하세요!!    Do It! 쉽게 배우는 R 데이터 분석 저자 GitHub",
        "url": "/R-lecture-R-matrix"
    }
    ,
    
    "r-lecture-r-vector": {
        "title": "R 기초강의(5) - R 자료구조(vector)",
            "author": "moon9342",
            "category": "",
            "content": "R 강좌는 여러 절로 구성되어 있습니다.     R 기초강의(1) - R 개요    R 기초강의(2) - R Operator    R 기초강의(3) - R Data Type    R 기초강의(4) - R 패키지와 함수    R 기초강의(5) - R 자료구조(vector)    R 기초강의(6) - R 자료구조(matrix)    R 기초강의(7) - R 자료구조(factor, list)    R 기초강의(8) - R 자료구조(data frame)    R 기초강의(9) - R 문자열 처리    R 기초강의(10) - R 데이터 입출력    R 기초강의(11) - R 제어문 및 함수    R 기초강의(12) - R 기초 Exercise    R 기초강의(13) - R Crawling    R 기초강의(14) - R 데이터 조작    R 기초강의(15) - R 데이터 조작 실습    R 기초강의(16) - R 데이터 정제    R 기초강의(17) - R 기초 통계 함수    R 기초강의(18) - R Graph    R 기초강의(19) - R KoNLP    R 기초강의(20) - R 연습문제    R 기초강의(21) - R ggmap    R 기초강의(22) - R 정형데이터 처리R 자료구조자료형(Data Type)은 저장된 데이터의 성격(숫자형, 문자형, 논리형)을 의미합니다. 이에 비해자료구조(Data Structure)는 변수에 저장된 데이터의 메모리 구조(배열, 리스트, 테이블)를 의미합니다.이런 메모리 구조는 객체가 생성될 때 만들어지기 때문에 자료구조를 객체형(Object Type)이라고도 합니다.R은 mode()함수를 이용하여 데이터의 자료형을 확인할 수 있으며 class() 함수를 이용하여자료구조, 즉 메모리 구조를 확인할 수 있습니다.R에서 제공하는 주요 자료구조는 크게 5가지로 분류됩니다.R의 주요 자료구조  Vector : 1차원 배열  Matrix : 2차원 배열  Array : 다차원 배열  List : 중첩 자료구조  Data Frame : 2차원 테이블 구조( 이미지출처 : https://devopedia.org/r-data-structures )            구분      1차원      2차원      n차원                  Homogeneous      vector      matrix      array              Heterogeneous      list      data frame             R의 자료구조는 크게 단일형과 다중형으로 구분됩니다. 데이터 타입이 한가지면 단일형, 여러 가지이면 다중형 입니다.위의 그림과 표에서 보듯이 단일형에는 크게 3가지, 다중형에는 크게 2가지 자료구조가 존재합니다. 이 외에 factor라고 불리는자료구조가 존재합니다.여기서는 벡터(vector)에 대해서 알아보도록 하겠습니다.vector의 특징  vector는 1차원의 선형 자료구조 형태로 만들어집니다.  vector는 하나의 Data Type으로 구성됩니다. (vector의 구성요소는 모두 같은 Data Type입니다.)  vector는 변수[첨자] 형태로 접근합니다. 첨자(index)는 1부터 시작합니다.  여기서 잠깐!!      vector 중에서 구성인자가 1개인 것을 scalar라고 합니다. 따라서 scalar는 vector 입니다.  # scalar 생성var1 &lt;- c(100)   # scalarvar1vector를 생성하는 방법은 여러가지가 있으나 여기서는 대표적인 4가지 방법에 대해서 알아보겠습니다.vector 생성방법 - c() 함수  c() 함수는 combine의 약자로 vector를 생성하는 가장 대표적인 방법입니다. 일반적으로 규칙이 없는데이터로 이루어진 vector를 생성할 때 이용됩니다. c() 함수는 vector들을 하나로 합쳐서 새로운 vector를생성할 수도 있습니다.  c() 함수는 vector를 생성할 때 사용되지만 다른 데이터 형태에서 일부의 데이터를 추출할 때도 사용됩니다.# vector 생성 - c()var1 = c(10,30,77,100)var1var2 = c(89,56,33)var2var3 = c(TRUE,FALSE,FALSE,TRUE)var3var4 = c(\"홍길동\", \"강감찬\", \"유관순\")var4var5 = c(\"홍길동\", 100, TRUE, 3.141592)var5var6 = c(var1, var2)var6var7 = c(var1, var4)var7vector 생성방법 - :  콜론(:)은 수치형에만 적용할 수 있으며 1씩 증가하거나 감소하는 규칙이 있는 값으로 vector를 생성할 때사용됩니다. start:end 형태로 사용됩니다.  콜론(:) 역시 다른 데이터 형태에서 연달아 있는 특정한 행이나 열의 데이터를 추출할 때 사용할 수 있습니다.# vector 생성 - :var1 = 1:5var1var2 = 5:0var2var3 = 3.3:10var3vector 생성방법 - seq() 함수 (등차 수열)  seq() 함수는 sequence의 약자로 콜론(:)의 일반형이라고 보시면 됩니다. 3개의 argument인 시작(from), 끝(to), 증감치(by)를 명시해서 규칙이 있는 수치형 vector를 생성할 수 있습니다.  인자의 위치에 따라 argument의 이름을 생략할 수 도 있지만 가능하면 argument 이름을 사용하는것이 readability 측면에서 좋습니다.# vector 생성 - seq()var1 = seq(from=1, to=5, by=1)var1var2 = seq(from=0.5, to=10, by=1.5)var2var3 = seq(from=10, to=5, by=-2)var3vector 생성방법 - rep() 함수  rep()함수는 지정하는 반복 횟수만큼 동일한 값이 복제되어 vector가 생성됩니다.# vector 생성 - rep()    # replicate 함수var1 = rep(1:3, times=3) # times 생략 가능var1                     # 1 2 3 1 2 3 1 2 3 var2 = rep(1:3, each=3)  # each는 각 원소가 반복할 횟수 지정var2                     # 1 1 1 2 2 2 3 3 3  vector의 Data Type 확인  앞서 설명한 mode()함수와 is계열의 함수를 이용하면 vector의 Data Type을 알아낼 수 있습니다.# vector의 Data Typevar1 = c(10,20,50,100)var1mode(var1)              # numericis.character(var1)      # FALSEis.numeric(var1)        # TRUEis.integer(var1)        # FALSE is.double(var1)         # TRUEvector의 데이터 개수 확인  vector가 가지고 있는 데이터의 개수를 알아내기 위해서는 length() 함수를 이용합니다.# vector의 개수 확인 - length()var1 = seq(1,100,2)var1var2 = c(10,20,30)var2length(var1)    # var1의 개수 - 50length(var2)    # var1의 개수 - 3var3 = seq(1,100, length = 4)  # length을 이용한 vector 생성var3vector에서 데이터 추출  vector안에서 일부 데이터를 추출할 때는 대괄호([])를 이용합니다. 다른 프로그래밍 언어의 배열을 사용하는것처럼 index를 이용하여 vector의 요소를 추출해서 사용할 수 있습니다. 단, R에서는 index의 시작이 1입니다.  index부분에는 위에서 설명한 c(), :, seq()등도 올 수 있습니다.# vector 데이터 추출var1 = c(67,90,80,50,100)var1var1[1]                   # 67var1[length(var1)]        # 100var1[2:4]                 # 90 80 50var1[c(1,2,5)]            # 67 90 100var1[seq(2,4)]            # 90 80 50var1[6]                   # NAvar1[-1]                  # 1번째를 제외한 나머지                          # 90 80 50 100var1[-(2:5)]              # 67var1[-c(1,2,4,5)]         # 80vector 데이터의 이름  names() 함수를 이용하면 vector의 원소 각각에 이름이 있으면 이름을 문자열 형태로 출력합니다. 만약 이름이없으면 NULL을 출력합니다.  vector 각 원소에 이름을 붙여주고 싶은 경우에는 c()함수와 함께 사용하여 이름을 부여할 수 있습니다.# vector의 원소 이름var1 = c(10,20,30)var1names(var1)    # NULLnames(var1) = c(\"국어\", \"영어\", \"수학\")names(var1)    # \"국어\" \"영어\" \"수학\"var1           # 이름과 데이터 함께 출력var1[1]        # index를 이용한 vector 원소 접근var1[\"국어\"]   # name을 이용한 vector 원소 접근vector의 연산  수치형 vector에 수치형 scalar를 이용하여 사칙연산을 할 수 있습니다. 또한 vector와 vector간의 빠른 연산도 지원합니다.  vector의 길이가 동등할 경우 각 vector의 요소들끼리 연산을 수행합니다.  vector의 길이가 동등하지 않을 경우 연산과정에서 데이터의 개수가 적은 vector가 데이터의 개수가 많은 vector와동일하게 데이터의 개수를 맞추게 됩니다. 즉, 데이터 개수가 차이나는 만큼 데이터의 개수가 늘어나게 됩니다. 새롭게 생성되는 데이터는 원래 가지고 있던 데이터를 순서대로 새롭게 생성되는 데이터에 지정하게 되는데 이러한 규칙을 재사용 규칙(recycling rule) 이라고 합니다.# vector간의 연산var1 = 1:3var2 = 4:6var1                      # 1 2 3var2                      # 4 5 6 var1 * 2                  # 2 4 6var1 + 10                 # 11 12 13var1 + var2               # 5 7 9var3 = 1:6var3var1 + var3               # var1 : 1 2 3 1 2 3 (recycling rule)                          # var3 : 1 2 3 4 5 6                          # 2 4 6 5 7 9var4 = 1:5var4var1 + var4               # var1 : 1 2 3 1 2 (recycling rule)                          # var4 : 1 2 3 4 5                          # 연산은 되지만 warning 발생                          # 2 4 6 5 7vector간의 집합연산  vector를 대상으로 union(), intersect(), setdiff() 함수를 적용하여 집합연산을 수행할 수 있습니다.# vector의 집합연산var1 = c(1,2,3,4,5)var2 = seq(3,7)union(var1,var2)       # 합집합 : 1 2 3 4 5 6 7intersect(var1,var2)   # 교집합 : 3 4 5setdiff(var1, var2)    # 차집합 : 1 2 vector간의 비교  vector를 대상으로 identical(), setequal() 함수를 적용하여 비교 연산을 수행할 수 있습니다.  identical()은 두 vector의 항목이 개수, 순서, 항목명이 모두 동일한 경우 TRUE를 반환하고  setequal()은 두 vector의 항목의 개수와 순서에 상관없이 항목명이 동일할 경우 TRUE를 반환합니다.# vector간의 비교연산var1 = c(\"홍길동\",\"김길동\",\"최길동\")var2 = c(\"HONG\",\"KIM\",\"CHOI\")var3 = c(\"김길동\",\"홍길동\",\"김길동\",\"최길동\")identical(var1,var3)    # FALSEsetequal(var1,var3)     # TRUEvar1 = 1:3var2 = c(1:3)var3 = c(1,2,3)class(var1); class(var2); class(var3)# data type이 다르다.identical(var1,var2)  # TRUE   identical(var1,var3)  # FALSE  요소가 없는 vector 생성  항목을 저장할 공간의 개수만 지정해서 vector를 생성할 수 있습니다.# 요소가 없는 vector 생성# 항목을 저장할 공간을 생성할 때 사용var1 = vector(mode=\"numeric\", length=10)var1End.이 포스트의 내용은 아래의 책과 사이트를 참조했습니다.    조금 더 자세한 사항을 알고 싶으시면 책을 참조하거나 해당 사이트를 방문하세요!!    Do It! 쉽게 배우는 R 데이터 분석 저자 GitHub",
        "url": "/R-lecture-R-vector"
    }
    ,
    
    "r-lecture-r-function-package": {
        "title": "R 기초강의(4) - R 패키지와 함수",
            "author": "moon9342",
            "category": "",
            "content": "R 강좌는 여러 절로 구성되어 있습니다.     R 기초강의(1) - R 개요    R 기초강의(2) - R Operator    R 기초강의(3) - R Data Type    R 기초강의(4) - R 패키지와 함수    R 기초강의(5) - R 자료구조(vector)    R 기초강의(6) - R 자료구조(matrix)    R 기초강의(7) - R 자료구조(factor, list)    R 기초강의(8) - R 자료구조(data frame)    R 기초강의(9) - R 문자열 처리    R 기초강의(10) - R 데이터 입출력    R 기초강의(11) - R 제어문 및 함수    R 기초강의(12) - R 기초 Exercise    R 기초강의(13) - R Crawling    R 기초강의(14) - R 데이터 조작    R 기초강의(15) - R 데이터 조작 실습    R 기초강의(16) - R 데이터 정제    R 기초강의(17) - R 기초 통계 함수    R 기초강의(18) - R Graph    R 기초강의(19) - R KoNLP    R 기초강의(20) - R 연습문제    R 기초강의(21) - R ggmap    R 기초강의(22) - R 정형데이터 처리R 패키지R에서 제공하는 package는 처리할 Data와 기능(function) 그리고 알고리즘이 하나의 꾸러미 형태로 제공됩니다.R 프로그래밍 실력은 얼마나 많은 package를 데이터 분석에 효과적으로 적용할 수 있는가의 능력에 따라좌우된다고 할 수 있습니다.  여기서 잠깐!!      R은 Base system과 Other package로 구분할 수 있습니다. Base System은 우리가 설치한 R을 지칭합니다.Base system에는 두가지 종류의 package가 존재하는데 Base package와 Recommended package로 구분됩니다.    Base package는 설치가 필요없고 사용하기 위해서 불러오기(library())를 할 필요가 없습니다. Recommended package는 설치가 필요없지만 사용하기 위해서는 불러오기를 해야 합니다. other package는 당연히 설치한 후에 불러오기를 해야 사용할 수 있습니다.  package의 설치  install.packages('패키지명')의 형태로 설치할 수 있습니다.  R을 설치하면 기본적으로 설치되는 package들은 설치과정없이 바로 사용할 수 있습니다.  RStudio에서 [Pakcages] 탭을 이용하여 package를 설치할 수 있습니다.  installed.packages()를 사용하면 설치된 package를 확인할 수 있습니다.  .libPaths()를 사용하면 library 설치 경로를 확인할 수 있습니다.  library 설치 경로 변경하려면 .libPaths(\"C:/myLib\") 처럼 이용하면 됩니다.R에서 package를 사용하려면 해당 package를 메모리에 로드해야 합니다. package를 메모리에 로드하기 위해서는 2가지 방법이 있습니다.package의 사용  library('패키지명')  require('패키지명')설치된 package를 제거하기 위해서는 패키지가 설치된 폴더를 찾아 직접 제거하거나 다음의 함수를이용합니다.package의 제거  remove.packages('패키지명')실습  ggplot2 package를 설치하고 사용해보자.# ggplot2 package를 설치하고 사용해보자install.packages(\"ggplot2\")library(ggplot2)# 문자로 구성된 vector 생성x &lt;- c(\"a\",\"b\",\"c\",\"a\",\"b\",\"a\")# qplot()을 이용하여 빈도 막대 그래프를 그려보자qplot(x)# ggplot2 package 삭제remove.packages(\"ggplot2\")# 다양한 package를 설치하면 package들은 R이 설치된 경로 또는 내 문서에 설치된다.# library 설치 경로 확인.libPaths()# library 설치 경로 변경.libPaths(\"c:/R_workspace/R_Lecture/lib\")R 함수R을 설치하면 기본적으로 몇개의 package가 같이 설치됩니다. 이러한 package안에 속한 함수는 별도의 설치과정없이 바로 사용할 수 있습니다. 하지만 이 수많은함수를 모두 외워서 사용하는 것은 불가능합니다. 따라서 함수 사용에 도움을 주는 몇가지 함수를 알아둬야 함수를 사용하기 편합니다.함수 도움말  help()를 이용하면 함수 도움말을 볼 수 있습니다.함수 파라미터 확인  args() 함수는 특정 함수를 대상으로 사용 가능한 파라미터를 보여줍니다.함수 사용 예제 보기  example() 함수는 R에서 제공하는 기본 함수들을 사용하는 예제를 보여줍니다.실습  함수를 사용하기 위한 도움기능을 사용해 보자.# R의 도움말 기능을 이용해보자help(mean)# 기본 함수의 파라미터를 확인해보자args(max)# 기본 함수의 사용예제example(mean)# qplot 함수의 사용예제example(qplot)R 작업공간R은 현재 작업할 작업공간(Workspace)을 확인할 수 있고, 이 작업공간의 경로를 변경할 수 있습니다.현재 작업하는 작업 공간은 getwd()를 통해 확인할 수 있습니다. 메뉴의 Tools &gt; Global Options &gt;General &gt; Default Working Directory를 통해 확인할 수 있습니다.이 작업공간을 변경하기 위해서는 setwd()함수를 이용합니다. 특정 경로로 작업공간을 변경한 후데이터 파일을 읽어오는 등의 작업을 수행할 수 있습니다. 특정 폴더를 명시할 때는 /를 이용하여 디렉토리를구분합니다.실습  현재 작업공간을 확인하고 변경하는 실습을 해보자.# 현재 작업공간 확인getwd()# 작업공간 변경setwd(\"c:/R_workspace/R_Lecture\")End.이 포스트의 내용은 아래의 책과 사이트를 참조했습니다.    조금 더 자세한 사항을 알고 싶으시면 책을 참조하거나 해당 사이트를 방문하세요!!    Do It! 쉽게 배우는 R 데이터 분석 저자 GitHub",
        "url": "/R-lecture-R-function_package"
    }
    ,
    
    "r-lecture-r-datatype": {
        "title": "R 기초강의(3) - R Data Type",
            "author": "moon9342",
            "category": "",
            "content": "R 강좌는 여러 절로 구성되어 있습니다.     R 기초강의(1) - R 개요    R 기초강의(2) - R Operator    R 기초강의(3) - R Data Type    R 기초강의(4) - R 패키지와 함수    R 기초강의(5) - R 자료구조(vector)    R 기초강의(6) - R 자료구조(matrix)    R 기초강의(7) - R 자료구조(factor, list)    R 기초강의(8) - R 자료구조(data frame)    R 기초강의(9) - R 문자열 처리    R 기초강의(10) - R 데이터 입출력    R 기초강의(11) - R 제어문 및 함수    R 기초강의(12) - R 기초 Exercise    R 기초강의(13) - R Crawling    R 기초강의(14) - R 데이터 조작    R 기초강의(15) - R 데이터 조작 실습    R 기초강의(16) - R 데이터 정제    R 기초강의(17) - R 기초 통계 함수    R 기초강의(18) - R Graph    R 기초강의(19) - R KoNLP    R 기초강의(20) - R 연습문제    R 기초강의(21) - R ggmap    R 기초강의(22) - R 정형데이터 처리R Data TypeR에는 크게 2가지 형태의 Data Type이 있습니다. 하나는 기본 데이터 타입이고 다른 하나는 특수 데이터 타입입니다.기본 데이터 타입  수치형(Numeric) : 숫자로 되어 있으며 정수형과 실수형을 의미합니다. L 기호를 이용하면정수형, 그렇지 않으면 실수형으로 간주합니다.  문자형(character) : 하나의 문자 혹은 문자열로 되어 있으며 \"\" 혹은 ''을 사용합니다.  논리형(logical) : 참과 거짓의 논리값으로 TRUE(T) 혹은 FALSE(F)로 표현됩니다.  복소수형(complex) : 실수와 허수로 이루어진 복소수형태로 표현됩니다.특수 데이터 타입  NULL : NULL은 그 자체가 객체이며 존재하지 않는 객체를 지정할 때 사용됩니다.  NA : Not Available의 약자로 결측치(missing value)를 의미합니다.  NaN : Not available Number의 약자로 수학적으로 연산이 불가능한 수를 의미합니다. 예) sqrt(-3)  Inf : Infinite의 약자로 양의 무한대를 의미합니다.  -Inf : 음의 무한대를 의미합니다.Data Type을 알려주는 함수는 mode() 함수와 is로 시작하는 함수가 제공됩니다. mode()함수는 문자열 형태로최종 결과를 알려주고 is계열의 함수는 TRUE 혹은 FALSE의 논리값으로 리턴됩니다.실습  Data Type을 알려주는 mode()함수와 is계열의 함수를 사용해보자.var1 = 100var2 = 100Lvar3 = \"HEllo\"var4 = TRUEvar5 = 4 - 3ivar6 = NULLvar7 = sqrt(-3)      # warning : NaNs producedmode(var1)           # \"numeric\" mode(var2)           # \"numeric\" mode(var3)           # \"character\"mode(var4)           # \"logical\" mode(var5)           # \"complex\"mode(var6)           # \"NULL\"mode(var7)           # \"numeric\"is.numeric(var1)     # TRUEis.numeric(var2)     # TRUEis.double(var1)      # TRUEis.integer(var1)     # FALSEis.integer(var2)     # TRUEis.character(var3)   # TRUEis.logical(var1)     # FALSEis.null(var6)        # TRUE   is.na(var7)          # TRUE제공되는 is계열의 Data Type 확인 함수는 다음과 같습니다.R은 Data Type의 우선순위가 존재합니다. 아직 설명하지는 않았지만 R에는 vector라는 자료구조가존재합니다. vector는 여러개의 데이터를 가질 수 있는 자료구조인데 하나의 Data Type만을 가질 수있습니다. 따라서 vector를 만들 때 여러 Data Type을 이용해도 최종적으로는 하나의 Data Type으로통일되며 우선순위에 의해서 최종 Data Type이 결정됩니다.  Data Type의 우선순위      문자형(character) &gt; 복소수형(complex) &gt; 수치형(numeric) &gt; 논리형(logical)  실습  vector를 이용하여 Data Type의 우선순위를 확인해보자# Data Type의 우선순위var1 &lt;- c(100,TRUE,3.1415)     # numericvar1var2 &lt;- c(100,TRUE,3.1415,\"Hello\")  # charactervar2var3 &lt;- c(100,FALSE,3-4i)  # complexvar3var4 &lt;- c(100,FALSE,3-4i,\"안녕!!\")  # charactervar4R은 하나의 Data Type을 다른 Data Type으로 변경시키는 Type Casting작업을 위해 아래와 같은 함수를 제공합니다. (아래의 함수 이외의 함수도 제공됩니다. 추가적인 함수는나올때마다 학습하도록 합니다.)실습  형변환 함수를 이용하여 하나의 Data Type을 다른 Data Type으로 변환해 보자.# Data Type 변환var1 &lt;- 3.1415var2 &lt;- 0var3 &lt;- \"3.141592\"var4 &lt;- \"Hello\"as.character(var1)      # \"3.1415\"as.double(var1)         # 3.1415  as.integer(var1)        # 3 as.numeric(var1)        # 3.1415as.logical(var1)        # TRUEas.logical(var2)        # FALSEas.double(var3)         # 3.141592as.integer(var3)        # 3as.double(var4)         # NAEnd.이 포스트의 내용은 아래의 책과 사이트를 참조했습니다.    조금 더 자세한 사항을 알고 싶으시면 책을 참조하거나 해당 사이트를 방문하세요!!    Do It! 쉽게 배우는 R 데이터 분석 저자 GitHub",
        "url": "/R-lecture-R-datatype"
    }
    ,
    
    "r-lecture-r-operator": {
        "title": "R 기초강의(2) - R Operator",
            "author": "moon9342",
            "category": "",
            "content": "R 강좌는 여러 절로 구성되어 있습니다.     R 기초강의(1) - R 개요    R 기초강의(2) - R Operator    R 기초강의(3) - R Data Type    R 기초강의(4) - R 패키지와 함수    R 기초강의(5) - R 자료구조(vector)    R 기초강의(6) - R 자료구조(matrix)    R 기초강의(7) - R 자료구조(factor, list)    R 기초강의(8) - R 자료구조(data frame)    R 기초강의(9) - R 문자열 처리    R 기초강의(10) - R 데이터 입출력    R 기초강의(11) - R 제어문 및 함수    R 기초강의(12) - R 기초 Exercise    R 기초강의(13) - R Crawling    R 기초강의(14) - R 데이터 조작    R 기초강의(15) - R 데이터 조작 실습    R 기초강의(16) - R 데이터 정제    R 기초강의(17) - R 기초 통계 함수    R 기초강의(18) - R Graph    R 기초강의(19) - R KoNLP    R 기초강의(20) - R 연습문제    R 기초강의(21) - R ggmap    R 기초강의(22) - R 정형데이터 처리R OperatorR의 기본 연산자에 대해서 알아보겠습니다. 다른 프로그래밍 언어와 거의 차이가 없으며약간 형태가 다른 연산자가 존재합니다.산술연산자에서 기억해야 할 연산자는 몫과 나머지를 구하는 연산자 입니다. 그 이외의 연산자는다른 언어와 거의 같습니다.실습  %/%를 이용하여 몫을 구해보자.  %%를 이용하여 나머지를 구해보자.var1 &lt;- 100var2 &lt;- 3                result &lt;- var1 / var2    # 기본 나누기result                   # 33.33333options(digits = 5)     # 숫자를 몇 자리까지 출력할 것인가 설정( default값은 7 )resultsprintf(\"%0.7f\",var1 / var2)   # format을 설정해서 출력result &lt;- var1 %/% var2  # 몫 구하기 result                   # 33  result &lt;- var1 %% var2   # 나머지 구하기 result                   # 1비교연산자는 다른 언어와 그 사용이 같습니다. 대신 두 값의 비교로서 맞으면 TRUE, 맞지 않으면FALSE를 반환합니다.실습  비교연산자를 이용한 간단한 코드를 작성해보자.var1 &lt;- 100var2 &lt;- 200var1 == var2     # FALSE  var1 != var2     # TRUEvar1 &gt; var2      # FALSEvar1 &gt;= var2     # FALSE!(var1 &lt;= var2)  # FALSE할당연산자는 다른 언어와 약간 다른 형태를 가집니다. 기존의 할당연산자 =를 이용할 수 도 있지만&lt;- 또는 -&gt; 형태의 연산자를 이용할 수 있습니다.주의해야 할 점은 R의 = 할당 연산자는 간혹 오류를 발생시키는 경우가 보고되고 있습니다. 할당 연산자는 가능한 &lt;- 또는 -&gt;을 이용하는 것이 좋습니다.실습  R의 할당 연산자 &lt;- 또는 -&gt;의 사용법을 알아보자var1 = 100       # var1에 100 대입var1var2 &lt;- 200      # var2에 200 대입var2300 -&gt; var3      # var3에 300 대입var3논리연산자는 두 개 이상의 조건을 비교합니다. &amp;와 &amp;&amp;는 모든 조건이 TRUE일 경우만TRUE가 리턴되고 |, ||는 조건 중 하나라도 TRUE이면 TRUE가 리턴됩니다. 단, scalar가 아닌 vector 연산일 경우 &amp;와 &amp;&amp;연산에 차이가 존재합니다.실습  여러가지 경우에서 논리연산자 동작방식을 알아보자.# 조건에 있는 값이 scalar면 &amp;와 &amp;&amp;가 동일처리TRUE &amp; FALSE      # FALSETRUE &amp;&amp; FALSE     # FALSE# 조건에 있는 값이 scalar면 |와 ||가 동일처리TRUE | FALSE      # TRUETRUE || FALSE     # TRUE# 조건에 있는 값이 vector이면 # &amp;는 vector의 모든 조건에 대한 연산을 수행한 후 # 결과를 vector로 return# &amp;&amp;는 vector의 첫번째 조건에 대한 연산을 수행한 후# 결과를 scalr로 returnc(TRUE,FALSE) &amp; c(TRUE,TRUE)   # TRUE FALSEc(TRUE,FALSE) &amp;&amp; c(TRUE,TRUE)  # TRUEc(TRUE,FALSE) &amp; c(TRUE,TRUE,FALSE)  # Error!c(TRUE,FALSE,TRUE)            # FALSE TRUE FALSER은 다른 언어와 유사하게 여러 수학적인 함수를 내장하고 있습니다.End.이 포스트의 내용은 아래의 책과 사이트를 참조했습니다.    조금 더 자세한 사항을 알고 싶으시면 책을 참조하거나 해당 사이트를 방문하세요!!    Do It! 쉽게 배우는 R 데이터 분석 저자 GitHub",
        "url": "/R-lecture-R-operator"
    }
    ,
    
    "r-lecture-r-environment": {
        "title": "R 기초강의(1) - R 개요",
            "author": "moon9342",
            "category": "",
            "content": "R 강좌는 여러 절로 구성되어 있습니다.     R 기초강의(1) - R 개요    R 기초강의(2) - R Operator    R 기초강의(3) - R Data Type    R 기초강의(4) - R 패키지와 함수    R 기초강의(5) - R 자료구조(vector)    R 기초강의(6) - R 자료구조(matrix)    R 기초강의(7) - R 자료구조(factor, list)    R 기초강의(8) - R 자료구조(data frame)    R 기초강의(9) - R 문자열 처리    R 기초강의(10) - R 데이터 입출력    R 기초강의(11) - R 제어문 및 함수    R 기초강의(12) - R 기초 Exercise    R 기초강의(13) - R Crawling    R 기초강의(14) - R 데이터 조작    R 기초강의(15) - R 데이터 조작 실습    R 기초강의(16) - R 데이터 정제    R 기초강의(17) - R 기초 통계 함수    R 기초강의(18) - R Graph    R 기초강의(19) - R KoNLP    R 기초강의(20) - R 연습문제    R 기초강의(21) - R ggmap    R 기초강의(22) - R 정형데이터 처리R 개요R은 통계 계산을 위한 프로그래밍 언어이면서 동시에 데이터 분석 소프트웨어 입니다. AT&amp;T의 Bell 연구소에서 만들어진 통계 프로그램 S에서 문법과 통계처리 부분을 참고해 1993년 뉴질랜드 오클랜드 대학교 통계학과 교수인 로스 이하카와 로버트 젠틀맨이 개발했고 현재는 R 코어팀이 개발을 진행중입니다.R은 범용 분석 툴이기 때문에 다양한 형태의 데이터를 분석할 수 있습니다.일반적으로 다음과 같은 일들을 할 수 있습니다.  통계 분석 : 기초통계, 가설검정  머신러닝 모델링 : SVM, Random Forest, Deep Learning  텍스트 마이닝 : 단어의 빈도를 이용해 글의 성향 분석  이미지와 사운드 분석 : 이미지와 사운드의 속성을 추출해 데이터로 변환데이터 분석을 하기에 R이 가장 성능이 좋은 것은 아닙니다. 이미 SAS, SPSS 같은 기능이 더 많고성능이 더 좋은 통계 패키지가 존재합니다. 또한 Excel 역시 어느 정도의 통계 분석기능을 가지고 있구요. 이런 상황에서 왜 R을 배워야 할까요?  R은 무료이면서 성능이 상당히 좋기 때문입니다. (설득력이 좀 …)데이터 분석을 위한 프로그래밍 언어 측면에서 R 이외에도 Python을 많이 언급합니다. 프로그래밍 언어 측면에서는 R과 Python 중 어떤것을 선택해야 할까요?R은 일반적으로 데이터를 분석한 후 그 결과를 어딘가에 보고하거나 그 의미를 시각화 시키기에 적합합니다.그에 비해 Python은 데이터 분석 결과를 다른 Web Application 같은 곳에 접목시킬려는 의도가 강하다고 보시면 됩니다. 내가 해결해야 하는 문제에 대해 어느 방식이 더 적합한가를 고려하여 데이터 분석 언어를 선택하시면 됩니다.R의 장점R이 다른 데이터 분석 툴에 비해 가지는 장점은 다음과 같습니다.      Open Source : SAS, SPSS와 같은 전통적인 데이터 분석 시스템은 대부분 유료이지만 R은 무료로 사용할 수 있습니다.        Open Source 생태계 : 다양한 분석 package가 존재하며 최신 분석 기법을 빠르게 사용할 수 있습니다.특히 R 사용자들이 패키지를 만들어 공유하는 site인 CRAN(The Comprehensive R Archive Network)을 통해 최신 분석 기법이 포함된 package들을 쉽게 이용할 수 있습니다.        프로그래밍 방식의 데이터 분석 : 전문적인 데이터 분석이 가능합니다. 제한된 기능이 있는 GUI 분석툴보다 좀 더 심층적인 분석이 가능하고 분석의 전 과정이 코드로 표현 되기 때문에 재현성을 확보할 수 있습니다.  R과 RStudio 설치R을 다운로드하여 설치하고 R 개발을 편하게 하기 위한 IDE인 RStudio를 다운로드하여 설치합니다.  R 설치 시 주의할 점      설치 시 윈도우 사용자 계정이 한글인 경우 설치 및 실행에 오류가 발생할 수 있습니다.계정이 한글인 경우 영문으로 새로운 계정을 생성해서 R을 설치해야 합니다.    CRAN에서 R 다운로드 및 설치  RStudio 다운로드 및 설치RStudio 화면구성RStudio의 화면은 총 4개로 구성되어 있으며 필요에 따라 각 창의 위치를 자유롭게 바꿀 수 있습니다.각 창의 역할을 간단하게 살펴보면 다음과 같습니다.  Source 창 : 스크립트 파일을 생성해서 코드를 작성합니다.  Console 창 : 코드 실행결과가 표시됩니다.  환경 창 : 코드 실행 시 생성된 변수의 값을 확인할 수 있습니다.  파일 창 : 워킹 디렉토리 확인 및 설치된 패키지를 확인할 수 있는 탭이 있습니다.R Project 생성 및 환경 설정코드를 작성할 준비가 되었으면 이제 R Project를 생성합니다.  R Project 생성 시 주의할 점      Project 명과 경로명에 한글이 있는 경우 오류가 발생할 여지가 있습니다. Project 명과 경로명에 한글이 포함되지 않도록 Project를 생성합니다.  Project 생성 후 Global Options에서 soft-wrap 자동 줄바꿈 옵션 설정을 체크하는게 코드를 보기에 편합니다.(Tools -&gt; Global Options -&gt; Code -&gt; Soft-wrap R source files 체크)인코딩 설정은 Global Options과 Project Options에서 각각 설정할 수 있습니다.Global Options의 인코딩 설정은 Tools -&gt; Global Options -&gt; Code -&gt; Saving -&gt; Default text encoding 부분에 UTF-8로 설정합니다.Project Options에서 인코딩 설정은 Tools -&gt; Project Options -&gt; Code Editing -&gt; Text Encoding을 UTF-8로 설정합니다.프로젝트를 생성한 후 변수를 선언하고 간단한 사칙연산을 수행해보도록 하겠습니다. R에서 모든 변수는 객체(Object)형태로 저장되기 때문에 하나의 변수에 데이터와 함수, 그래프까지 저장이가능합니다.R 코드를 작성할 때 기본적으로 알아두어야 할 점은 다음과 같습니다.  R의 주석은 # 으로 표현합니다.  R Studio에서 여러줄 주석은 Ctrl + Shift + c 입니다.  ; 기호는 하나의 statement가 종료되었음을 의미합니다. 만약 같은 줄에 다른 statement가 없다면 생략할 수 있습니다.  R 명령어를 수행하는 기능은 Ctrl + Enter 입니다.  R은 Case-Sensitive하기 때문에 대소문자 처리에 주의해야 합니다.  두단어를 포함해서 변수를 생성할 때는 두번째 단어의 시작을 대문자(CamelCase)로 합니다.실습Project 생성 후 변수를 선언하고 사칙연산을 하는 기본 코드를 작성하고 실행해 결과를 확인합니다.# 변수선언 및 사칙연산# scalar : R의 vector 자료구조의 한 유형으로 한 개의 값만 갖는 vector를 의미myVar &lt;- 100result &lt;- myVar + 200result# 1개의 데이터 출력(출력 후 개행)print(result)var1 = 3.141592result = var1 * 2# 여러개의 데이터 출력# cat()은 출력후 개행이 일어나지 않음. \"\\n\"으로 개행 출력cat(\"계산된 결과값은 :\", result)# cat() 함수는 console이 아닌 파일에 출력을 할 수 있습니다.cat(\"계산된 결과값은 :\",    result,\"\\n\",    file=\"c:/R_workspace/R_Lecture/data/cat_result.txt\",    append=TRUE)    # Environment에 있는 모든 객체 삭제.# Console을 clear. rm(list=ls())  # Environment 객체 삭제cat(\"\\014\")    # console clearEnd.이 포스트의 내용은 아래의 책과 사이트를 참조했습니다.    조금 더 자세한 사항을 알고 싶으시면 책을 참조하거나 해당 사이트를 방문하세요!!    Do It! 쉽게 배우는 R 데이터 분석 저자 GitHub",
        "url": "/R-lecture-R-environment"
    }
    ,
    
    "gulp-css-compile": {
        "title": "Gulp CSS Compile 문제 해결",
            "author": "moon9342",
            "category": "",
            "content": "IntroductionJekyll에서 CSS를 수정한 후 적용하기 위해서 Gulp를 이용하는 방법에 대한 내용입니다.제 블로그를 예로 들어 설명하면 사용하는 CSS 파일은 /assets/css 폴더안에 위치해 있습니다. CSS 파일을 수정한 후 Gulp를 이용하여 compile을 해야 하는데 사용하는 gulpfile.js의 내용은 다음과 같습니다.var gulp = require('gulp');// gulp plugins and utilsvar gutil = require('gulp-util');var postcss = require('gulp-postcss');var sourcemaps = require('gulp-sourcemaps');var imagemin = require('gulp-imagemin');// postcss pluginsvar autoprefixer = require('autoprefixer');var colorFunction = require('postcss-color-function');var cssnano = require('cssnano');var customProperties = require('postcss-custom-properties');var easyimport = require('postcss-easy-import');gulp.task('images', function() {    return gulp.src('assets/images/*')        .pipe(imagemin())        .pipe(gulp.dest('assets/built/images/'))});gulp.task('css', function () {    var processors = [        easyimport,        customProperties,        colorFunction(),        autoprefixer({browsers: ['last 2 versions']}),        cssnano()    ];    return gulp.src('assets/css/*.css')        .pipe(sourcemaps.init())        .pipe(postcss(processors))        .pipe(sourcemaps.write('.'))        .pipe(gulp.dest('assets/built/'))});nodejs를 설치한 후 npm을 이용하여 필요한 module을 설치합니다. 여기서 주의할 점은 node의 버전이 12버전이면js파일에서 오류가 발생할 수 있습니다. gulp의 버전과 node의 버전에 따라서 compile 오류가 발생할 여지가 있기때문에 만약 오류가 발생하면 버전문제를 해결해야 합니다. (저의 경우는 nodejs 버전을 11버전으로 낮추어서 사용했습니다.)compile이 성공하면 결과 파일은 /assets/built 폴더 하단에 CSS파일로 저장되게 됩니다.End.",
        "url": "/gulp-css-compile"
    }
    ,
    
    "angular-lecture-lifecycle": {
        "title": "Angular 강좌(20) - Component LifeCycle",
            "author": "moon9342",
            "category": "",
            "content": "Angular 강좌는 여러 절로 구성되어 있습니다.     Angular 강좌(1) - Introduction    Angular 강좌(2) - 개발환경세팅    Angular 강좌(3) - Component    Angular 강좌(4) - Angular Material    Angular 강좌(5) - 실습(1)    Angular 강좌(6) - Data Binding    Angular 강좌(7) - 실습(2)    Angular 강좌(8) - Material Table    Angular 강좌(9) - 데이터공유(@Input)    Angular 강좌(10) - 데이터공유(@Output)    Angular 강좌(11) - 데이터공유(@ViewChild)    Angular 강좌(12) - 데이터공유(Content Projection)    Angular 강좌(13) - Service    Angular 강좌(14) - Service Mediator Pattern    Angular 강좌(15) - Service RxJS    Angular 강좌(16) - Material Table Event    Angular 강좌(17) - 중간 정리    Angular 강좌(18) - Directive    Angular 강좌(19) - Pipe    Angular 강좌(20) - Component LifecycleComponent Lifecycle이번 포스트에서는 Angular의 Lifecycle에 대해서 알아보겠습니다. 다른 Framework과 마찬가지로 Angular 역시여러 단계의 lifecycle을 관리합니다. Component와 Directive가 이 lifecycle의 영향을 받게 되며 각 lifecycle마다 제공되는hook method를 이용하여 특정 작업을 처리할 수 있습니다.이런 hook method는 interface형태로 우리에게 제공됩니다. Component 혹은 Directive class가 이 interface를 구현하고그 안의 특정 method를 overriding하는 식으로 hook method를 이용할 수 있습니다.Component를 대상으로 객체가 생성되고 소멸되기까지 호출되는 hook method를 순서대로 나열하면 다음과 같습니다. Directive는View를 가지고 있지 않기 때문에 ngAfter로 시작되는 hook method는 호출되지 않습니다.  constructor  ngOnChanges  ngOnInit  ngDoCheck  ngAfterContentInit  ngAfterContentChecked  ngAfterViewInit  ngAfterViewChecked  ngOnDestroy간단하게 Project를 하나 생성해서 각 lifecycle단계에서 해당 hook method가 호출되는지 확인하는 식으로 진행하시면 됩니다.constructorComponent 혹은 Directive가 생성될 때 호출됩니다. 사실 constructor는 Angular의 lifecycle의 단계에 포함될 내용은 아닙니다.TypeScript에서는 일반적으로 constructor에서 초기화를 진행합니다. 하지만 Angular에서 사용하는 속성의 초기화는 ngOnInit에서 하는것이 좋습니다.ngOnChanges@Input을 이용해 부모 Component가 자식 Component에게 데이터를 전달할 수 있습니다. ngOnChanges는 부모 Component에서 자식 Component로 데이터가 binding 될 때 혹은 변경되었을 때 호출됩니다. 따라서 @Input을 사용하지 않으면 호출되지 않습니다.정확하게는 부모 Component로부터 자식 Component에게 전달하는 primitive 값이 변경되거나 혹은 참조하는 객체의 reference가 변경되어야 호출됩니다. 즉, 참조하는 객체의 property가 변경되는 경우에는 ngOnChanges가 호출되지 않는다는 것 기억하셔야 합니다.@Input을 이용한 값의 binding은 생성자가 호출된 후에 일어납니다. 즉, 생성자에서 @Input을 이용해 binding한 값을 출력하면undefined가 출력되게 됩니다. 간단한 이벤트 처리를 통해 @Input으로 전달되는 값을 변경해보면 값이 변경될 때마다ngOnChanges hook method가 호출되는걸 확인할 수 있습니다.ngOnChanges hook method의 인자로 SimpleChanges 객체를 하나 받을 수 있습니다. 해당 객체를 이용하면 변경되기 이전값과이후값등을 알 수 있습니다.import {Component, Input, OnChanges, OnInit, SimpleChanges} from '@angular/core';@Component({  selector: 'app-child',  templateUrl: './child.component.html',  styleUrls: ['./child.component.css']})export class ChildComponent implements OnInit, OnChanges {  @Input() myInput: string;  constructor() {    console.log(`Constructor 호출!! =&gt; myInput : ${this.myInput}`);  }  ngOnChanges(simpleChanges: SimpleChanges) {    console.log(`ngOnChanges 호출!! =&gt; myInput : ${this.myInput}`);    console.log(simpleChanges.myInput.previousValue);    console.log(simpleChanges.myInput.currentValue);  }  ngOnInit() {  }}ngOnInitngOnInit는 ngOnChanges가 호출된 이후에 모든 속성에 대한 초기화가 완료된 시점에 딱 한번만 호출됩니다. 즉, class가 가지고 있는속성과 @Input을 통해 값을 내려받은 속성이 모두 초기화가 된 이후에 호출됩니다. 결국 Component의 속성 참조는 ngOnInithook method이후에 참조하는 것이 좋습니다.결국 생성자는 Service의 Injection같은 사항을 처리하고 속성에 대한 초기화는 ngOnInit에서 처리하시는게 좋다는 말입니다.import {Component, Input, OnChanges, OnInit, SimpleChanges} from '@angular/core';@Component({  selector: 'app-child',  templateUrl: './child.component.html',  styleUrls: ['./child.component.css']})export class ChildComponent implements OnInit, OnChanges {  @Input() myInput: string;  myString = 'Hello';  constructor() {    console.log(`Constructor 호출!! =&gt; myInput : ${this.myInput}`);    console.log(`Constructor 호출!! =&gt; myString : ${this.myString}`);  }  ngOnChanges(simpleChanges: SimpleChanges) {    console.log(`ngOnChanges 호출!! =&gt; myInput : ${this.myInput}`);    console.log(simpleChanges.myInput.previousValue);    console.log(simpleChanges.myInput.currentValue);  }  ngOnInit() {    console.log(`ngOnInit 호출!! =&gt; myInput : ${this.myInput}`);    console.log(`ngOnInit 호출!! =&gt; myString : ${this.myString}`);  }}ngDoCheckngOnInit hook method가 호출된 이후에 호출됩니다. Component에서 발생하는 모든 상태변화에 반응하여 호출되어지는 hook method로Angular의 Changes Detection이 상태변화를 감지하면 자동으로 호출되게 됩니다. 한가지 주의하셔야 할 점은 ngOnChanges와는 다르게 primitive값의 변경, reference 객체의 변경, reference객체의 속성변경에 대한 모든 변경에 대해 해당 hook mehtod가호출된다는 점입니다. 심지에 이전값과 같은 값이 assign되었음에도 호출됩니다. 따라서 ngDoCheck을 많이 사용하게 되면그만큼 성능이 저하될 수 있습니다.import {Component, DoCheck, Input,         OnChanges, OnInit, SimpleChanges} from '@angular/core';interface IBook {  btitle: string;  bauthor: string;}@Component({  selector: 'app-child',  templateUrl: './child.component.html',  styleUrls: ['./child.component.css']})export class ChildComponent implements OnInit, OnChanges, DoCheck {  @Input() myInput: IBook;  myString = 'Hello';  constructor() {    console.log(`Constructor 호출!! =&gt; myInput : ${this.myInput}`);    console.log(`Constructor 호출!! =&gt; myString : ${this.myString}`);  }  ngOnChanges(simpleChanges: SimpleChanges) {    console.log(`ngOnChanges 호출!! =&gt; myInput : ${this.myInput}`);    console.log(simpleChanges.myInput.previousValue);    console.log(simpleChanges.myInput.currentValue);  }  ngOnInit() {    console.log(`ngOnInit 호출!! =&gt; myInput : ${this.myInput}`);    console.log(`ngOnInit 호출!! =&gt; myString : ${this.myString}`);  }  ngDoCheck() {    console.log(`ngDoCheck 호출!! =&gt; myInput : ${this.myInput}`);    console.log(`ngDoCheck 호출!! =&gt; myString : ${this.myString}`);  }}ngAfterContentInit, ngAfterContentChecked최초의 ngDoCheck hook method가 호출된 후에 한번만 호출되며 앞서 배운 ngContent directive를 이용해 부모 Component의 template일부를 자식 Component에서 projection한 후 호출됩니다. 여기서 Content의 의미는 ngContent directive처럼 외부에서Component View안으로 내용을 가져온 것을 지칭합니다. 이 hook method 이후에 Change Detection이 실행된 후 바로 따라서 ngAfterContentChecked hook method가 호출됩니다.ngAfterViewInit, ngAfterViewCheckedComponent에 속한 모든 View와 ViewChild가 시작되고 나서 호출됩니다. 쉽게 생각하면 HTML이 모두 화면에 출력된 후 호출된다고 생각하시면 됩니다. ngAfterViewChecked는 Component의 View에 대한 Change Detection이 실행되고 난 후 호출됩니다.ngOnDestroyComponent가 소멸하기 직전에 호출됩니다. 일반적으로 사용된 자원에 대한 해제 코드가 들어옵니다.import {  AfterContentChecked, AfterContentInit, AfterViewChecked, AfterViewInit,   Component, DoCheck, Input, OnChanges, OnDestroy, OnInit,  SimpleChanges} from '@angular/core';interface IBook {  btitle: string;  bauthor: string;}@Component({  selector: 'app-child',  templateUrl: './child.component.html',  styleUrls: ['./child.component.css']})export class ChildComponent implements OnInit, OnChanges, DoCheck, AfterContentInit,  AfterContentChecked, AfterViewInit, AfterViewChecked, OnDestroy {  @Input() myInput: IBook;  myString = 'Hello';  constructor() {    console.log(`Constructor 호출!! =&gt; myInput : ${this.myInput}`);    console.log(`Constructor 호출!! =&gt; myString : ${this.myString}`);  }  ngOnChanges(simpleChanges: SimpleChanges) {    console.log(`ngOnChanges 호출!! =&gt; myInput : ${this.myInput}`);    console.log(simpleChanges.myInput.previousValue);    console.log(simpleChanges.myInput.currentValue);  }  ngOnInit() {    console.log(`ngOnInit 호출!! =&gt; myInput : ${this.myInput}`);    console.log(`ngOnInit 호출!! =&gt; myString : ${this.myString}`);  }  ngDoCheck() {    console.log(`ngDoCheck 호출!! =&gt; myInput : ${this.myInput}`);    console.log(`ngDoCheck 호출!! =&gt; myString : ${this.myString}`);  }  ngAfterContentInit() {    console.log(`ngAfterContentInit 호출!!`);  }  ngAfterContentChecked() {    console.log(`ngAfterContentChecked 호출!!`);  }  ngAfterViewInit() {    console.log(`ngAfterViewInit 호출!!`);  }  ngAfterViewChecked() {    console.log(`ngAfterViewChecked 호출!!`);  }  ngOnDestroy() {    console.log(`ngOnDestroy 호출!!`);  }}이번 포스트는 Angular가 제어하는 Component와 Directive의 lifecycle에 대해서 살펴봤습니다. 어떤 시점에 어떤 hookmethod가 호출되는지 이해하고 Change Detection이 어느 시점에 호출되는지를 이해하시면 조금 더 Angular를 이해하는데 도움이될 듯 합니다.End.Angular 강좌는 아래의 책과 사이트를 참조했습니다.    조금 더 자세한 사항을 알고 싶으시면 해당 사이트를 방문하세요!!    Angular Official HomePage    Angular Material Official HomePage    Build a Mobile App with Angular 2 and Ionic 2    Angular 첫걸음 - 한빛미디어    제대로 배우는 Angular 4 - 비제이퍼블릭",
        "url": "/angular-lecture-lifecycle"
    }
    ,
    
    "angular-lecture-pipe": {
        "title": "Angular 강좌(19) - Pipe",
            "author": "moon9342",
            "category": "",
            "content": "Angular 강좌는 여러 절로 구성되어 있습니다.     Angular 강좌(1) - Introduction    Angular 강좌(2) - 개발환경세팅    Angular 강좌(3) - Component    Angular 강좌(4) - Angular Material    Angular 강좌(5) - 실습(1)    Angular 강좌(6) - Data Binding    Angular 강좌(7) - 실습(2)    Angular 강좌(8) - Material Table    Angular 강좌(9) - 데이터공유(@Input)    Angular 강좌(10) - 데이터공유(@Output)    Angular 강좌(11) - 데이터공유(@ViewChild)    Angular 강좌(12) - 데이터공유(Content Projection)    Angular 강좌(13) - Service    Angular 강좌(14) - Service Mediator Pattern    Angular 강좌(15) - Service RxJS    Angular 강좌(16) - Material Table Event    Angular 강좌(17) - 중간 정리    Angular 강좌(18) - Directive    Angular 강좌(19) - Pipe    Angular 강좌(20) - Component LifecyclePipe이번 포스트에서는 Angular의 Pipe에 대해서 알아보겠습니다. Pipe는 HTML template내에서 출력하고자 하는 데이터를 원하는형식으로 변환하여 출력하는 기능입니다. 원본 데이터에는 변형을 가하지 않은 상태로 출력 형태만 변경해 주기 때문에원치않은 Side Effect를 없앨 수 있습니다.가장 흔하게 사용하는 예부터 시작하여 사용자 정의 pipe를 생성하는 것 까지 살펴보겠습니다.Built-in PipeAngular는 몇가지 종류의 built-in pipe를 지원합니다. 자세한 사항은 여기를 클릭해 보시면 볼 수 있습니다. 이 중 몇가지만 예를 들어보기로 하죠.다음은 대문자로 출력내용을 바꾸는 pipe의 사용법입니다.&lt;h5 #resultStatus     class=\"mb-0 text-white lh-100\"&gt;    Search Result : {{searchTitle | uppercase }}&lt;/h5&gt;searchTitle의 값이 그대로 interpolation을 이용해 출력되는 형태에서 uppercase라는 내장 pipe를 이용해 출력되는 영문문자열을대문자로 변경해 출력하는 것입니다.이와 유사하게 다음과 같이 날짜에 대한 pipe도 존재합니다.&lt;div&gt;{{ today }}&lt;/div&gt;&lt;div&gt;{{ today | date }}&lt;/div&gt;&lt;div&gt;{{ today | date: 'y년 MM월 dd일' }}&lt;/div&gt;today = new Date();원래 출력되는 형식과 pipe로 변형되서 출력되는 형식을 잘 보시면 될 듯 합니다. 또한 pipe사용은 체이닝을 지원합니다.여러 pipe를 이어서 원하는 형식으로 변환시켜 출력 가능하다는 말이죠.이번에는 우리예제 중 Material Table의 출력 중 가격부분을 통화단위로 바꾸어서 출력하는걸 해보도록 하죠.다음은 list-box.component.html의 일부입니다.&lt;ng-container matColumnDef=\"bprice\"&gt;  &lt;mat-header-cell *matHeaderCellDef&gt; Price &lt;/mat-header-cell&gt;  &lt;mat-cell *matCellDef=\"let element\"&gt; {{element.bprice | currency: 'KRW'}} &lt;/mat-cell&gt;&lt;/ng-container&gt;위의 예에서 볼 수 있듯이 책의 가격을 통화단위(원화)로 변경해서 출력할 수 있습니다. 이렇게 built-in pipe를 이용해서처리할 수 있고 built-in pipe로 처리할 수 없는 것들은 custom pipe를 이용해 처리할 수 있습니다.사용자 정의 pipe를 이용해 비슷한 처리를 해 보겠습니다.command 창을 열고 다음의 명령을 실행해 pipe를 생성합니다.  ng generate pipe bookPricebook-price.pipe.ts 파일이 생성되게 됩니다. 기본적인 code가 생성되고 내용은 다음과 같이 수정합니다.import { Pipe, PipeTransform } from '@angular/core';@Pipe({  name: 'bookPrice'})export class BookPricePipe implements PipeTransform {  transform(value: any, args?: any): any {    return value.toString().replace(/\\B(?=(\\d{3})+(?!\\d))/g, ',') + '원';  }}bookPrice란 이름의 pipe를 사용하면 transform() method가 호출되서 변환작업을 진행하게 됩니다. 적절하게해당 method의 내용을 우리가 원하는 내용으로 변경해주면 되겠네요. 위의 코드는 입력받은 숫자를 3자리마다 ,를찍고 맨 마지막에 ‘원’을 붙여서 문자열을 리턴하는 코드입니다.우리가 만든 pipe를 Module에 등록하고 list-box.component.html 에서 다음과 같이 사용하시면 됩니다.&lt;ng-container matColumnDef=\"bprice\"&gt;  &lt;mat-header-cell *matHeaderCellDef&gt; Price &lt;/mat-header-cell&gt;  &lt;mat-cell *matCellDef=\"let element\"&gt; {{element.bprice | bookPrice}} &lt;/mat-cell&gt;&lt;/ng-container&gt;이번 포스트에서는 Angular에서 Pipe라고 불리는 요소가 어떠한 역할을 하는지에 대해서 알아보았습니다. Pipe는어렵지 않은 내용이기 때문에 built-in pipe를 사용하는 방법과 custom pipe를 작성하는 방법만 몇가지 알아두시면됩니다.End.Angular 강좌는 아래의 책과 사이트를 참조했습니다.    조금 더 자세한 사항을 알고 싶으시면 해당 사이트를 방문하세요!!    Angular Official HomePage    Angular Material Official HomePage    Build a Mobile App with Angular 2 and Ionic 2    Angular 첫걸음 - 한빛미디어    제대로 배우는 Angular 4 - 비제이퍼블릭",
        "url": "/angular-lecture-pipe"
    }
    ,
    
    "angular-lecture-directive": {
        "title": "Angular 강좌(18) - Directive",
            "author": "moon9342",
            "category": "",
            "content": "Angular 강좌는 여러 절로 구성되어 있습니다.     Angular 강좌(1) - Introduction    Angular 강좌(2) - 개발환경세팅    Angular 강좌(3) - Component    Angular 강좌(4) - Angular Material    Angular 강좌(5) - 실습(1)    Angular 강좌(6) - Data Binding    Angular 강좌(7) - 실습(2)    Angular 강좌(8) - Material Table    Angular 강좌(9) - 데이터공유(@Input)    Angular 강좌(10) - 데이터공유(@Output)    Angular 강좌(11) - 데이터공유(@ViewChild)    Angular 강좌(12) - 데이터공유(Content Projection)    Angular 강좌(13) - Service    Angular 강좌(14) - Service Mediator Pattern    Angular 강좌(15) - Service RxJS    Angular 강좌(16) - Material Table Event    Angular 강좌(17) - 중간 정리    Angular 강좌(18) - Directive    Angular 강좌(19) - Pipe    Angular 강좌(20) - Component LifecycleDirective이번 포스트에서는 Angular의 Directive에 대해서 알아보겠습니다. 지금까지 예제를 작성하면서 여러 directive를 사용해 왔는데요.그에 대해서 조금 더 정리를 해 보려 합니다.Directive는 DOM의 모양이나 동작을 지시하기 위한 명령이라고 생각하시면 됩니다. 크게 HTML Element형태로 사용되거나 Element의 attribute의 형태로 사용되게 됩니다. 예를 들면 우리가 사용했던 ngIf 같은 attribute를 떠올리시면 됩니다.Routing에서 사용했던 &lt;router-outlet&gt;&lt;/router-outlet&gt; Element 역시 directive입니다.이렇게 directive는 DOM을 제어하기 위한 용도로 사용되는데 DOM을 제어하기 위해서 우리는 지금까지 Component를 이용했었습니다. Component로 제어하면 되지 굳이 directive로 DOM을 제어할 필요가 있느냐 하는 의문이 들 수 있습니다. 하지만 Component는원칙적으로 자신이 rendering하는 View에 대해서만 관심이 있습니다. 여러 View들이 공통적으로 사용하는 Element나 Element의attribute같은 것들을 따로 directive로 지정해 사용하면 SRP관점에서 봤을 때도 타당하고 Component의 복잡도를 낮출 수 있으며유지보수와 같은 관리적인 측면에서도 더 나은 형태로 구현이 가능합니다.Component 역시 큰 의미에서 directive입니다. Component는 directive이면서 View를 가지고 있고 자식 Component 또한 가질 수있습니다. 하지만 directive는 View를 가지고 있지 않고 자식 directive 또한 가질 수 없습니다.Directive는 크게 다음과 같은 4가지 종류로 구분 할 수 있습니다.      Component Directive    우리가 알고 있는 Component입니다. selector에서 우리가 directive를 지정해 사용하게 됩니다.            Attribute Directive    HTML Element의 Attribute로 사용됩니다. built-in 형태로는 ngClass 같은 것들이 있습니다.            Structural Directive    DOM의 구성을 제어하기 위한 directive로 ngIf , ngFor, ngSwitch 등이 있습니다.            Custom Directive    built-in 형태로 만들어진 directive가 아닌 직접 만들어서 사용하는 directive를 지칭합니다.      이 중 Component에 대해서는 많이 사용해 봤으니 Structural Directive와 Custom Directive에 대해서알아보도록 하겠습니다.Structural Directive우리 예제에서도 사용했던 ngIf, ngFor등을 지칭합니다. 단, 이것들은 built-in된 형태입니다. 이런 구조적 directive를우리가 직접 만들어서 사용할 수도 있습니다. ngIf와 ngFor를 사용하실 때 몇가지 알아두셔야 하는 사항이 있습니다.일반적으로 다음과 같이 코드처리 합니다.&lt;div *ngIf=\"hero\" class=\"name\"&gt;&lt;/div&gt;hero가 null과 undefined가 아니면 &lt;div&gt;를 DOM에 추가하고 interpolation을 이용해 값을 출력하는 코드입니다.이 코드는 사실 다음과 같이 변형되어서 실행됩니다.&lt;ng-template [ngIf]=\"hero\"&gt;  &lt;div class=\"name\"&gt;&lt;/div&gt;&lt;/ng-template&gt;ng-template을 이용해서 조건을 통해 &lt;div&gt;의 처리를 결정합니다.비교해서 보셔야 할 것으로 ng-container가 있습니다. 위의 코드는 다음의 코드로 표현이 가능합니다.&lt;ng-container *ngIf=\"hero\"&gt;  &lt;div class=\"name\"&gt;&lt;/div&gt;&lt;/ng-container&gt;Angular는 동일한 Element에 두개 이상의 *ngIf, *ngFor, *ngSwitch를 사용할 수 없습니다. for문을 돌리면서 if문을이용해 비교하고 싶은 경우에는 문제가 됩니다. 이 같은 경우를 해결하기 위해 ng-container를 제공하는 것이라 보시면 됩니다.Custom Directive기존에 만들었던 mySearchProject에 간단하게 Custom Directive를 추가하고 어떻게 이용하는지 살펴보도록 하겠습니다.command 창을 열고 다음의 명령을 실행해서 directive를 하나 생성합니다. 현재 command 창의 working directory는src/app 입니다.  ng generate directive textColor두개의 파일이 생성됩니다. Angular CLI의 이름규칙에 의해 text-color.directive.ts 라는 이름의 파일이 생성됩니다.그 내용을 다음과 같이 수정합니다.import {Directive, ElementRef, Renderer2} from '@angular/core';@Directive({  selector: '[myColor]'})export class TextColorDirective {  constructor(elementref: ElementRef, renderer: Renderer2) {    renderer.setStyle(elementref.nativeElement,'color','darkred');  }}위의 directive 내용은 HTML Element의 속성으로 myColor 가 사용되었을 경우 해당 Element를 DOM에rendering 할 때 글자색을 darkred로 설정하라는 것입니다.이렇게 directive를 생성하면 사용하기 위해서 Root Module에 등록해야 합니다. Angular CLI를 이용했기 때문에이미 등록이 되어 있습니다. 이제 실제 해당 directive가 정상적으로 동작하는지 확인해보면 될 듯 합니다.pages/home 폴더에 있는 home.component.html을 수정해서 해당 directive를 사용해 보죠.&lt;h1&gt;HOME&lt;/h1&gt;&lt;hr&gt;&lt;p myColor&gt;이 Web Application은 Angular 강좌를 위한 Test App입니다.&lt;p&gt;이 강좌는 다음의 내용을 포함합니다. &lt;/p&gt;&lt;ul&gt;  &lt;li&gt;Angular의 기본 구조&lt;/li&gt;  &lt;li&gt;Angular CLI&lt;/li&gt;  &lt;li&gt;Component&lt;/li&gt;  &lt;li&gt;Template - Template Reference Variable&lt;/li&gt;.........  위와 같이 myColor라는 directive를 사용할 수 있습니다. 해당 P Element의 text 글자는 darkred로 출력되겠네요.가장 직관적인 예를 들기 위해 text color를 변경하는걸로 처리를 했는데 그 외 DOM을 제어하는 다른 기능들도 할 수 있습니다.이번에는 이벤트 처리를 한번 해 보죠. 위의 예에서 해당 P Element를 클릭했을 때 alert() 이 수행되게 할려면 다음과 같이처리하시면 됩니다.import {Directive, ElementRef, HostListener, Renderer2} from '@angular/core';@Directive({  selector: '[myColor]'})export class TextColorDirective {  @HostListener('click', ['$event']) elementClick(e) {    // e안에는 event객체가 들어온다.    // this는 directive 객체를 지칭.    alert(e.srcElement.innerHTML)  }  constructor(elementref: ElementRef, renderer: Renderer2) {    renderer.setStyle(elementref.nativeElement,'color','darkred');  }}이벤트를 처리하기 위해 @HostListener decorator를 이용했습니다. 여기서 host라는 표현이 나오는데 지금 우리 예제에서myColor 속성을 적용한 HTML Element를 host라고 지칭합니다.이벤트 객체를 얻기 위해 처리하는 부분을 조심해서 보시면 됩니다.추가적으로 @Input decorator를 이용해서 directive가 값을 전달 받을 수 있습니다. 원래 @Input은 부모 Component가 자식 Component에게 데이터를 전달해 주기 위해 사용했었는데 directive에게도 값을 전달 할 수 있습니다. 사용하는 Component때 했던 것과 동일합니다.이번 포스트는 Directive에 대해서 정리해보았습니다. 더 많은 기능이 있지만 기본적으로 이런 용도로 사용된다는 정도만 알고 계시면될 듯 합니다.End.Angular 강좌는 아래의 책과 사이트를 참조했습니다.    조금 더 자세한 사항을 알고 싶으시면 해당 사이트를 방문하세요!!    Angular Official HomePage    Angular Material Official HomePage    Build a Mobile App with Angular 2 and Ionic 2    Angular 첫걸음 - 한빛미디어    제대로 배우는 Angular 4 - 비제이퍼블릭",
        "url": "/angular-lecture-directive"
    }
    ,
    
    "angular-lecture-inspection-1": {
        "title": "Angular 강좌(17) - 중간 정리",
            "author": "moon9342",
            "category": "",
            "content": "Angular 강좌는 여러 절로 구성되어 있습니다.     Angular 강좌(1) - Introduction    Angular 강좌(2) - 개발환경세팅    Angular 강좌(3) - Component    Angular 강좌(4) - Angular Material    Angular 강좌(5) - 실습(1)    Angular 강좌(6) - Data Binding    Angular 강좌(7) - 실습(2)    Angular 강좌(8) - Material Table    Angular 강좌(9) - 데이터공유(@Input)    Angular 강좌(10) - 데이터공유(@Output)    Angular 강좌(11) - 데이터공유(@ViewChild)    Angular 강좌(12) - 데이터공유(Content Projection)    Angular 강좌(13) - Service    Angular 강좌(14) - Service Mediator Pattern    Angular 강좌(15) - Service RxJS    Angular 강좌(16) - Material Table Event    Angular 강좌(17) - 중간 정리    Angular 강좌(18) - Directive    Angular 강좌(19) - Pipe    Angular 강좌(20) - Component Lifecycle중간 정리지금까지 Angular의 구조와 기본개념을 살펴보기 위해서 간단한 예제프로그램을 작성했습니다.이제 기존에 하지 못했던 조금 더 자세한 사항에 대해 알아봐야 할 듯 합니다.Performance Issue먼저 얘기할 부분은 Angular의 Performance 입니다.기존 AngularJS에 비해서 Angualr는 여러 관점에서 성능향상이 이루어졌습니다. 하나씩 간단하게 살펴보겠습니다.      Digest Loop로 인한 성능 저하 문제가 개선되었습니다. 우리 예제에서 다뤄보았던 양방향 바인딩 기억하시나요?AngularJS에서는 이 양방향 바인딩을 처리하기 위해 watcher라는걸 사용합니다. 이 watcher라는 놈이 수행될 때마다 digest loop가 수행되어 양방향 바인딩을 처리하는 구조였습니다. 양방향 바인딩이 많아질수록 watcher가 증가하고결과적으로 digest loop의 수행도 같이 증가해서 결국 성능이 저하되는 문제가 발생했던 겁니다.지금의 Angualr는 전통적인 양방향 바인딩을 다른 방식으로 처리함으로써 이 문제를 해결했습니다.    현재 Agnular에서 양방향 바인딩은 내부적으로 Property binding과 Event binding으로 변환되어서 처리됩니다.만약 Angular의 Change Detection에 대해 자세히 알고 싶으시면여기를참고하세요.    Angular는 AoT Compile을 지원합니다. AoT(Ahead of Time) compile이란 사전 컴파일을 지칭합니다. 런타임에 컴파일을 하지 않고 미리 컴파일을 해 놓기 때문에 실행 속도를 더 높일 수 있는 것이죠. 안드로이드 개발을 해 보신 분이라면 Dalvik과ART를 알고 계실 겁니다. Dalvik은 JIT 컴파일러를 이용하고 ART는 AoT 컴파일러를 사용합니다. 둘을 비교해보자면 JIT(Just-In-Time)은실행시점에 소스코드를 컴파일하는 방식입니다. 설치는 빠르게 되겠지만 실행이 좀 느리겠지요. AoT는 설치시점에 소스코드를컴파일하는 방식입니다. 따라서 설치가 조금 느려지지만 실행시 빠르게 실행되는 장점을 가지고 있습니다.  Angular뿐만 아니라 모든 Front-End Framework이 가지는 문제점 중 하나는 바로 SPA(Single Page Application) 구조에서 오는 rendering의 속도 문제입니다.우리는 기존에 SSR(Server Side Rendering)을 이용해 프로그램을 했었습니다. 예를 들면, JSP 이런것들 이지요. SSR의 장점은일단 클라이언트에게 빠르게 화면을 보여줄 수 있다는 겁니다. 하지만 라이브러리가 다 로딩된 후에야 Client와 interaction이 가능합니다.반면에 SPA 구조는 모든 라이브러리가 다 로딩되어야 Client가 화면을 볼 수 있습니다. 즉, Client가 초기에 화면을 보기까지 로딩시간이걸린다는 것입니다. CSR(Client Side Rendering) 이라고 불리는 이 방식은 화면이 뜨자마자 바로 interaction이 가능하다는 장점이 있습니다. 요즘에는 이 둘을 섞어서 최적화를 꾀하고 있습니다. 이와 관련된 사항으로 Angular는 Lazy Loading을 사용합니다.Lazy Loading(지연 로딩)은 SPA의 단점을 극복하기 위한 하나의 방법으로 사용하는 모든 라이브러리를 한꺼번에 다 불러들이지 않고필요한 시점에 필요한 라이브러리만 로딩하는 방식입니다. 이를 이용해 로딩 시간을 단축할 수 있기 때문입니다.Angular CLI그 다음 살펴볼 부분은 Angular CLI입니다. 우리 예제 프로그램을 작성하기 위해 사용했던 것 기억하시지요?Angular CLI(Command Line Interpreter)는 command 명령어를 이용해서 프로젝트의 생성 및 Scaffolding, build, 개발서버를 이용한실행과 테스팅까지 수행할 수 있는 개발지원 도구 입니다. 간단하지 않는 프로젝트의 구조 생성 및 설정 그리고 Coding Convention등을 자동으로 잡아주기 때문에 편하게 개발환경을 구축하고 표준적 방식으로 프로젝트를 진행할 수 있도록 도와주는 아주 고마운 도구이지요.다음은 일반적으로 많이 사용되는 Angular CLI의 명령어와 알아두어야 할 사항들 입니다.  프로젝트의 생성    ng new &lt;project_name&gt;        위와 같은 형태로 프로젝트를 생성하면 기본 폴더 구조와 파일이 생성됩니다. 이전에도 언급했지만 이렇게 생성된 프로젝트의 구조와Coding Convention이 Angular의 표준 스타일입니다. 또한 필요한 의존 Module이 같이 설치됩니다. 만약 의존Module을 설치하고 싶지 않을 경우 --skip-install option을 이용해 프로젝트를 생성하시면 됩니다.    내장 개발서버를 이용한 프로젝트 실행    ng serve        위와 같은 명령을 이용하면 내장 개발 서버를 이용해 우리 프로젝트를 deploy할 수 있습니다. 기본적으로 사용하는 port는 4200입니다. 만약 다른 포트를 사용하고 싶을 때는 --port option을 이용해 포트번호를 변경할 수 있습니다. 그리고 --o option을이용하면 시스템에 설정되어 있는 default browser를 실행해 http://localhost:4200 으로 접속까지 해 줍니다.    이 내장 개발서버는 LiveReload 기능을 지원합니다. 쉽게말하자면 우리가 코드를 수정하면 그 내용을 컴파일하여 즉각 반영하고 browser를 refresh까지 시켜준다는 것이지요. 개발을 편하게 가져갈 수 있습니다.    프로젝트 구성요소 추가    ng generate &lt;구성요소&gt; &lt;구성요소명&gt;        위와 같은 명령을 이용하면 프로젝트에 새로운 Angular 구성요소를 추가할 수 있습니다. 우리는 component, service 구성요소를 추가해봤지요. 그 외에 다음과 같은 Angular 구성요소들을 추가할 수 있습니다.          directive      pipe      module      class      interface      enum      guard        이런 구성요소가 어떤 역할을 하는지는 나중에 하나씩 살펴봐야 겠네요. 기존에 우리 프로젝트에서 추가했던 search-box Component를 가지고 간단하게 Naming Rule에 대해 정리를 한번 해 보겠습니다.    다음과 같은 명령을 실행하면 새로운 Component가 하나 만들어 집니다.    ng generate component search-box        생성되는 파일은 총 4개입니다. option을 설정하면 파일이 만들어지지 않을수도 있습니다. 즉, CSS, HTML, SPEC파일을생성하지 않을수도 있다는 말입니다. CSS와 HTML을 inline방식으로 사용할 수 있으니까요. SPEC은 테스트를 위한 파일입니다.    그런데 만들어지는 파일의 이름이 좀 특이합니다. 다음과 같은 형태로 만들어졌습니다.    search-box-component.css     search-box-component.html    search-box-component.tssearch-box-component.spec.ts        파일명이 모두 search-box.component.* 형태로 만들어집니다. Angular는 Naming의 혼란을 방지하기 위해 케밥 표기법(Kebab case)을 이용해서 Angular 구성요소의 이름을 붙이게 됩니다. 사실 우리에게 익숙한표기법은 Camel case입니다. 각 단어의 첫글자를 소문자로 쓰고 붙어있는 단어들은 대문자로 시작하는 표기법입니다. Java의기본 표기법이죠. 참고로 Pascal case도 있습니다. Camel case와 유사한데 Pascal case는 첫 글자도 대문자로 시작합니다.Kebab-case는 하이픈(-)을 이용한 표기법입니다. Angular는 기본적으로 Kebab case를 Angular 구성요소 이름을 붙일 때 사용한다는걸 기억하시면 됩니다. 참고로 class의 이름은 Pascal case를 이용합니다.    이렇게 만들어진 search-box-component.ts 파일의 내용을 살펴보죠    import { Component, OnInit } from '@angular/core';  @Component({  selector: 'app-search-box',  templateUrl: './search-box.component.html',  styleUrls: ['./search-box.component.css']})export class SearchBoxComponent implements OnInit {    constructor() { }    ngOnInit() {  }  }        위의 코드에서 selector가 어떤 역할을 하는지 아실겁니다. 이 selector에 명시된 이름의 tag를 다른 template에서이용하면 해당 tag 위치에 우리 Component에서 지정한 template이 표시되게 됩니다. 이 selector에 명시된 이름이결국 &lt;app-search-box&gt;&lt;/app-search-box&gt;형태로 어딘가에서 이용된다는 말이죠. 이 selector에 지정된 이름을붙일 때 접두어 app을 이용해 Kebab case로 표현합니다. 기존의 HTML tag와 혼동되는걸 피하기 위해서라고 생각하시면 됩니다.    참고로 이 접두어는 .angular-cli.json 설정파일에서 다른것으로 지정할 수 있습니다.    우리는 CSS와 HTML을 따로 파일을 만들어서 사용했지만 inline형태로 이용할 수 있습니다. 아래와 같이 말이죠.    import { Component, OnInit } from '@angular/core';  @Component({  selector: 'app-search-box',  template: `&lt;h1&gt;Hello&lt;h1&gt;             &lt;p&gt;              this is a sample text             &lt;/p&gt;            `,  style: `.myStyle {              color : red          }         `})export class SearchBoxComponent implements OnInit {    constructor() { }    ngOnInit() {  }  }          여기서는 backquote ( ` ) 기호를 이용하는 template string을 사용했습니다. 다른 Angular 구성요소를 추가하는방법과 이용법은 이후 포스트에서 하나씩 실습을 통해 알아보도록 하겠습니다.    프로젝트 Build    ng build        위와 같은 명령을 이용하면 우리 프로젝트를 Angular CLI를 이용해 Build할 수 있습니다. 기존에는 SystemJS를 이용해서bundling을 했지만 현재는 webpack을 이용해 bundling합니다. option을 따로 주지 않고 build를 진행하면 개발환경 build를 수행하게 됩니다. 만약 productionbuild를 수행하시려면 --prod option을 이용하시면 됩니다. 또한 deploy를 위한 base url을 설정할 때는 --base-href option을이용하시면 됩니다. Angular CLI Build에 관한 보다 자세한 option 사항은 여기를 참조하시면 됩니다.  이번 포스트는 기존에 설명하기 좀 난감(?)했던 성능문제라던지 Angular CLI의 Naming Rule에 대해 보충설명을 진행했습니다. 만약 Angular CLI에 대해 더 자세하게 알고 싶으시면 여기를 살펴보시면 됩니다.End.Angular 강좌는 아래의 책과 사이트를 참조했습니다.    조금 더 자세한 사항을 알고 싶으시면 해당 사이트를 방문하세요!!    Angular Official HomePage    Angular Material Official HomePage    Build a Mobile App with Angular 2 and Ionic 2    Angular 첫걸음 - 한빛미디어    제대로 배우는 Angular 4 - 비제이퍼블릭",
        "url": "/angular-lecture-inspection-1"
    }
    ,
    
    "angular-lecture-table-event": {
        "title": "Angular 강좌(16) - Material Table Event",
            "author": "moon9342",
            "category": "",
            "content": "Angular 강좌는 여러 절로 구성되어 있습니다.     Angular 강좌(1) - Introduction    Angular 강좌(2) - 개발환경세팅    Angular 강좌(3) - Component    Angular 강좌(4) - Angular Material    Angular 강좌(5) - 실습(1)    Angular 강좌(6) - Data Binding    Angular 강좌(7) - 실습(2)    Angular 강좌(8) - Material Table    Angular 강좌(9) - 데이터공유(@Input)    Angular 강좌(10) - 데이터공유(@Output)    Angular 강좌(11) - 데이터공유(@ViewChild)    Angular 강좌(12) - 데이터공유(Content Projection)    Angular 강좌(13) - Service    Angular 강좌(14) - Service Mediator Pattern    Angular 강좌(15) - Service RxJS    Angular 강좌(16) - Material Table Event    Angular 강좌(17) - 중간 정리    Angular 강좌(18) - Directive    Angular 강좌(19) - Pipe    Angular 강좌(20) - Component LifecycleAngular Material Table Event이번 포스트는 list-box Component의 Angular Material Table의 row를 클릭하면 해당 책의 세부정보를 detail-box Component의View에 출력하는 부분을 작성해 보겠습니다. 이 작업 역시 BehaviorSubject를 이용해 선택한 책의 정보를 자동으로 갱신해 출력할 수 있도록 처리하겠습니다.Service에 Client에 의해 선택된 책의 세부정보가 담긴 객체정보가 존재해야 합니다. detail-box Component는 이 정보를 subscribe해야 하고 만약 Client에 의해 다른 책이 선택된다면 이 정보를 갱신해주면 될 듯합니다.다음은 http-support.service.ts 파일의 내용입니다.import { Injectable } from '@angular/core';import { HttpClient } from \"@angular/common/http\";import { BehaviorSubject } from \"rxjs/BehaviorSubject\";interface IBook {  bauthor: string;  bdate: string;  btranslator: string;  bpublisher: string;  btitle: string;  bprice: number;  bisbn: string;  bimgurl: string;}@Injectable()export class HttpSupportService {  books: IBook[];  // Client에 의해 선택된 책의 정보 - 초기화  selectedBook: IBook = {    bauthor: '',    bdate: '',    btranslator: '',    bpublisher: '',    btitle: '',    bprice: 0,    bisbn: '',    bimgurl: ''  };  constructor(private http: HttpClient) { }  updateBooks: BehaviorSubject&lt;IBook[]&gt; = new BehaviorSubject&lt;IBook[]&gt;(this.books);    // selectedBook에 대한 BehaviorSubject 객체 생성  updateSelectedBook: BehaviorSubject&lt;IBook&gt; = new BehaviorSubject&lt;IBook&gt;(this.selectedBook);  getJsonData(url:string, name:string, category:string, keyword:string) {    this.http.get&lt;IBook[]&gt;(`${url}${name}`)        .subscribe(res =&gt; {           let tmp = null;           // 도서종류와 검색어를 이용한 도서 데이터 Filtering 시작           if( category == 'all' ) {             tmp = res.filter(function(item,idx,arr) {               if(item.btitle.includes(keyword)) {                 return true;               } else {                 return false;               }             });           } else if( category == 'country') {             tmp = res.filter(function(item,idx,arr) {               if(item.btitle.includes(keyword)) {                 return true;               } else {                 return false;               }             }).filter(function(item,idx,arr) {               if(item.btranslator == '') {                 return true;               } else {                 return false;               }             });           } else if( category == 'foreign') {             tmp = res.filter(function(item,idx,arr) {               if(item.btitle.includes(keyword)) {                 return true;               } else {                 return false;               }             }).filter(function(item,idx,arr) {               if(item.btranslator != '') {                 return true;               } else {                 return false;               }             });           }          // 도서종류와 검색어를 이용한 도서 데이터 Filtering 끝          this.updateBooks.next(tmp);          //this.books = tmp;          //console.log(this.books);        });  }  getBooks(): IBook[] {    return this.books;  }}이제 Material Table row event를 처리해야 합니다. 이 부분은 API 사용이기 때문에 별다른 설명이 없습니다. 다음의 코드를이용하시면 됩니다.다음은 list-box.component.html 파일의 내용입니다.&lt;div class=\"example-container mat-elevation-z8\"&gt;  &lt;mat-table class=\"list-table-style\" #table [dataSource]=\"dataSource\"&gt;    &lt;ng-container matColumnDef=\"bisbn\"&gt;      &lt;mat-header-cell *matHeaderCellDef&gt; ISBN &lt;/mat-header-cell&gt;      &lt;mat-cell *matCellDef=\"let element\"&gt;  &lt;/mat-cell&gt;    &lt;/ng-container&gt;    &lt;ng-container matColumnDef=\"btitle\"&gt;      &lt;mat-header-cell *matHeaderCellDef&gt; Title &lt;/mat-header-cell&gt;      &lt;mat-cell *matCellDef=\"let element\"&gt;  &lt;/mat-cell&gt;    &lt;/ng-container&gt;    &lt;ng-container matColumnDef=\"bauthor\"&gt;      &lt;mat-header-cell *matHeaderCellDef&gt; Author &lt;/mat-header-cell&gt;      &lt;mat-cell *matCellDef=\"let element\"&gt;  &lt;/mat-cell&gt;    &lt;/ng-container&gt;    &lt;ng-container matColumnDef=\"bprice\"&gt;      &lt;mat-header-cell *matHeaderCellDef&gt; Price &lt;/mat-header-cell&gt;      &lt;mat-cell *matCellDef=\"let element\"&gt;  &lt;/mat-cell&gt;    &lt;/ng-container&gt;    &lt;mat-header-row class=\"list-header-style\"                    *matHeaderRowDef=\"displayedColumns\"&gt;    &lt;/mat-header-row&gt;    &lt;mat-row *matRowDef=\"let row; columns: displayedColumns;\"             (click)=\"rowSelect(row)\"&gt;    &lt;/mat-row&gt;  &lt;/mat-table&gt;  &lt;mat-paginator #paginator                 [pageSize]=\"5\"                 [pageSizeOptions]=\"[5, 10, 20]\"                 showFirstLastButtons&gt;  &lt;/mat-paginator&gt;&lt;/div&gt;아래쪽에 &lt;mat-row&gt;에 대한 이벤트 처리만 유의해서 보시면 됩니다. Table의 각 row를 클릭할 때 마다 rowSelect()를 이용해 method를 호출하면서 현재 선택된 row 객체를 인자로 넘겨줍니다.다음은 list-box.component.ts 파일의 내용입니다.import { Component, OnInit } from '@angular/core';import { MatTableDataSource } from '@angular/material';import { MatPaginator } from '@angular/material';import { ViewChild } from '@angular/core';import { HttpSupportService } from \"../http-support.service\";import { SelectionModel } from '@angular/cdk/collections';interface IBook {  bauthor: string;  bdate: string;  btranslator: string;  bpublisher: string;  btitle: string;  bprice: number;  bisbn: string;  bimgurl: string;}@Component({  selector: 'app-list-box',  templateUrl: './list-box.component.html',  styleUrls: ['./list-box.component.css']})export class ListBoxComponent {  displayedColumns = ['bisbn', 'btitle', 'bauthor', 'bprice'];  dataSource;  books: IBook[];  // event 처리  selection = new SelectionModel&lt;IBook&gt;(false, []);  @ViewChild(MatPaginator) paginator: MatPaginator;  constructor(private httpSupportService:HttpSupportService) {    this.httpSupportService.updateBooks.subscribe(data =&gt; {      this.books = data;      this.dataSource = new MatTableDataSource&lt;IBook&gt;(this.books);      this.dataSource.paginator = this.paginator;    })  }  rowSelect(row) {    this.selection.select(row);    this.httpSupportService.updateSelectedBook.next(this.selection.selected[0]);  }}SelectionModel을 이용해 사용자가 선택한 row에 대한 정보를 획득합니다. Service의 updateSelectedBook의 next()를호출하여 detail-box Component에서 구독하고 있을 선택된 책의 정보를 갱신합니다.마지막으로 detail-box.component.ts 파일입니다.import { Component, OnInit } from '@angular/core';import {HttpSupportService} from \"../http-support.service\";interface IBook {  bauthor: string;  bdate: string;  btranslator: string;  bpublisher: string;  btitle: string;  bprice: number;  bisbn: string;  bimgurl: string;}@Component({  selector: 'app-detail-box',  templateUrl: './detail-box.component.html',  styleUrls: ['./detail-box.component.css']})export class DetailBoxComponent implements OnInit {  book: IBook;  constructor(private httpSupportService:HttpSupportService) {    this.httpSupportService.updateSelectedBook.subscribe(selectedBook =&gt; {      this.book = selectedBook;    });  }  ngOnInit() {  }}기존에 sample data를 삭제하고 Service를 이용하여 updateSelectedBook 객체를 subscribe하게끔 처리했습니다.Table의 이벤트 처리하는 부분만 잘 보시면 됩니다. 데이터 공유는 이전 포스트에서 설명했던 방식 그대로 똑같이 적용해서 처리했습니다.여기까지해서 기본적인 도서 검색에 대한 프로그램을 완성했습니다. 다음 포스트들은 실습과 약간 무관하지만 알아야 하는부분들에 대해서 정리해 보겠습니다.End.Angular 강좌는 아래의 책과 사이트를 참조했습니다.    조금 더 자세한 사항을 알고 싶으시면 해당 사이트를 방문하세요!!    Angular Official HomePage    Angular Material Official HomePage    Build a Mobile App with Angular 2 and Ionic 2    Angular 첫걸음 - 한빛미디어    제대로 배우는 Angular 4 - 비제이퍼블릭",
        "url": "/angular-lecture-table-event"
    }
    ,
    
    "angular-lecture-data-share-service-rxjs": {
        "title": "Angular 강좌(15) - Service RxJS",
            "author": "moon9342",
            "category": "",
            "content": "Angular 강좌는 여러 절로 구성되어 있습니다.     Angular 강좌(1) - Introduction    Angular 강좌(2) - 개발환경세팅    Angular 강좌(3) - Component    Angular 강좌(4) - Angular Material    Angular 강좌(5) - 실습(1)    Angular 강좌(6) - Data Binding    Angular 강좌(7) - 실습(2)    Angular 강좌(8) - Material Table    Angular 강좌(9) - 데이터공유(@Input)    Angular 강좌(10) - 데이터공유(@Output)    Angular 강좌(11) - 데이터공유(@ViewChild)    Angular 강좌(12) - 데이터공유(Content Projection)    Angular 강좌(13) - Service    Angular 강좌(14) - Service Mediator Pattern    Angular 강좌(15) - Service RxJS    Angular 강좌(16) - Material Table Event    Angular 강좌(17) - 중간 정리    Angular 강좌(18) - Directive    Angular 강좌(19) - Pipe    Angular 강좌(20) - Component LifecycleAngular RxJS이번 포스트는 RxJS를 이용해 데이터를 공유하는 방법에 대해서 알아보겠습니다. RxJS에 대한 이론적인 내용은 다른 포스트에서알아보기로 하고 여기서는 RxJS를 이용해 우리 예제를 어떻게 구현할 수 있나에 초점을 맞추어 보도록 하죠.지금까지 작성한 우리 예제 프로그램은 search-box Component에서 Search 버튼을 클릭하면 Service의 method가 호출되서JSON 데이터를 확보합니다. 이 데이터를 자동으로 list-box Component에 전달할 방법이 없었기 때문에 list-box Component에서 Service를 이용해 데이터를 가져가는 방식으로 동작했습니다.여기서는 BehaviorSubject class를 이용해 보도록 하겠습니다. 이 BehaviorSubject는 Observable의 특별한 형태라고 보시면 됩니다. 연관된 데이터를 쉽게 구독할 수 있는 method와 데이터를 변경하기 위한method등 사용하기 쉬운 몇가지 method를 제공해서 보다 쉽게 RxJS 기능을 이용할 수 있도록 고안된 class입니다.먼저 http-support.service.ts 파일에 BehaviorSubject class 타입의 객체를 하나 생성합니다. 연관된 데이터를 생성자의인자로 이용해서 객체를 생성합니다.updateBooks: BehaviorSubject&lt;IBook[]&gt; = new BehaviorSubject&lt;IBook[]&gt;(this.books);새로운 JSON 데이터가 만들어지면 updateBooks에 데이터를 밀어 넣습니다. 다음과 같은 method를 이용합니다.this.updateBooks.next(tmp);//this.books = tmp;기존에는 JSON 데이터를 만들어서 this.books에 바로 assign했는데 이 데이터를 updateBooks의 method를 이용하여 books에 밀어 넣습니다.이제 list-box Component를 수정할 차례입니다. 데이터를 가져오기 위한 버튼은 필요없으니 HTML에서 삭제합니다. 또한 버튼이 클릭되었을 때 Service에서 데이터를 가져오는 method도 의미가 없으니 삭제해야 겠네요.list-box Component는 단순합니다. 주입된 Service의 updateBooks를 구독하고 있다가 데이터가 변경되면 변경된데이터를 자동으로 가져와 Table의 DataSource에 injection하는 코드만 작성하면 됩니다. 생성자에서 처리하면 될 듯 합니다.  constructor(private httpSupportService:HttpSupportService) {    this.httpSupportService.updateBooks.subscribe(data =&gt; {      this.books = data;      this.dataSource = new MatTableDataSource&lt;IBook&gt;(this.books);      this.dataSource.paginator = this.paginator;    })  }BehaviorSubject class의 도움을 받으면 RxJS의 이론적인 내용과 Observable에 대한 내용을 잘 몰라도 쉽게 구현이 가능합니다. 하지만 나중에 RxJS의 이론적인 내용은 한번 보셔야 합니다.마지막으로 부모 Component의 초기화 버튼을 누르면 list-box에 출력된 도서 내용도 초기화 되어야 합니다. 이 부분은 위의 내용을응용해 구현해 보세요!!우리 프로그램이 거의 완성되어가고 있습니다. 다음은 list-box에서 책을 선택하면 해당 책의 세부정보가 detail-box에 출력되도록처리해 보겠습니다.End.Angular 강좌는 아래의 책과 사이트를 참조했습니다.    조금 더 자세한 사항을 알고 싶으시면 해당 사이트를 방문하세요!!    Angular Official HomePage    Angular Material Official HomePage    Build a Mobile App with Angular 2 and Ionic 2    Angular 첫걸음 - 한빛미디어    제대로 배우는 Angular 4 - 비제이퍼블릭",
        "url": "/angular-lecture-data-share-service-rxjs"
    }
    ,
    
    "angular-lecture-data-share-service-mediator-pattern": {
        "title": "Angular 강좌(14) - Service Mediator Pattern",
            "author": "moon9342",
            "category": "",
            "content": "Angular 강좌는 여러 절로 구성되어 있습니다.     Angular 강좌(1) - Introduction    Angular 강좌(2) - 개발환경세팅    Angular 강좌(3) - Component    Angular 강좌(4) - Angular Material    Angular 강좌(5) - 실습(1)    Angular 강좌(6) - Data Binding    Angular 강좌(7) - 실습(2)    Angular 강좌(8) - Material Table    Angular 강좌(9) - 데이터공유(@Input)    Angular 강좌(10) - 데이터공유(@Output)    Angular 강좌(11) - 데이터공유(@ViewChild)    Angular 강좌(12) - 데이터공유(Content Projection)    Angular 강좌(13) - Service    Angular 강좌(14) - Service Mediator Pattern    Angular 강좌(15) - Service RxJS    Angular 강좌(16) - Material Table Event    Angular 강좌(17) - 중간 정리    Angular 강좌(18) - Directive    Angular 강좌(19) - Pipe    Angular 강좌(20) - Component LifecycleService Mediator Pattern이번 포스트는 Service의 개념을 이용해서 Component간 데이터를 공유하는 Service Mediator Pattern에 대해서 알아보겠습니다.먼저 간단한 경우부터 살펴보기로 하죠.도서종류와 검색어를 입력하고 Search! 버튼을 클릭하면 Service를 이용해서 JSON 파일로부터 데이터를 읽어들입니다. 원래는RESTful 서버를 이용해서 JSON 데이터를 가져와야 하지만 우리는 RESTful 서버를 이용하지 않으니 일단 JSON 파일로 부터 데이터를읽어들이고 데이터를 filtering해서 사용하겠습니다.먼저 부모 Component인 book-search-main Component에서 선택된 도서종류를 search-box Component에서 사용해야 하므로선택된 도서종류에 대한 값을 search-box Component에서 사용할 수 있도록 코드를 수정합니다.다음은 book-search-main.component.html 중 일부 입니다.    &lt;app-search-box [bookCategory]=\"displayCategoryName\"                    [selectedValue]=\"selectedValue\"                    (searchEvent)=\"changeTitleBar($event)\"&gt;    &lt;/app-search-box&gt;@Input decorator로 데이터를 받기 위해 search-box.component.ts를 수정해야 합니다.다음은 search-box.component.ts 파일입니다.import {  Component, OnInit,  Input, Output, EventEmitter} from '@angular/core';import { HttpSupportService } from \"../http-support.service\";import {JSON_DATA_CONFIG, JsonConfig} from \"./json-config\";@Component({  selector: 'app-search-box',  templateUrl: './search-box.component.html',  styleUrls: ['./search-box.component.css'],  providers: [    {      provide: JsonConfig,      useValue: JSON_DATA_CONFIG    }  ]})export class SearchBoxComponent implements OnInit {  _bookCategory: string;  //@Input() bookCategory:string;  //@Input('bookCategory') mySelected:string;    @Input('selectedValue') selectedValue:string;  @Input()  set bookCategory(value: string) {    if( value != null ) {      // 추가적인 작업이 들어올 수 있습니다.      this._bookCategory = 'category: ' +value;    } else {      this._bookCategory = value;    }  }  @Output() searchEvent = new EventEmitter();  keyword = null;  constructor(private httpSupportService:HttpSupportService,              private jsonConfig:JsonConfig) { }  ngOnInit() {  }  setKeyword(keyword: string): void {    this.keyword = keyword;    this.searchEvent.emit({      keyword : `${this.keyword}`,      category: `${this._bookCategory.replace('category: ','')}`    });    this.httpSupportService.getJsonData(      this.jsonConfig.url,      this.jsonConfig.name,      this.selectedValue,      this.keyword);  }  inputChange(): void {  }}부모 Component로부터 받은 도서종류와 Client로부터 입력받은 keyword를 가지고 injection된 Service의 method를 호출합니다.다음은 http-support.service.ts 파일입니다.import { Injectable } from '@angular/core';import { HttpClient } from \"@angular/common/http\";interface IBook {  bauthor: string;  bdate: string;  btranslator: string;  bpublisher: string;  btitle: string;  bprice: number;  bisbn: string;  bimgurl: string;}@Injectable()export class HttpSupportService {  books: IBook[];  constructor(private http: HttpClient) { }  getJsonData(url:string, name:string, category:string, keyword:string) {    this.http.get&lt;IBook[]&gt;(`${url}${name}`)        .subscribe(res =&gt; {           let tmp = null;           // 도서종류와 검색어를 이용한 도서 데이터 Filtering 시작           if( category == 'all' ) {             tmp = res.filter(function(item,idx,arr) {               if(item.btitle.includes(keyword)) {                 return true;               } else {                 return false;               }             });           } else if( category == 'country') {             tmp = res.filter(function(item,idx,arr) {               if(item.btitle.includes(keyword)) {                 return true;               } else {                 return false;               }             }).filter(function(item,idx,arr) {               if(item.btranslator == '') {                 return true;               } else {                 return false;               }             });           } else if( category == 'foreign') {             tmp = res.filter(function(item,idx,arr) {               if(item.btitle.includes(keyword)) {                 return true;               } else {                 return false;               }             }).filter(function(item,idx,arr) {               if(item.btranslator != '') {                 return true;               } else {                 return false;               }             });           }          // 도서종류와 검색어를 이용한 도서 데이터 Filtering 끝           this.books = tmp;           console.log(this.books);        });  }  getBooks(): IBook[] {    return this.books;  }}Filtering처리를 해야해서 코드가 좀 길어졌네요. 알기 쉽게 좀 풀어서 코드를 작성했습니다. Filtering처리된 JSON 데이터를얻어와서 일단 books 속성에 저장했습니다. 그리고 list-box Component에서 데이터를 가져가기 위해 getBooks() method를하나 작성했습니다.이제 데이터를 가져가는 list-box Component를 살펴보면 됩니다. list-box Component에서 데이터를 가져가기 위한 버튼을하나 준비합니다.다음은 list-box.component.html 파일입니다.&lt;br&gt;&lt;button mat-raised-button color=\"warn\"        (click)=\"getData()\"&gt;Get DATA!&lt;/button&gt;&lt;div class=\"example-container mat-elevation-z8\"&gt;  &lt;mat-table class=\"list-table-style\" #table [dataSource]=\"dataSource\"&gt;    &lt;ng-container matColumnDef=\"bisbn\"&gt;      &lt;mat-header-cell *matHeaderCellDef&gt; ISBN &lt;/mat-header-cell&gt;      &lt;mat-cell *matCellDef=\"let element\"&gt;  &lt;/mat-cell&gt;    &lt;/ng-container&gt;    &lt;ng-container matColumnDef=\"btitle\"&gt;      &lt;mat-header-cell *matHeaderCellDef&gt; Title &lt;/mat-header-cell&gt;      &lt;mat-cell *matCellDef=\"let element\"&gt;  &lt;/mat-cell&gt;    &lt;/ng-container&gt;    &lt;ng-container matColumnDef=\"bauthor\"&gt;      &lt;mat-header-cell *matHeaderCellDef&gt; Author &lt;/mat-header-cell&gt;      &lt;mat-cell *matCellDef=\"let element\"&gt;  &lt;/mat-cell&gt;    &lt;/ng-container&gt;    &lt;ng-container matColumnDef=\"bprice\"&gt;      &lt;mat-header-cell *matHeaderCellDef&gt; Price &lt;/mat-header-cell&gt;      &lt;mat-cell *matCellDef=\"let element\"&gt;  &lt;/mat-cell&gt;    &lt;/ng-container&gt;    &lt;mat-header-row class=\"list-header-style\"                    *matHeaderRowDef=\"displayedColumns\"&gt;    &lt;/mat-header-row&gt;    &lt;mat-row *matRowDef=\"let row; columns: displayedColumns;\"&gt;&lt;/mat-row&gt;  &lt;/mat-table&gt;  &lt;mat-paginator #paginator                 [pageSize]=\"5\"                 [pageSizeOptions]=\"[5, 10, 20]\"                 showFirstLastButtons&gt;  &lt;/mat-paginator&gt;&lt;/div&gt;Table 상단에 Get DATA!라는 버튼을 만들고 event binding을 시켰습니다. 마지막으로 list-box.component.ts 파일의 내용입니다.import { Component, OnInit } from '@angular/core';import { HttpClient } from \"@angular/common/http\";import { MatTableDataSource } from '@angular/material';import { MatPaginator } from '@angular/material';import { ViewChild } from '@angular/core';import {HttpSupportService} from \"../http-support.service\";interface IBook {  bauthor: string;  bdate: string;  btranslator: string;  bpublisher: string;  btitle: string;  bprice: number;  bisbn: string;  bimgurl: string;}@Component({  selector: 'app-list-box',  templateUrl: './list-box.component.html',  styleUrls: ['./list-box.component.css']})export class ListBoxComponent {  displayedColumns = ['bisbn', 'btitle', 'bauthor', 'bprice'];  dataSource;  books: IBook[];  @ViewChild(MatPaginator) paginator: MatPaginator;  constructor(private httpSupportService:HttpSupportService) {  }  getData(): void {    this.books = this.httpSupportService.getBooks();    this.dataSource = new MatTableDataSource&lt;IBook&gt;(this.books);    this.dataSource.paginator = this.paginator;  }}주입된 Service객체를 이용해서 Service에 저장되 있는 JSON데이터를 가져다가 Table의 DataSource에 설정하게 됩니다.내용이 좀 많지만 천천히 따라가면서 살펴보시면 어렵지 않게 이해하실 수 있습니다. 그림으로 보자면 아래와 같은 형태입니다.동작은 잘 하지만 list-box Component에 데이터를 가져오기 위해서 버튼을 한번 더 클릭해야 한다는 것이 좀 그렇네요.Service에 의해서 데이터가 공유되는 건 확인했지만 새로 검색을 해서 데이터가 변경되면 당연히 list쪽에서는 데이터가자동으로 변경되지 않습니다.이 문제는 RxJS를 이용해서 처리할 수 있습니다. 다음 포스트에서는 RxJS를 이용해서 데이터의 흐름을 subscribe(구독) 하고 구독하고 있는 데이터를 어떻게 변경해야 하는지에 대해서 알아보겠습니다.End.Angular 강좌는 아래의 책과 사이트를 참조했습니다.    조금 더 자세한 사항을 알고 싶으시면 해당 사이트를 방문하세요!!    Angular Official HomePage    Angular Material Official HomePage    Build a Mobile App with Angular 2 and Ionic 2    Angular 첫걸음 - 한빛미디어    제대로 배우는 Angular 4 - 비제이퍼블릭",
        "url": "/angular-lecture-data-share-service-mediator-pattern"
    }
    ,
    
    "angular-lecture-data-share-service": {
        "title": "Angular 강좌(13) - Service",
            "author": "moon9342",
            "category": "",
            "content": "Angular 강좌는 여러 절로 구성되어 있습니다.     Angular 강좌(1) - Introduction    Angular 강좌(2) - 개발환경세팅    Angular 강좌(3) - Component    Angular 강좌(4) - Angular Material    Angular 강좌(5) - 실습(1)    Angular 강좌(6) - Data Binding    Angular 강좌(7) - 실습(2)    Angular 강좌(8) - Material Table    Angular 강좌(9) - 데이터공유(@Input)    Angular 강좌(10) - 데이터공유(@Output)    Angular 강좌(11) - 데이터공유(@ViewChild)    Angular 강좌(12) - 데이터공유(Content Projection)    Angular 강좌(13) - Service    Angular 강좌(14) - Service Mediator Pattern    Angular 강좌(15) - Service RxJS    Angular 강좌(16) - Material Table Event    Angular 강좌(17) - 중간 정리    Angular 강좌(18) - Directive    Angular 강좌(19) - Pipe    Angular 강좌(20) - Component LifecycleService이번 포스트는 Angular의 Service에 대해서 알아보겠습니다. 먼저 Service의 기본적인 사항들을 알아본 후 이를 통해 데이터를 공유하는Service Mediator Pattern으로 넘어가면 될 듯 하네요.이 Service는 Angular에만 존재하는 개념이 아닙니다. 객체지향 프로그래밍을 다뤄보신 분은 익히 들어본 개념입니다. 특히 Spring과 같은 Framework이나 MVC Pattern을 다뤄보신 분들이라면 쉽게 이해하실 수 있는 내용입니다.우리는 Angular를 하고 있으니 여기에 맞춰 설명을 하자면 Component는 View를 표현하고 관리하는게 주된 역할입니다. 즉, 데이터를 받아와서 View에 출력한다던지 View의 값이 변경되면 그걸 또 어떻게 처리한다던지하는 View와 밀접한 로직을 Component class가가지고 있게 됩니다.만약 View를 처리하는 로직 이외의 별도의 로직이 필요하면 그 로직은 어디에 두는것이 좋을까요? 로그인 처리를 할때필요한 인증로직이라던지 혹은 서버와의 데이터 통신을 위한 REST 서버의 호출같은 로직을 그냥 필요할 때마다 Component안에 집어 넣어서 처리하는게 좋을까요?우리는 CBD(Component Based Development)를 하고 있습니다. 각각의 Component는 자신의 주된 관심사에 집중하게끔 코드를 작성해야합니다. 객체지향설계에서 얘기하는 SRP(Single Responsibility Principle)을 생각하시면 됩니다. Component안에 다른 관심사가존재하면 Component의 독립성이 보장되지 못하고 결국 중복 코드가 발생하며 Component의 재사용과 유지보수에 문제가 발생하게되겠죠.그래서 위에서 얘기한 별도의 로직들은 다른 곳에서 관리할 필요가 있습니다. Service라는 걸 이용해서 이 로직들을 작성하고 다른 Component에서 이 Service를 가져다가사용하는 식으로 관리를 하면 SoC(Separation of Concern)원칙에 잘 들어맞을 거 같습니다.이렇게 Component와 Service를 분리해서 작성하고 Component에서 Service를 사용하는 건 좋은데 사용할 때 문제가 하나 있습니다. Dependency라는게 생기는 거죠. 쉽게 단위 코드로 Component에서Service를 사용하는 예를 한번 보죠. 아래는 Component class입니다.MyService service = new MyService();service.getUserAuth('moon9342');pseudocode 입니다. Component class안에서 직접 Service 객체를 생성해서 이용하는 경우입니다. 이런 경우 우리 Component는Service에 의존하게 됩니다. 이걸 Dependency Relationship(의존관계)이 존재한다 라고 표현하기도 합니다. 이 때 Componentclass의 입장에서 Service 객체를 Dependency라고 표현합니다.이렇게 의존관계가 성립되면 Service가 변경되었을 때 우리 Component는 그에 따른 영향을 받을 수 밖에 없습니다. 연관관계가 강하게 성립되어서 서로 독립적으로 사용하는게 힘들어지는것이고 재사용이나 유지보수에 문제가 생기게 되겠네요.이 문제를 해결하는 Design Pattern이 바로 DI(Dependency Injection)입니다. 우리 Service객체(Dependency)를 사용하는 객체인Component에게 주입해서 사용하는 것입니다. 주입하는 방법은 일반적으로 constructor를 이용하는 방법과 setter를 이용하는 방법이있는데 Angular는 constructor injection을 지원합니다.즉, Component가 직접 Service를 new keyword로 생성하는 것이 아니라 Angular Framework이 Service를 Component가 사용할 있도록Service객체를 생성해서 Component에게 넣어주는 방식입니다. 이걸 IoC(Inversion of Control)라고 합니다. Angular Framework은 IoC Container입니다.이론적인 배경을 간단히 설명했으니 이제 Service를 우리 예제에 추가해보겠습니다. Angular application은 Module의 집합입니다. Module은 크게 Feature Module과 Shared Module이 있다는 얘기 혹시 기억하시나요? 어디에 Service를 생성하느냐 하는 문제인데 사실 case-by-case입니다.특성상 여러 Feature Module에서 사용하는 공통 로직의 개념이면 따로 Shared Module을 만들어서 그 안에 Service를 포함시키는게 좋습니다. 하지만 우리 예제처럼 bookSearch Module에서만 사용할 생각이면 해당 Module안에 포함시키는게더 좋은 선택이겠죠.Service 생성다음의 코드를 이용해 우리 bookSearch Module에 서비스를 하나 추가합니다.command 창을 열어서 다음과 같은 명령어를 실행시킵니다.  ng generate service HttpSupport성공적으로 수행되면 현재 Module 폴더에 2개의 파일이 생성됩니다. 하나는 SPEC 파일이고 나머지 하나가 바로 Service 입니다.다음은 http-support.service.ts 파일의 내용입니다.import { Injectable } from '@angular/core';@Injectable()export class HttpSupportService {  constructor() { }}주의해서 보셔야 하는 부분은 @Injectable decorator입니다. 해당 class가 다른 class에 주입(Injection)될 수 있다는걸의미합니다. 아까도 설명했듯이 주입은 생성자를 이용하게 되고 주입과정은 Angular Framework이 담당합니다.이제 이 안에 JSON 데이터를 가져오는 코드를 작성해야 합니다. 우리 예제의 list-box Component는 View를 rendering할 때 HttpClient를 이용해 JSON데이터를 가져와 Material Table로 화면에 바로 출력합니다. 이 부분을 변경해야겠죠.search-box Component에서 Search! 버튼을 클릭하면 HttpClient를 이용해서 데이터를 가져와서 그 데이터를 list-box가사용할 수 있도록 처리해야 합니다.원래는 Back End 프로그램도 하나 작성해서 RESTful 서비스 하는걸 예로 들어야 하는데 서버쪽 프로그램이 없으니 그냥 JSON 파일로부터 데이터를 받는걸로 처리했습니다.다음은 수정된 http-support.service.ts 파일의 내용입니다.import { Injectable } from '@angular/core';import { HttpClient } from \"@angular/common/http\";interface IBook {  bauthor: string;  bdate: string;  btranslator: string;  bpublisher: string;  btitle: string;  bprice: number;  bisbn: string;  bimgurl: string;}@Injectable()export class HttpSupportService {  books: IBook[];  constructor(private http: HttpClient) { }  getJsonData() {    this.http.get&lt;IBook[]&gt;('assets/data/book.json')        .subscribe(res =&gt; {           this.books = res;           console.log(this.books);        });  }}interface IBook도 저런식으로 코드마다 등장해서는 안되겠죠. 원래 따로 빼서 관리해야 합니다. 하지만 예제를 좀 이해하기 쉽도록 그냥 중복해서 썻습니다. ^^;;constructor(private http: HttpClient) { }생성자로 인자가 하나 들어옵니다. 사실 이것도 HttpClient 타입의 객체가 우리 서비스 안으로 Injection되는 것입니다.생성자에 인자를 받으면서 Access Modifier를 이용하면 class안에 속성으로 자동 지정됩니다. 여기서는 private으로 Injection된 HttpClient 객체를 받았습니다.getJsonData() method가 호출되면 Injection받은 HttpClient 객체를 이용해서 파일로부터 JSON 데이터를 읽어들인 후 console에 정상적으로 읽었는지 출력합니다.Service Injection위에서 생성한 Service 객체를 search-box Component에 Injection한 후 사용해 보겠습니다.다음은 search-box.component.ts 파일의 내용입니다.import {  Component, OnInit,  Input, Output, EventEmitter} from '@angular/core';import { HttpSupportService } from \"../http-support.service\";@Component({  selector: 'app-search-box',  templateUrl: './search-box.component.html',  styleUrls: ['./search-box.component.css'],  providers: [    HttpSupportService  ]})export class SearchBoxComponent implements OnInit {  _bookCategory: string;  //@Input() bookCategory:string;  //@Input('bookCategory') mySelected:string;  @Input()  set bookCategory(value: string) {    if( value != null ) {      // 추가적인 작업이 들어올 수 있습니다.      this._bookCategory = 'category: ' +value;    } else {      this._bookCategory = value;    }  }  @Output() searchEvent = new EventEmitter();  keyword = null;  constructor(private httpSupportService:HttpSupportService) { }  ngOnInit() {  }  setKeyword(keyword: string): void {    this.keyword = keyword;    this.searchEvent.emit({      keyword : `${this.keyword}`,      category: `${this._bookCategory.replace('category: ','')}`    });    this.httpSupportService.getJsonData();  }  inputChange(): void {  }}기존 코드에서 변경된 부분을 살펴보면import { HttpSupportService } from \"../http-support.service\";기본적으로 import는 시켜줘야 사용할 수 있겠지요.constructor(private httpSupportService:HttpSupportService) { }constructor를 이용해 Service가 Injection되었습니다.this.httpSupportService.getJsonData();Injection받은 Service의 method를 호출하는 부분입니다.@Component({  selector: 'app-search-box',  templateUrl: './search-box.component.html',  styleUrls: ['./search-box.component.css'],  providers: [    HttpSupportService  ]})Angular Framework에 어떤 class가 Injection이 되는지 알려줘야 합니다. Component의 Metadata부분에providers를 이용해 처리해야 합니다.실행해보면 정상적으로 console에 JSON데이터가 출력되는걸 확인하실 수 있습니다.Injector기본적으로 Angular Framework은 dependency객체를 어떻게 생성해야 하는지 알지 못합니다. 그래서 우리가 Component의 Metadata를 이용해서 providers에 그 정보를 명시했었지요. 이 정보를 근간으로 Injector가 의존객체를 생성하고주입합니다.정리하자면 Component가 생성될 때 Angualr는 Injection에 필요한 객체를 Injector에 요청합니다. 이 Injector는 이미 생성한 객체들을 담고 있는 Container를 유지하고 있는데 이 안에 객체가 있으면 바로 주입하고 그렇지 않으면의존객체를 생성한 후 주입하게 됩니다.그림으로 표현하면 다음과 같습니다.( 이미지 출처 : https://angular.io/guide/architecture )여기서 주의해야 할 점이 있는데 각각의 Component 각자 하나씩의 Injector를 가지고 있습니다. Component는 tree형식으로구성되니 Injector 역시 tree형태로 구성이 되게됩니다. 만약 Injection요청에 대한 내용이 현재 Component의 providers부분에명시되어 있지 않으면 부모 Component의 providers에서 검색하게 됩니다. 이렇게 부모로 타고 올라가면서 의존객체를 찾게 되는것이죠.만약 상위 Component에서 의존객체를 생성해 놓았으면 하위 Component에서 따로 선언하지 않아도 사용이 가능합니다.또한 Component의 providers에 등록해 놓을 수도 있지만 Module의 providers에도 등록할 수 있습니다. 이런 경우 해당 Module안에있는 모든 Component들이 해당 의존모듈을 사용할 수 있게 되겠네요. 최상위 Component인 Root Component가 가지고 있는Root Injector는 Application 전역에서 사용가능한 의존모듈을 가지고 있게 되겠네요.Provider위에서 설명했듯이 Module안에 providers로 등록한 의존객체는 Module안에서 사용이 가능합니다. Component에서 등록한 의존객체는자신과 자식 Component에서 사용이 가능하지요.이렇게 보면 Module과 Component에 등록하는게 크게 차이가 없어 보이지만 Module에 등록하는 경우 의존객체는 하나의 객체가 생성되서 사용됩니다. 즉, Singleton 형태로 사용된다는 것이죠. 반면 Component에 등록된 의존객체는 해당 Component가 생성될 때 마다 의존객체가 따로 생성되게 됩니다.따라서 정보공유를 목적으로 하는 Service Mediator Pattern을 이용할 경우 일반적으로 Module에 의존객체를 등록해서 사용하는것이좋습니다.이 provider에 대해서 조금만 더 알아보도록 하죠.Component안에서 의존객체를 등록하려면 다음의 코드를 이용합니다.@Component({  selector: 'app-search-box',  templateUrl: './search-box.component.html',  styleUrls: ['./search-box.component.css'],  providers: [    HttpSupportService  ]})우리는 지금 의존객체라는 표현을 쓰면서 객체만이 주입되는식으로 표현했는데 실제 객체뿐만 아니라 Value도 주입할 수 있습니다. 일단 먼저 의존객체를 주입하는 방식에 대해서 코드를 조금만 상세히 표현해 보겠습니다. 위의 코드는 사실 밑의 코드의 축약형 입니다.@Component({  selector: 'app-search-box',  templateUrl: './search-box.component.html',  styleUrls: ['./search-box.component.css'],  providers: [    {      provide: HttpSupportService,    // 데이터 타입      useClass: HttpSupportService    // 실제 객체를 생성하기 위해 필요한 class명    }  ]})provide의 값과 useClass의 값이 같을 경우 축약형으로 표현할 수 있습니다. provide는 만들어지는 객체의 데이터 타입입니다.useClass는 실제 객체를 생성하기 위해 사용되는 class명이구요. 당연히 두개가 틀릴 수 있습니다. interface를 이용하거나 duck typing을 이용하면 서로 다른 데이터 타입과 class를 사용할 수 있습니다.duck typing에 대해서는 여기를 클릭하시면 간단한 내용을 확인하실 수 있습니다.이번에는 의존객체가 아닌 고정값을 주입하는 방법에 대해서 알아보겠습니다. 일반적인 예는 configuration 값을 주입받는 경우입니다.간단하게 환경설정파일을 하나 만들어서 그 안에 configuration내용을 채워놓고 그 값을 주입받아 보겠습니다.command 창을 열어 다음의 명령을 실행해서 하나의 class를 생성합니다. 현재 command 창의 working directory는search-box Component의 위치입니다.  ng generate class jsonConfigjson-config.ts 파일이 생성됩니다. 해당 파일에 다음과 같이 우리가 사용하는 JSON 파일에 대한 경로와 파일명을 설정정보로입력합니다.export class JsonConfig {  url: string;  name: string;}export const JSON_DATA_CONFIG: JsonConfig = {  url: 'assets/data/',  name: 'book.json'};다음은 search-box.component.ts 파일의 내용입니다.import {  Component, OnInit,  Input, Output, EventEmitter} from '@angular/core';import { HttpSupportService } from \"../http-support.service\";import { JSON_DATA_CONFIG, JsonConfig } from \"./json-config\";@Component({  selector: 'app-search-box',  templateUrl: './search-box.component.html',  styleUrls: ['./search-box.component.css'],  providers: [    {      provide: HttpSupportService,      useClass: HttpSupportService    },    {      provide: JsonConfig,      useValue: JSON_DATA_CONFIG    }  ]})export class SearchBoxComponent implements OnInit {  _bookCategory: string;  //@Input() bookCategory:string;  //@Input('bookCategory') mySelected:string;  @Input()  set bookCategory(value: string) {    if( value != null ) {      // 추가적인 작업이 들어올 수 있습니다.      this._bookCategory = 'category: ' +value;    } else {      this._bookCategory = value;    }  }  @Output() searchEvent = new EventEmitter();  keyword = null;  constructor(private httpSupportService:HttpSupportService,              private jsonConfig:JsonConfig) { }  ngOnInit() {  }  setKeyword(keyword: string): void {    this.keyword = keyword;    this.searchEvent.emit({      keyword : `${this.keyword}`,      category: `${this._bookCategory.replace('category: ','')}`    });    this.httpSupportService.getJsonData(this.jsonConfig.url, this.jsonConfig.name);  }  inputChange(): void {  }}기존에 비해 몇가지 사항이 달라졌습니다. Value를 Injection받을 때 어떻게 처리해야 하는지를 유심히 보시면 됩니다.service의 method를 호출할 때 주입값을 가지고 method를 호출하기 때문에 service의 코드도 변경해야 합니다.다음은 http-support.service.ts 파일의 내용입니다.import { Injectable } from '@angular/core';import {HttpClient} from \"@angular/common/http\";interface IBook {  bauthor: string;  bdate: string;  btranslator: string;  bpublisher: string;  btitle: string;  bprice: number;  bisbn: string;  bimgurl: string;}@Injectable()export class HttpSupportService {  books: IBook[];  constructor(private http: HttpClient) { }  getJsonData(url:string, name:string) {    this.http.get&lt;IBook[]&gt;(`${url}${name}`)        .subscribe(res =&gt; {           this.books = res;           console.log(this.books);        });  }}마지막으로 한가지가 더 남아있습니다. 의존객체를 생성할 때 객체를 그대로 사용하는게 아니라 특정 로직을 거쳐 의존객체를 생성해사용할 수 있습니다. 객체지향에서 나왔던 Factory Pattern 생각하시면 됩니다. 이 부분은 여기서 따로 설명하지는 않겠습니다.Optional DependencyOptional Dependency는 의존객체의 주입이 필수가 아니라는 것을 의미합니다. @Optional decorator를 이용하면 의존객체가존재하지 않더라도 프로그램 오류가 나지 않습니다.단순히 생성자에서 의존객체를 주입받을 때 @Optional decorator를 명시하시면 됩니다. 물론 의존객체가 들어오지 않을때의로직처리는 해 주어야 합니다.constructor(private httpSupportService:HttpSupportService,            @optional private jsonConfig:JsonConfig) { }이번 포스트에서는 Angular의 Service에 대해서 알아보았습니다. 기본적인 Service의 사용방법을 먼저 숙지하신 후 이 Service를이용해 데이터를 공유하는 방법으로 넘어가면 될 듯 보입니다. 다음 포스트는 Service Mediator Pattern을 이용한 Component간데이터 공유에 대해서 알아보도록 하겠습니다.End.Angular 강좌는 아래의 책과 사이트를 참조했습니다.    조금 더 자세한 사항을 알고 싶으시면 해당 사이트를 방문하세요!!    Angular Official HomePage    Angular Material Official HomePage    Build a Mobile App with Angular 2 and Ionic 2    Angular 첫걸음 - 한빛미디어    제대로 배우는 Angular 4 - 비제이퍼블릭",
        "url": "/angular-lecture-data-share-service"
    }
    ,
    
    "angular-lecture-data-share-4": {
        "title": "Angular 강좌(12) - 데이터공유(Content Projection)",
            "author": "moon9342",
            "category": "",
            "content": "Angular 강좌는 여러 절로 구성되어 있습니다.     Angular 강좌(1) - Introduction    Angular 강좌(2) - 개발환경세팅    Angular 강좌(3) - Component    Angular 강좌(4) - Angular Material    Angular 강좌(5) - 실습(1)    Angular 강좌(6) - Data Binding    Angular 강좌(7) - 실습(2)    Angular 강좌(8) - Material Table    Angular 강좌(9) - 데이터공유(@Input)    Angular 강좌(10) - 데이터공유(@Output)    Angular 강좌(11) - 데이터공유(@ViewChild)    Angular 강좌(12) - 데이터공유(Content Projection)    Angular 강좌(13) - Service    Angular 강좌(14) - Service Mediator Pattern    Angular 강좌(15) - Service RxJS    Angular 강좌(16) - Material Table Event    Angular 강좌(17) - 중간 정리    Angular 강좌(18) - Directive    Angular 강좌(19) - Pipe    Angular 강좌(20) - Component LifecycleContent Projection이번 포스트는 과거 AngularJS에서 transclusion이라고 불리었던 Content Projection에 대해서 알아보겠습니다. 쉽게 말하자면부모 Component가 자식 Component에게 template을 전달해 줄 수 있는 기능입니다. 이 역시 우리 예제에서는 필요없는 부분이지만 간단하게 내용을 추가해서 알아보겠습니다.다음은 book-search-main.component.html의 내용입니다.&lt;div class=\"bookSearch-outer\"&gt;  &lt;div class=\"d-flex align-items-center p-3 my-3 text-white-50 bg-purple rounded box-shadow\"&gt;    &lt;img class=\"mr-3\" src=\"assets/images/search-icon.png\" alt=\"\" width=\"48\" height=\"48\"&gt;    &lt;div class=\"lh-100\"&gt;      &lt;h5 #resultStatus class=\"mb-0 text-white lh-100\"&gt;Search Result : {{searchTitle}}&lt;/h5&gt;    &lt;/div&gt;  &lt;/div&gt;  &lt;div class=\"example-container\"&gt;    &lt;mat-form-field&gt;      &lt;mat-select placeholder=\"도서종류\"                  #bookCategorySelect                  [(ngModel)]=\"selectedValue\"                  (ngModelChange)=\"changeValue(bookCategorySelect.value)\"&gt;        &lt;mat-option *ngFor=\"let category of bookCaterory\"                    [value]=\"category.value\"&gt;          {{ category.viewValue }}        &lt;/mat-option&gt;      &lt;/mat-select&gt;    &lt;/mat-form-field&gt;    &lt;button mat-raised-button color=\"primary\"            (click)=\"clearCondition()\"&gt;검색 초기화&lt;/button&gt;    &lt;button mat-raised-button color=\"primary\"            (click)=\"changeDOM()\"&gt;DOM 직접 변경&lt;/button&gt;  &lt;/div&gt;  &lt;div&gt;    &lt;app-search-box [bookCategory]=\"displayCategoryName\"                    (searchEvent)=\"changeTitleBar($event)\"&gt;      &lt;p&gt;Content Projection!&lt;/p&gt;      &lt;p&gt;First Paragraph&lt;/p&gt;      &lt;p&gt;Second Paragraph&lt;/p&gt;    &lt;/app-search-box&gt;  &lt;/div&gt;  &lt;div&gt;    &lt;app-detail-box&gt;&lt;/app-detail-box&gt;  &lt;/div&gt;  &lt;div&gt;    &lt;app-list-box&gt;&lt;/app-list-box&gt;  &lt;/div&gt;&lt;/div&gt;기존에 비해 변경된 부분만 보시면 됩니다. 위의 코드 중&lt;app-search-box [bookCategory]=\"displayCategoryName\"                (searchEvent)=\"changeTitleBar($event)\"&gt;  &lt;p&gt;Content Projection!&lt;/p&gt;  &lt;p&gt;First Paragraph&lt;/p&gt;  &lt;p&gt;Second Paragraph&lt;/p&gt;&lt;/app-search-box&gt;부분을 보면 하위 Component를 포함시키면서 3개의 &lt;p&gt; Element를 전달한 것을 보실 수 있습니다. 이렇게 부모 Component가자식 Component에게 특정 template을 전달해 줄 수 있는 기능이라고 생각하시면 됩니다. 자식 Component인search-box.component.html은 다음과 같이 작성합니다.&lt;div class=\"example-container\"&gt;  &lt;mat-toolbar #toolbar class=\"search-toolbar-style\"&gt;    Search Keyword : {{keyword}}    &lt;ng-container *ngIf=\"_bookCategory != null\"&gt;      ( {{_bookCategory}} )    &lt;/ng-container&gt;  &lt;/mat-toolbar&gt;  &lt;mat-form-field&gt;    &lt;input matInput #inputKeyword placeholder=\"Search Keyword\"           [(ngModel)]=\"keyword\" (ngModelChange)=\"inputChange()\"&gt;  &lt;/mat-form-field&gt;  &lt;button mat-raised-button color=\"warn\"          (click)=\"setKeyword(inputKeyword.value)\"&gt;Search!&lt;/button&gt;  &lt;ng-content&gt;&lt;/ng-content&gt;&lt;/div&gt;다른 부분은 다 동일하고 맨 마지막에 &lt;ng-content&gt;&lt;/ng-content&gt; directive가 보입니다. 이 directive가 부모 Component가전달해 준 template으로 치환되게 됩니다.다음에는 Service에 대해서 알아본 후 이를 이용한 데이터 공유 방법인 Service Mediator Pattern에 대해서 알아보도록 하겠습니다.End.Angular 강좌는 아래의 책과 사이트를 참조했습니다.    조금 더 자세한 사항을 알고 싶으시면 해당 사이트를 방문하세요!!    Angular Official HomePage    Angular Material Official HomePage    Build a Mobile App with Angular 2 and Ionic 2    Angular 첫걸음 - 한빛미디어    제대로 배우는 Angular 4 - 비제이퍼블릭",
        "url": "/angular-lecture-data-share-4"
    }
    ,
    
    "angular-lecture-data-share-3": {
        "title": "Angular 강좌(11) - 데이터공유(@ViewChild)",
            "author": "moon9342",
            "category": "",
            "content": "Angular 강좌는 여러 절로 구성되어 있습니다.     Angular 강좌(1) - Introduction    Angular 강좌(2) - 개발환경세팅    Angular 강좌(3) - Component    Angular 강좌(4) - Angular Material    Angular 강좌(5) - 실습(1)    Angular 강좌(6) - Data Binding    Angular 강좌(7) - 실습(2)    Angular 강좌(8) - Material Table    Angular 강좌(9) - 데이터공유(@Input)    Angular 강좌(10) - 데이터공유(@Output)    Angular 강좌(11) - 데이터공유(@ViewChild)    Angular 강좌(12) - 데이터공유(Content Projection)    Angular 강좌(13) - Service    Angular 강좌(14) - Service Mediator Pattern    Angular 강좌(15) - Service RxJS    Angular 강좌(16) - Material Table Event    Angular 강좌(17) - 중간 정리    Angular 강좌(18) - Directive    Angular 강좌(19) - Pipe    Angular 강좌(20) - Component Lifecycle부모 Component의 직접적인 자식 요소 제어이번 포스트는 부모 Component에서 자식 요소에 직접 접근하는 방법에 대해서 알아보겠습니다. 이전 포스트에서 @Input decorator를이용해 부모 Component에서 자식 Component로 데이터를 전달하는 방법에 대해서 알아보았는데 이번에는 약간 다릅니다.부모 Component는 자식 Component 객체뿐만 아니라 자식으로 포함된 Directive에 직접 접근할 수 있고 또한Component가 Rendering하는 View자체에 직접 접근할 수 있습니다.하지만 이런 접근 방법이 항상 좋은건 아닙니다. 오히려 좋지 않은 현상이 발생하게 됩니다. 예를 들어 Component가 직접적으로 DOM에 접근해서 제어하는 코드를 작성한다고 가정해 보죠. 일단 간단하게 프로그램을 구현할 수 있으나 나중에 Component의 View가 변경되면 Component에서 처리하는 부분도 당연히 그에 맞게 바뀌어야 합니다. Component의 재사용성과 유지보수성에 문제가 생길 여지가 있습니다.그렇기 때문에 이런 직접적인 접근방식은 꼭 필요한 경우가 아니면 지양하는 것이 좋습니다.그럼 천천히 한번 알아보도록 하죠.@ViewChild, @ViewChildren Decorator부모 Component template안에 위치한 모든 자식 요소들을 ViewChild라고 합니다. 이 ViewChild안에는 자식 Component 객체뿐만아니라 Component가 Rendering하는 View의 DOM 그리고 Directive가 포함됩니다.자식 Component객체에 직접 접근하는 방법부터 살펴보도록 하겠습니다.자식 Component 객체에 직접 접근하려면 @ViewChild decorator를 이용하시면 됩니다. 조건에 부합되는 객체 1개를 찾게되고그에 대한 property를 지정해서 사용할 수 있습니다. 만약 @ViewChildren을 이용하면 조건에 부합되는 객체를 모두 찾게 되고QueryList 형태로 객체들의 집합을 얻을 수 있습니다. QueryList는 실제 배열이 아니기 때문에 toArray() method를 이용해배열을 얻어내 이용할 수 있습니다.그럼 간단한 예를 가지고 알아보도록 하죠.부모 Component에 초기화버튼을 하나 만들어서 해당 버튼을 누르면 Client가 선택한 도서 종류와 입력된 키워드를 초기화 시키는작업을 해 보도록 하겠습니다.먼저 초기화버튼을 만들어야 하니 book-search-main.component.html부터 수정해야 합니다.&lt;div class=\"bookSearch-outer\"&gt;  &lt;div class=\"d-flex align-items-center p-3 my-3 text-white-50 bg-purple rounded box-shadow\"&gt;    &lt;img class=\"mr-3\" src=\"assets/images/search-icon.png\" alt=\"\" width=\"48\" height=\"48\"&gt;    &lt;div class=\"lh-100\"&gt;      &lt;h5 class=\"mb-0 text-white lh-100\"&gt;Search Result : &lt;/h5&gt;    &lt;/div&gt;  &lt;/div&gt;  &lt;div class=\"example-container\"&gt;    &lt;mat-form-field&gt;      &lt;mat-select placeholder=\"도서종류\"                  #bookCategorySelect                  [(ngModel)]=\"selectedValue\"                  (ngModelChange)=\"changeValue(bookCategorySelect.value)\"&gt;        &lt;mat-option *ngFor=\"let category of bookCaterory\"                    [value]=\"category.value\"&gt;                  &lt;/mat-option&gt;      &lt;/mat-select&gt;    &lt;/mat-form-field&gt;    &lt;button mat-raised-button color=\"primary\"            (click)=\"clearCondition()\"&gt;검색 초기화&lt;/button&gt;  &lt;/div&gt;  &lt;div&gt;    &lt;app-search-box [bookCategory]=\"displayCategoryName\"                    (searchEvent)=\"changeTitleBar($event)\"&gt;&lt;/app-search-box&gt;  &lt;/div&gt;  &lt;div&gt;    &lt;app-detail-box&gt;&lt;/app-detail-box&gt;  &lt;/div&gt;  &lt;div&gt;    &lt;app-list-box&gt;&lt;/app-list-box&gt;  &lt;/div&gt;&lt;/div&gt;검색 초기화 버튼을 생성하고 해당 버튼을 클릭하면 clearCondition() method가 호출되도록 처리했습니다.다음은 부모 Component인 book-search-main.component.ts 파일입니다. clearCondition() method를 작성해야하고해당 method안에서 자신의 검색에 관련된 사항을 초기화하고 자식 Component를 찾아 자식 Component의 property를초기화시키는 작업을 진행합니다.import {Component, OnInit,        ViewChild, ViewChildren, QueryList } from '@angular/core';import { SearchBoxComponent } from \"../search-box/search-box.component\";@Component({  selector: 'app-book-search-main',  templateUrl: './book-search-main.component.html',  styleUrls: ['./book-search-main.component.css']})export class BookSearchMainComponent implements OnInit {  selectedValue = null;  displayCategoryName = null;  bookCaterory = [    {value: 'all', viewValue: '국내외도서'},    {value: 'country', viewValue: '국내도서'},    {value: 'foreign', viewValue: '국외도서'}  ];  searchTitle = null;  constructor() { }  ngOnInit() {  }  changeValue(category: string): void {    for(let element of this.bookCaterory ) {      if(element.value == category) {        this.displayCategoryName = element.viewValue;      }    }  }  changeTitleBar(searchInfo) : void {    this.searchTitle = `${searchInfo.keyword} ( ${searchInfo.category} )`;  }  @ViewChild(SearchBoxComponent) searchComp: SearchBoxComponent;  @ViewChildren(SearchBoxComponent) searchCompArr: QueryList&lt;SearchBoxComponent&gt;;  clearCondition(): void {    this.selectedValue = null;    this.searchTitle = null;/*    @ViewChild를 사용할 경우    this.searchComp._bookCategory = null;    this.searchComp.keyword = null;*/    // @ViewChildren을 사용할 경우    this.searchCompArr.toArray()[0]._bookCategory = null;    this.searchCompArr.toArray()[0].keyword = null;  }}부모 Component와 자식 Component가 데이터를 공유하는게 아니라 부모 Component가 직접 자식 Component 객체를제어하는 방식입니다.Component가 Rendering하는 View의 DOM에 직접 접근@ViewChild와 @ViewChildren을 이용하면 자식 Component의 객체뿐 아니라 Component가 rendering하는 View의DOM에 직접 접근할 수 있습니다. 이전에 나왔던 Template Reference Variable을 이용해서 Component가 DOM에 접근하는 것이죠.우리 예제에 딱히 필요하진 않지만 이해를 돕기 위해 버튼 하나를 더 추가해 어떻게 사용하는지 살펴보겠습니다.book-search-main.component.html을 수정해 버튼을 하나 더 추가합니다.......&lt;h5 #resultStatus class=\"mb-0 text-white lh-100\"&gt;Search Result : &lt;/h5&gt;.........    &lt;button mat-raised-button color=\"primary\"            (click)=\"changeDOM()\"&gt;DOM 직접 변경&lt;/button&gt;......            일부만 표시했습니다. 결과를 표시하는 영역에 Template Reference Variable #resultStatus을 지정했습니다. 그리고 버튼을 하나추가했구요. 해당 버튼을 클릭하면 changeDOM() method가 호출되겠네요.다음은 book-search-main.component.ts 파일 내용입니다.import {Component, OnInit,        ViewChild, ViewChildren, QueryList,        ElementRef } from '@angular/core';import { SearchBoxComponent } from \"../search-box/search-box.component\";@Component({  selector: 'app-book-search-main',  templateUrl: './book-search-main.component.html',  styleUrls: ['./book-search-main.component.css']})export class BookSearchMainComponent implements OnInit {  selectedValue = null;  displayCategoryName = null;  bookCaterory = [    {value: 'all', viewValue: '국내외도서'},    {value: 'country', viewValue: '국내도서'},    {value: 'foreign', viewValue: '국외도서'}  ];  searchTitle = null;  constructor() { }  ngOnInit() {  }  changeValue(category: string): void {    for(let element of this.bookCaterory ) {      if(element.value == category) {        this.displayCategoryName = element.viewValue;      }    }  }  changeTitleBar(searchInfo) : void {    this.searchTitle = `${searchInfo.keyword} ( ${searchInfo.category} )`;  }  @ViewChild(SearchBoxComponent) searchComp: SearchBoxComponent;  @ViewChildren(SearchBoxComponent) searchCompArr: QueryList&lt;SearchBoxComponent&gt;;  clearCondition(): void {    this.selectedValue = null;    this.searchTitle = null;/*    @ViewChild를 사용할 경우    this.searchComp._bookCategory = null;    this.searchComp.keyword = null;*/    // @ViewChildren을 사용할 경우    this.searchCompArr.toArray()[0]._bookCategory = null;    this.searchCompArr.toArray()[0].keyword = null;  }  @ViewChild('resultStatus') resultToolbar: ElementRef;  changeDOM(): void {    this.resultToolbar.nativeElement.onclick = function() {      alert('DOM을 직접 제어할 수 있어요!!');    };    this.resultToolbar.nativeElement.innerHTML = \"클릭해보세요!!\";  }}아래부분에 resultStatus Template Reference Variable을 이용해서 해당 Element의 Reference를 획득하는 부분을 잘 보시면됩니다. 이렇게 ElementRef type의 객체를 획득하면 nativeElement 속성으로 직접 제어할 수 있습니다.이번 포스트에서는 @ViewChild와 @ViewChildren을 이용해 자식 Component의 객체를 직접 제어하거나 rendering된 View의 DOM에직접 접근해서 제어하는 방법에 대해서 살펴보았습니다. 다음 포스트는 Angular에서 Content Projection이라고 불리는 부분에 대해서살펴보도록 하겠습니다.End.Angular 강좌는 아래의 책과 사이트를 참조했습니다.    조금 더 자세한 사항을 알고 싶으시면 해당 사이트를 방문하세요!!    Angular Official HomePage    Angular Material Official HomePage    Build a Mobile App with Angular 2 and Ionic 2    Angular 첫걸음 - 한빛미디어    제대로 배우는 Angular 4 - 비제이퍼블릭",
        "url": "/angular-lecture-data-share-3"
    }
    ,
    
    "angular-lecture-data-share-2": {
        "title": "Angular 강좌(10) - 데이터공유(@Output)",
            "author": "moon9342",
            "category": "",
            "content": "Angular 강좌는 여러 절로 구성되어 있습니다.     Angular 강좌(1) - Introduction    Angular 강좌(2) - 개발환경세팅    Angular 강좌(3) - Component    Angular 강좌(4) - Angular Material    Angular 강좌(5) - 실습(1)    Angular 강좌(6) - Data Binding    Angular 강좌(7) - 실습(2)    Angular 강좌(8) - Material Table    Angular 강좌(9) - 데이터공유(@Input)    Angular 강좌(10) - 데이터공유(@Output)    Angular 강좌(11) - 데이터공유(@ViewChild)    Angular 강좌(12) - 데이터공유(Content Projection)    Angular 강좌(13) - Service    Angular 강좌(14) - Service Mediator Pattern    Angular 강좌(15) - Service RxJS    Angular 강좌(16) - Material Table Event    Angular 강좌(17) - 중간 정리    Angular 강좌(18) - Directive    Angular 강좌(19) - Pipe    Angular 강좌(20) - Component Lifecycle@Output Decorator이번 포스트는 자식 Component에서 부모 Component로 데이터를 전달하기 위한 @Output decorator에 대해서 알아보겠습니다.자식 Component에서 부모 Component로 데이터를 전달하기 위해서는 EventEmitter를 이용한 이벤트 처리를 하셔야 합니다. 즉, 자식 Component에서 발생한 event를 부모 Component가 event bidning을 이용해 데이터를 받는 방식입니다.코드레벨에서 알아보죠. 이전에 @Input decorator를 설명하면서 사용했던 예제를 좀 수정해서 사용하겠습니다.아래는 search-box.component.ts 내용입니다.import { Component, OnInit,         Input, Output, EventEmitter } from '@angular/core';@Component({  selector: 'app-search-box',  templateUrl: './search-box.component.html',  styleUrls: ['./search-box.component.css']})export class SearchBoxComponent implements OnInit {  _bookCategory: string;  //@Input() bookCategory:string;  //@Input('bookCategory') mySelected:string;  @Input()  set bookCategory(value: string) {    if( value != null ) {      // 추가적인 작업이 들어올 수 있습니다.      this._bookCategory = 'category: ' +value;    } else {      this._bookCategory = value;    }  }  @Output() searchEvent = new EventEmitter();  keyword = null;  constructor() { }  ngOnInit() {  }  setKeyword(keyword: string): void {    this.keyword = keyword;    this.searchEvent.emit({      keyword : `${this.keyword}`,      category: `${this._bookCategory.replace('category: ','')}`    });  }  inputChange(): void {  }}부모 Component에게 이벤트를 전달하기 위해 다음의 코드로 EventEmitter 객체를 생성하고 @Output decorator를 이용했습니다.부모 Component는 searchEvent 이름으로 event binding 해야합니다.@Output() searchEvent = new EventEmitter();자식 Component에서 Search! 버튼을 눌렀을 때 setKeyword() method가 호출되는데 이 안에서 searchEvent에 대한 이벤트를발생시킵니다. 그러면서 부모 Component에게 전달할 데이터를 인자로 넣어줍니다.this.searchEvent.emit({    keyword : `${this.keyword}`,    category: `${this._bookCategory.replace('category: ','')}`});이제 부모 Component에서 어떻게 event binding을 이용해서 데이터를 받는지만 살펴보면 됩니다.아래는 book-search-main.component.html 입니다.&lt;div class=\"bookSearch-outer\"&gt;  &lt;div class=\"d-flex align-items-center p-3 my-3 text-white-50 bg-purple rounded box-shadow\"&gt;    &lt;img class=\"mr-3\" src=\"assets/images/search-icon.png\" alt=\"\" width=\"48\" height=\"48\"&gt;    &lt;div class=\"lh-100\"&gt;      &lt;h5 class=\"mb-0 text-white lh-100\"&gt;Search Result : {{searchTitle}}&lt;/h5&gt;    &lt;/div&gt;  &lt;/div&gt;  &lt;div class=\"example-container\"&gt;    &lt;mat-form-field&gt;      &lt;mat-select placeholder=\"도서종류\"                  #bookCategorySelect                  [(ngModel)]=\"selectedValue\"                  (ngModelChange)=\"changeValue(bookCategorySelect.value)\"&gt;        &lt;mat-option *ngFor=\"let category of bookCaterory\"                    [value]=\"category.value\"&gt;          {{ category.viewValue }}        &lt;/mat-option&gt;      &lt;/mat-select&gt;    &lt;/mat-form-field&gt;  &lt;/div&gt;  &lt;div&gt;    &lt;app-search-box [bookCategory]=\"displayCategoryName\"                    (searchEvent)=\"changeTitleBar($event)\"&gt;    &lt;/app-search-box&gt;  &lt;/div&gt;  &lt;div&gt;    &lt;app-detail-box&gt;&lt;/app-detail-box&gt;  &lt;/div&gt;  &lt;div&gt;    &lt;app-list-box&gt;&lt;/app-list-box&gt;  &lt;/div&gt;&lt;/div&gt;주의해서 보셔야 할 부분은&lt;app-search-box [bookCategory]=\"displayCategoryName\"                (searchEvent)=\"changeTitleBar($event)\"&gt;&lt;/app-search-box&gt;입니다. event binding을 이용해서 searchEvent 이벤트가 발생하면 changeTitleBar() method를 호출하고 인자를 받아서처리하고 있네요. 인자 받는 방식도 유의해서 보셔야 합니다.&lt;h5 class=\"mb-0 text-white lh-100\"&gt;Search Result : {{searchTitle}}&lt;/h5&gt;interpolation을 이용해 searchTitle 속성의 값을 View에 출력하고 있네요. 아마 changeTitleBar() method안에서 내용이결정될 듯 합니다.마지막으로 book-search-main.component.ts 파일입니다.import { Component, OnInit } from '@angular/core';@Component({  selector: 'app-book-search-main',  templateUrl: './book-search-main.component.html',  styleUrls: ['./book-search-main.component.css']})export class BookSearchMainComponent implements OnInit {  selectedValue = null;  displayCategoryName = null;  bookCaterory = [    {value: 'all', viewValue: '국내외도서'},    {value: 'country', viewValue: '국내도서'},    {value: 'foreign', viewValue: '국외도서'}  ];  searchTitle = null;  constructor() { }  ngOnInit() {  }  changeValue(category: string): void {      for(let element of this.bookCaterory ) {        if(element.value == category) {          this.displayCategoryName = element.viewValue;        }      }  }  changeTitleBar(searchInfo) : void {    this.searchTitle = `${searchInfo.keyword} ( ${searchInfo.category} )`;  }}기본적인 개념은 이미 설명했으니 코드레벨에서 한번 천천히 살펴보시면 충분히 이해할 수 있을 듯 보입니다.여기까지 작업한 내용을 실행해 정상적으로 동작하는지 확인하시면 될 듯 합니다.자식 Component에서 부모 Component로 Event를 이용해서 데이터를 어떻게 전달하는지에 대해서 간단하게 살펴보았습니다.다음 포스트는 부모 Component에서 자식 요소에 접근할 때 또 다른 방법으로 어떤 방법이 있는지 알아보도록 하겠습니다.End.Angular 강좌는 아래의 책과 사이트를 참조했습니다.    조금 더 자세한 사항을 알고 싶으시면 해당 사이트를 방문하세요!!    Angular Official HomePage    Angular Material Official HomePage    Build a Mobile App with Angular 2 and Ionic 2    Angular 첫걸음 - 한빛미디어    제대로 배우는 Angular 4 - 비제이퍼블릭",
        "url": "/angular-lecture-data-share-2"
    }
    ,
    
    "angular-lecture-data-share-1": {
        "title": "Angular 강좌(9) - 데이터공유(@Input)",
            "author": "moon9342",
            "category": "",
            "content": "Angular 강좌는 여러 절로 구성되어 있습니다.     Angular 강좌(1) - Introduction    Angular 강좌(2) - 개발환경세팅    Angular 강좌(3) - Component    Angular 강좌(4) - Angular Material    Angular 강좌(5) - 실습(1)    Angular 강좌(6) - Data Binding    Angular 강좌(7) - 실습(2)    Angular 강좌(8) - Material Table    Angular 강좌(9) - 데이터공유(@Input)    Angular 강좌(10) - 데이터공유(@Output)    Angular 강좌(11) - 데이터공유(@ViewChild)    Angular 강좌(12) - 데이터공유(Content Projection)    Angular 강좌(13) - Service    Angular 강좌(14) - Service Mediator Pattern    Angular 강좌(15) - Service RxJS    Angular 강좌(16) - Material Table Event    Angular 강좌(17) - 중간 정리    Angular 강좌(18) - Directive    Angular 강좌(19) - Pipe    Angular 강좌(20) - Component LifecycleComponent Data Sharing이번 포스트는 Component 간의 데이터 공유에 대해서 알아보고 그 내용을 기반으로 우리 mySearchProject의 도서검색 부분을완성해 나가도록 하겠습니다.최종적으로 완성된 프로그램은 이전에 비해 세가지 기능이 추가되었습니다.  도서 검색 시 도서 종류(국내도서, 국외도서, 국내외도서)에 대한 Filtering이 가능합니다.  키워드 입력 후 Search버튼을 클릭하면 해당 키워드에 대한 책만 list-box에 출력됩니다.  list-box에 출력된 책 중 하나를 선택하면 해당 책에 대한 세부내역을 detail-box에 출력합니다.이 기능들을 구현하려면 Component간의 데이터 공유 방법을 아셔야 합니다. Component간 데이터를 공유하는방법은 여러가지가 있는데 하나씩 살펴보면서 우리 코드에 적용해 보겠습니다.그럼 천천히 한번 살펴보기로 하죠.@Input Decorator이전에 View의 포함관계를 설명하면서 Component Tree에 대한 언급을 한 적이 있습니다. Component간의 부모-자식 관계가성립되면 서로간의 데이터 연결통로가 생성됩니다. 이를 통해 부모 Component와 자식 Component간의 데이터 공유가 이루어질 수 있습니다.먼저 부모 Component에서 자식 Component로 데이터를 전달하는 방법에 대해서 알아보죠.만약 부모 Component가 사용자 입력양식을 가지고 있다면 Client에 의해서 사용자 입력양식의 상태값이 변경될 수 있고 그 상태값를 자식 Component와 공유할 필요가 있습니다. 우리 예제로 설명하자면상위 Component인 book-search-main Component에서 Client가 설정한 도서 종류가 하위 Component인 search-box Component에 전해져야 제대로 된 검색을 수행할 수 있다는 말입니다.이런 경우 부모 Component는 property binding을 이용해 자식 Component에게 데이터를 전달해 줄 수 있습니다. 이렇게 전달된데이터는 @Input decorator에 의해서 자식 Component에서 사용될 수 있습니다.우리 예제를 수정해서 Client가 Select Box에서 선택한 도서 종류 정보가 하위 Component인 search-box Component와 공유되는지확인해 보겠습니다.book-search-main.component.html 파일의 내용을 다음과 같이 수정합니다.&lt;div class=\"bookSearch-outer\"&gt;  &lt;div class=\"d-flex align-items-center p-3 my-3 text-white-50 bg-purple rounded box-shadow\"&gt;    &lt;img class=\"mr-3\" src=\"assets/images/search-icon.png\" alt=\"\" width=\"48\" height=\"48\"&gt;    &lt;div class=\"lh-100\"&gt;      &lt;h5 class=\"mb-0 text-white lh-100\"&gt;Search Result&lt;/h5&gt;    &lt;/div&gt;  &lt;/div&gt;  &lt;div class=\"example-container\"&gt;    &lt;mat-form-field&gt;      &lt;mat-select placeholder=\"도서종류\"                  #bookCategorySelect                  [(ngModel)]=\"selectedValue\"                  (ngModelChange)=\"changeValue(bookCategorySelect.value)\"&gt;        &lt;mat-option *ngFor=\"let category of bookCaterory\"                    [value]=\"category.value\"&gt;          {{ category.viewValue }}        &lt;/mat-option&gt;      &lt;/mat-select&gt;    &lt;/mat-form-field&gt;  &lt;/div&gt;  &lt;div&gt;    &lt;app-search-box [bookCategory]=\"displayCategoryName\"&gt;&lt;/app-search-box&gt;  &lt;/div&gt;  &lt;div&gt;    &lt;app-detail-box&gt;&lt;/app-detail-box&gt;  &lt;/div&gt;  &lt;div&gt;    &lt;app-list-box&gt;&lt;/app-list-box&gt;  &lt;/div&gt;&lt;/div&gt;위의 코드에서 다음의 코드를 주의해서 보시면 됩니다.&lt;mat-select placeholder=\"도서종류\"            #bookCategorySelect            [(ngModel)]=\"selectedValue\"            (ngModelChange)=\"changeValue(bookCategorySelect.value)\"&gt;    &lt;mat-option *ngFor=\"let category of bookCaterory\"                [value]=\"category.value\"&gt;                {{ category.viewValue }}    &lt;/mat-option&gt;&lt;/mat-select&gt;이전에 배웠던 Tempalte Reference Variable과 양방향 바인딩을 이용해 Client가 도서 종류를 변경하면 changeValue() method가 호출됩니다.이 method는 book-search-main.component.ts안에 정의되어 있어야 하겠죠.import { Component, OnInit } from '@angular/core';@Component({  selector: 'app-book-search-main',  templateUrl: './book-search-main.component.html',  styleUrls: ['./book-search-main.component.css']})export class BookSearchMainComponent implements OnInit {  selectedValue = null;  displayCategoryName = null;  bookCaterory = [    {value: 'all', viewValue: '국내외도서'},    {value: 'country', viewValue: '국내도서'},    {value: 'foreign', viewValue: '국외도서'}  ];  constructor() { }  ngOnInit() {  }  changeValue(category: string): void {      for(let element of this.bookCaterory ) {        if(element.value == category) {          this.displayCategoryName = element.viewValue;        }      }  }}method의 하는일을 보니 Client가 선택한 도서 종류를 가지고 displayCategoryName이라는 속성의 값을 변경하고 있습니다.이 displayCategoryName 속성이 바로 자식 Component인 search-box Component에게 전달되는 데이터입니다.다시 위쪽의 book-search-main.component.html의 내용을 보면 아래와 같은 코드가 있습니다.&lt;div&gt;    &lt;app-search-box [bookCategory]=\"displayCategoryName\"&gt;&lt;/app-search-box&gt;&lt;/div&gt;search-box Component에 property binding을 이용해 bookCategory라는 이름으로 displayCategoryName 속성을 바인딩해 놓은걸 확인하실 수 있습니다.이제 search-box.component.ts의 내용을 보죠import { Component, OnInit, Input } from '@angular/core';@Component({  selector: 'app-search-box',  templateUrl: './search-box.component.html',  styleUrls: ['./search-box.component.css']})export class SearchBoxComponent implements OnInit {  @Input() bookCategory:string;  keyword = null;  constructor() { }  ngOnInit() {  }  setKeyword(keyword: string): void {    this.keyword = keyword;  }  inputChange(): void {  }}@Input decorator를 볼 수 있습니다. @Input decorator를 이용하기 위해서 import를 해 줘야 하는것도 잊지 마시구요.@Input() bookCategory:string;위의 코드처럼 bookCategory라는 이름으로 부모 Component가 property binding으로 전달해준 데이터를 받을 수 있습니다.이 속성을 View에 interpolation을 이용해서 출력하면 될 듯 합니다.다음은 View에 rendering되는 search-box.component.html 입니다.&lt;div class=\"example-container\"&gt;  &lt;mat-toolbar class=\"search-toolbar-style\"&gt;    Search Keyword : {{keyword}}    &lt;ng-container *ngIf=\"bookCategory != null\"&gt;      ( {{bookCategory}} )    &lt;/ng-container&gt;  &lt;/mat-toolbar&gt;  &lt;mat-form-field&gt;    &lt;input matInput #inputKeyword placeholder=\"Search Keyword\"           [(ngModel)]=\"keyword\" (ngModelChange)=\"inputChange()\"&gt;  &lt;/mat-form-field&gt;  &lt;button mat-raised-button color=\"warn\"          (click)=\"setKeyword(inputKeyword.value)\"&gt;Search!&lt;/button&gt;&lt;/div&gt;Toolbar부분에 {{keyword}}와 함께 {{bookCategory}}를 이용해서 속성과 binding시킨 걸 확인할 수 있습니다. 만약 bookCategory값이 null이면 출력되지 않게끔 built-in directive를 이용해 처리했습니다.위의 코드에서 보듯이 자식 Component인 select-box Component는 자신에게 데이터를 주는 부모 Component가 어떤 Component인지는 알 필요가 없습니다. 단지 전달된 데이터를 사용할 수 있도록 해주는 property의 이름과 data type만이 필요할 뿐이죠. Component간의 Loosely Coupling을 유지하면서 데이터를 공유할 수 있습니다.기본적인 @Input decorator를 사용하는 방법에 대해 설명했는데 몇개의 응용이 있습니다.우리는 부모 Component의 book-search-main.component.html에서 property binding을 이용해 bookCategory라는이름의 property를 사용했습니다. 이를 사용하기 위해서 자식 Component인 search-box Component에서 역시같은 이름으로 사용했구요. 만약 다른이름으로 사용하실려면 아래와 같이 처리하시면 됩니다.@Input('bookCategory') mySelected:string;bookCategory라는 이름의 property 대신 mySelected property를 사용할 수 있습니다. interpolation 역시 mySelected으로 사용해야겠죠.지금까지의 예는 모두 부모 Component가 전달해 준 데이터를 그대로 가져다 사용하는 방식입니다. 만약 부모 Component가 전달해 준 데이터를 가공해서 자식 Component에서 사용하려면 어떻게 해야 할까요?setter를 이용하면 이 작업을 할 수 있습니다. 우리의 코드가 이렇게 바뀌겠네요.import { Component, OnInit, Input } from '@angular/core';@Component({  selector: 'app-search-box',  templateUrl: './search-box.component.html',  styleUrls: ['./search-box.component.css']})export class SearchBoxComponent implements OnInit {  //@Input() bookCategory:string;  //@Input('bookCategory') mySelected:string;  _bookCategory: string;    @Input()  set bookCategory(value: string) {    if( value != null ) {      // 추가적인 작업이 들어올 수 있습니다.      this._bookCategory = 'category: ' +value;    } else {      this._bookCategory = value;    }  }  keyword = null;  constructor() { }  ngOnInit() {  }  setKeyword(keyword: string): void {    this.keyword = keyword;  }  inputChange(): void {  }}사용되는 setter의 이름과 부모 Component가 property binding하는 property의 이름이 같아야 합니다. interpolation은 _bookCategory으로 변경되어야 하겠네요.한가지 추가적으로 기억하셔야 할 점은 이렇게 부모 Component가 자식 Component에게 데이터를 전달해 줄 때 이 방식이call-by-value방식이 아닌 call-by-reference방식이라는 것입니다. 즉, 우리의 예제에서 부모 Component와 자식 Component가둘 다 bookCategory를 reference하고 있는 형태입니다. 이렇게 연결된 상태에서 부모 Component가 해당 property의 값을변경시키면 그 값을 자식 Component가 공유하고 있으므로 변경된 값을 그 즉시 사용할 수 있는 것이죠.이렇게 생각하면 자식 Component가 공유되고 있는 property의 값을 변경하면 그 변경 내용이 부모 Component에게 영향을미쳐야 합니다. 하지만 실제로 코드 작업을 해 보면 그렇지 않다는 것을 확인하실 수 있습니다. 왜 이런 현상이 발생할까요?만약 자식 Component에서 변경된 값이 부모 Component에게 영향을 주게끔 처리하면 나중에 이 공유데이터의 변화를 예측하기 힘들어지게 됩니다. 데이터의 변경을 tracking하기 힘들어진다는 것이죠. 지금은 간단한 경우이니 별 문제가 안되지만 프로그램이커지게 되면 이런 데이터의 공유 문제가 프로그램의 구현과 디버깅을 힘들게 하는 원인이 됩니다.Angular는 Stateful Component와 Stateless Component의 개념이 있습니다. Stateful Component는 다른말로 Smart Component라고도 하는데 이 Component는 데이터의 정보를 변경하거나 저장할 수 있습니다. 하지만 Dumb Component라고 불리는 Stateless Component는 단지 상태 정보를 참조만 해서 이용할 수 있습니다. 우리의 예제에서 상위 Component인 book-search-mainComponent는 Stateful Component입니다. 반면 자식 Component인 search-box Component는 Stateless Component이구요. 그렇기때문에 자식 Component에서 공유된 변수에 대한 변경을 해 주어도 상위 Component에 영향을 미치지 않게 되는 것입니다.조금 어려운 개념인데 이 Stateful과 Stateless에 대해 조금 더 알고싶으시면 여기를 참조하시면 됩니다.쉽게 말하자면 @Input decorator를 이용하면 부모 Component에서 자식 Component에게 데이터를 전달할 수 있지만 그 반대는 허용되지 않는군요. 이 문제를 해결하기 위해 @Output decorator를 사용할 수 있습니다. 즉, 자식 Component에서 변경된 사항을 부모 Component에게 전달하는 방법이 따로 있다는 것이죠. 다음 포스트에서는 @Output decorator에 대해서 알아보도록 하겠습니다.End.Angular 강좌는 아래의 책과 사이트를 참조했습니다.    조금 더 자세한 사항을 알고 싶으시면 해당 사이트를 방문하세요!!    Angular Official HomePage    Angular Material Official HomePage    Build a Mobile App with Angular 2 and Ionic 2    Angular 첫걸음 - 한빛미디어    제대로 배우는 Angular 4 - 비제이퍼블릭",
        "url": "/angular-lecture-data-share-1"
    }
    ,
    
    "angular-lecture-material-table": {
        "title": "Angular 강좌(8) - Material Table",
            "author": "moon9342",
            "category": "",
            "content": "Angular 강좌는 여러 절로 구성되어 있습니다.     Angular 강좌(1) - Introduction    Angular 강좌(2) - 개발환경세팅    Angular 강좌(3) - Component    Angular 강좌(4) - Angular Material    Angular 강좌(5) - 실습(1)    Angular 강좌(6) - Data Binding    Angular 강좌(7) - 실습(2)    Angular 강좌(8) - Material Table    Angular 강좌(9) - 데이터공유(@Input)    Angular 강좌(10) - 데이터공유(@Output)    Angular 강좌(11) - 데이터공유(@ViewChild)    Angular 강좌(12) - 데이터공유(Content Projection)    Angular 강좌(13) - Service    Angular 강좌(14) - Service Mediator Pattern    Angular 강좌(15) - Service RxJS    Angular 강좌(16) - Material Table Event    Angular 강좌(17) - 중간 정리    Angular 강좌(18) - Directive    Angular 강좌(19) - Pipe    Angular 강좌(20) - Component LifecycleMaterial Table Component이번 포스트에서는 이전에 만들었던 list-boxComponent가 표현하는 부분을 Material Table을 이용해서 작성해 보겠습니다. 기본적인 테이블 구성과 함께 Pagination까지 추가해서 간단하게 Paging까지 구현해보겠습니다.사실 설명할 부분이 많지는 않습니다. DataSource만 Table에 잘 연결하면 알아서 보여주기 때문이죠. 그게 또 Component 기반개발의 장점이기도 하구요.먼저 CSS부터 수정하도록 하겠습니다. 다음은 list-box.component.css 파일입니다..example-container {  display: flex;  flex-direction: column;  min-width: 300px;  margin-top: 30px;}.mat-table {  overflow: auto;  max-height: 500px;}.mat-header-cell.mat-sort-header-sorted {  color: black;}.list-table-style {  font-family: Georgia;}.list-header-style {  background-color: beige;}그 다음은 list-box.component.html 파일입니다.&lt;div class=\"example-container mat-elevation-z8\"&gt;  &lt;mat-table class=\"list-table-style\" #table [dataSource]=\"dataSource\"&gt;    &lt;ng-container matColumnDef=\"bisbn\"&gt;      &lt;mat-header-cell *matHeaderCellDef&gt; ISBN &lt;/mat-header-cell&gt;      &lt;mat-cell *matCellDef=\"let element\"&gt; {{element.bisbn}} &lt;/mat-cell&gt;    &lt;/ng-container&gt;    &lt;ng-container matColumnDef=\"btitle\"&gt;      &lt;mat-header-cell *matHeaderCellDef&gt; Title &lt;/mat-header-cell&gt;      &lt;mat-cell *matCellDef=\"let element\"&gt; {{element.btitle}} &lt;/mat-cell&gt;    &lt;/ng-container&gt;    &lt;ng-container matColumnDef=\"bauthor\"&gt;      &lt;mat-header-cell *matHeaderCellDef&gt; Author &lt;/mat-header-cell&gt;      &lt;mat-cell *matCellDef=\"let element\"&gt; {{element.bauthor}} &lt;/mat-cell&gt;    &lt;/ng-container&gt;    &lt;ng-container matColumnDef=\"bprice\"&gt;      &lt;mat-header-cell *matHeaderCellDef&gt; Price &lt;/mat-header-cell&gt;      &lt;mat-cell *matCellDef=\"let element\"&gt; {{element.bprice}} &lt;/mat-cell&gt;    &lt;/ng-container&gt;    &lt;mat-header-row class=\"list-header-style\"                     *matHeaderRowDef=\"displayedColumns\"&gt;                      &lt;/mat-header-row&gt;    &lt;mat-row *matRowDef=\"let row; columns: displayedColumns;\"&gt;&lt;/mat-row&gt;  &lt;/mat-table&gt;  &lt;mat-paginator #paginator                 [pageSize]=\"5\"                 [pageSizeOptions]=\"[5, 10, 20]\"                 showFirstLastButtons&gt;  &lt;/mat-paginator&gt;&lt;/div&gt;Table Component를 이용하기 때문에 book-search.module.ts에 관련된 Module을 import해 주어야 합니다.import { MatTableModule } from '@angular/material/table';그리고 Paging처리를 해야 하기 때문에 MatPaginatorModule 역시 import합니다.import { MatPaginatorModule } from '@angular/material/paginator';위의 HTML에서 가장 중요한 부분은 당연히 DataSource를 바인딩 하는 부분입니다.&lt;mat-table class=\"list-table-style\" #table [dataSource]=\"dataSource\"&gt;Property binding을 이용하여 Component에 있는 dataSource라는 속성과 연결시켰습니다. 이 dataSource라는 속성은도서정보에 대한 객체배열을 이용해서 만든 MatTableDataSource class의 객체입니다. JSON 데이터를 가져와서 만든객체입니다.마지막으로 list-box.compoennt.ts파일의 내용입니다.import { Component, OnInit } from '@angular/core';import { HttpClient } from \"@angular/common/http\";import { MatTableDataSource } from '@angular/material';import { MatPaginator } from '@angular/material';import { ViewChild } from '@angular/core';interface IBook {  bauthor: string;  bdate: string;  btranslator: string;  bpublisher: string;  btitle: string;  bprice: number;  bisbn: string;  bimgurl: string;}@Component({  selector: 'app-list-box',  templateUrl: './list-box.component.html',  styleUrls: ['./list-box.component.css']})export class ListBoxComponent {  displayedColumns = ['bisbn', 'btitle', 'bauthor', 'bprice'];  dataSource;  books: IBook[];  @ViewChild(MatPaginator) paginator: MatPaginator;  constructor(private http: HttpClient) {    this.http.get&lt;IBook[]&gt;('assets/data/book.json')      .subscribe(res =&gt; {        this.books = res;        this.dataSource = new MatTableDataSource&lt;IBook&gt;(this.books);        this.dataSource.paginator = this.paginator;      });  }}Code Review  원래 Code Review란 표현은 Code Inspection에서 기인한 용어로 코드를 실제로 실행하지 않고 사람이 검토하는 과정을 통해논리적인 잠재 오류를 찾아내고 이를 개선하는 작업을 지칭합니다.그런데 여기서는 그냥 위의 코드를 살펴보자는 의미로 사용했습니다. ^^;;코드를 좀 간단히 설명해보죠.먼저 Table을 생성하는 구문은 다음과 같습니다.&lt;mat-table [dataSource]=\"dataArray\"&gt;  ...&lt;/mat-table&gt;위의 코드에서 dataArray라고 되어있는 부분이 실제 Table에 rendering되는 데이터입니다. 배열형태로 되어 있고 배열안의각각의 객체를 row로 가져와서 화면에 출력하게 됩니다.다음은 Table의 컬럼을 표현하는 template입니다. 구문은 다음과 같습니다.&lt;ng-container matColumnDef=\"bisbn\"&gt;    &lt;mat-header-cell *matHeaderCellDef&gt; ISBN &lt;/mat-header-cell&gt;    &lt;mat-cell *matCellDef=\"let element\"&gt; {{element.bisbn}} &lt;/mat-cell&gt;&lt;/ng-container&gt;matColumnDef 속성은 사용할 컬럼의 이름입니다. 이 부분은 list-box.component.ts파일안에 컬럼명에 대한 배열이정의되는데 이 부분과 매칭되어야 합니다. 다음은 list-box.component.ts안에 정의된 컬럼명에 대한 배열입니다.displayedColumns = ['bisbn', 'btitle', 'bauthor', 'bprice'];그리고 아래의 구문에 의해 ISBN 컬럼의 제목과 내용이 출력됩니다. dataSource에 연결된 모든 row를 가져와서 element라는 변수에반복적으로 할당 하면서 element.bisbn값을 테이블에 출력하라는 말입니다.&lt;mat-header-cell *matHeaderCellDef&gt; ISBN &lt;/mat-header-cell&gt;&lt;mat-cell *matCellDef=\"let element\"&gt; {{element.bisbn}} &lt;/mat-cell&gt;이와 같은 형태로 하나의 컬럼에 대한 데이터를 화면에 출력할 수 있습니다. 우리는 총 4개의 컬럼을 화면에 출력하고 있는 것이죠.list-box.compoennt.ts에서는 사용할 데이터를 HttpClient의 get() method로 가져온 후 이를 다음의 코드를 이용해서 객체화 시켰습니다.this.dataSource = new MatTableDataSource&lt;IBook&gt;(this.books);dataSource와 연결시키기 위해 위에 있는 코드처럼 객체를 생성해서 연결하셔야 합니다.Paginator의 사용은 코드에 나온것처럼 사용하시면 됩니다. 내부적으로 처리되기 때문에 사용하는 방법만 아시면 충분합니다.TypeScript를 사용하기 때문에 interface를 이용하여 data type을 명확히 지정했습니다. 이 부분역시 이전 HTML Table Element로작업했을 때와는 다르게 처리하셔야 합니다.정리이제 1차적인 작업은 모두 끝났습니다. 논리적인 설명보다는 실제 사용할 화면을 만들면서 필요한 개념들에 대해서 그때 그때 설명하는 방식을 취했습니다. 이제 Component간의 상태공유에 대한 문제만 해결되면우리의 프로그램은 얼추 완성할 수 있을 듯 보입니다.조금만 더 진행시켜 일단 프로그램을 완성한 후 세부적인 내용들에 대해서 다시 짚어가며 살펴보도록 하겠습니다.End.Angular 강좌는 아래의 책과 사이트를 참조했습니다.    조금 더 자세한 사항을 알고 싶으시면 해당 사이트를 방문하세요!!    Angular Official HomePage    Angular Material Official HomePage    Build a Mobile App with Angular 2 and Ionic 2    Angular 첫걸음 - 한빛미디어    제대로 배우는 Angular 4 - 비제이퍼블릭",
        "url": "/angular-lecture-material-table"
    }
    ,
    
    "angular-lecture-exercise-2": {
        "title": "Angular 강좌(7) - 실습(2)",
            "author": "moon9342",
            "category": "",
            "content": "Angular 강좌는 여러 절로 구성되어 있습니다.     Angular 강좌(1) - Introduction    Angular 강좌(2) - 개발환경세팅    Angular 강좌(3) - Component    Angular 강좌(4) - Angular Material    Angular 강좌(5) - 실습(1)    Angular 강좌(6) - Data Binding    Angular 강좌(7) - 실습(2)    Angular 강좌(8) - Material Table    Angular 강좌(9) - 데이터공유(@Input)    Angular 강좌(10) - 데이터공유(@Output)    Angular 강좌(11) - 데이터공유(@ViewChild)    Angular 강좌(12) - 데이터공유(Content Projection)    Angular 강좌(13) - Service    Angular 강좌(14) - Service Mediator Pattern    Angular 강좌(15) - Service RxJS    Angular 강좌(16) - Material Table Event    Angular 강좌(17) - 중간 정리    Angular 강좌(18) - Directive    Angular 강좌(19) - Pipe    Angular 강좌(20) - Component Lifecyclelist-box Component View이번 포스트에서는 도서 정보를 리스트 형태로 출력하는 list-box Component를 구현해 보도록 하겠습니다.먼저 HTML Table Element를 이용하여 구현해보겠습니다. 사실 우리는 최종적으로 Angular Material Table Component를 이용할 것이기 때문에 HTML Table Element에 대한 CSS처리는 하지 않았습니다.여하간 만들어지는 list의 형태는 다음 그림과 같습니다.더 많은 책이 하단에 쭉 나열됩니다. 나중에는 book-search-main Component에서 만들어 놓은 Angular Material Select를 이용해 선택한 조건으로 책들에 대한 리스트가 출력되겠지만 지금은 그냥 조건없이 모든 책이 나열됩니다.기존에 작성했던 book-search-main.component.html 파일을 열어서 HTML Select Element를 이용한 부분을Material Select로 변경합니다.&lt;div class=\"bookSearch-outer\"&gt;  &lt;div class=\"d-flex align-items-center p-3 my-3 text-white-50 bg-purple rounded box-shadow\"&gt;    &lt;img class=\"mr-3\" src=\"assets/images/search-icon.png\" alt=\"\" width=\"48\" height=\"48\"&gt;    &lt;div class=\"lh-100\"&gt;      &lt;h5 class=\"mb-0 text-white lh-100\"&gt;Search Result&lt;/h5&gt;    &lt;/div&gt;  &lt;/div&gt;  &lt;div class=\"example-container\"&gt;    &lt;mat-form-field&gt;      &lt;mat-select placeholder=\"도서종류\"  [(ngModel)]=\"selectedValue\"&gt;        &lt;mat-option *ngFor=\"let category of bookCaterory\"                    [value]=\"category.value\"&gt;          {{ category.viewValue }}        &lt;/mat-option&gt;      &lt;/mat-select&gt;    &lt;/mat-form-field&gt;  &lt;/div&gt;    &lt;div&gt;    &lt;app-search-box&gt;&lt;/app-search-box&gt;  &lt;/div&gt;  &lt;div&gt;    &lt;app-detail-box&gt;&lt;/app-detail-box&gt;  &lt;/div&gt;  &lt;div&gt;    &lt;app-list-box&gt;&lt;/app-list-box&gt;  &lt;/div&gt;&lt;/div&gt;일단 Angular Material의 MatSelectModule을 사용하기 때문에 book-search.module.ts에 다음과 같이 import작업부터 해야코드에러가 나지 않을 듯 보입니다.import { MatSelectModule } from '@angular/material/select';mat-select가 Select box에 대한 Angular Material Component 입니다. 양방향 바인딩으로 selectedValue란 이름의 Component의 속성에바인딩 시켜놓은 상태입니다.mat-option은 Select box안의 각각의 Option Component입니다. 여러개가 존재할 수 있기 때문에 ngFor directive를 이용하여 반복처리 했습니다.Angular는 구조적 지시자(Structural Directive)라는걸 제공합니다. DOM 요소를 추가하거나 삭제 혹은 반복처리를 함으로 화면의구조를 변경할 때 사용합니다. 대표적으로는 ngIf와 ngFor가 있습니다. 이름에서 의미하다시피 ngIf는 boolean값을 입력받아true일 경우 ngIf 가 선언된 Element를 DOM에 추가합니다. 만약 false일 경우에는 ngIf 가 선언된 Element는 DOM에서 제거됩니다. ngFor 는 반복가능한 데이터를 입력받아 DOM에 반복해서 Element를 표현할 때 사용합니다.  Directive에 대해서는 나중에 다른 포스트에서 다시 설명하겠습니다. 여기서는 구조적 지시자로 ngIf와 ngFor를 사용해서 DOM을제어하는 방식에 대해서만 알아두시면 됩니다.코드를 보고 유추하건대 bookCaterory는 배열형태의 데이터이고 배열의 각 원소는 객체이겠네요. 데이터 바인딩에서 학습했던 내용과 연계해서 생각해 보시면 됩니다.그럼 아마도 book-search-main.component.ts에 다음과 같은 내용이 포함되어야 할 것입니다.import { Component, OnInit } from '@angular/core';@Component({  selector: 'app-book-search-main',  templateUrl: './book-search-main.component.html',  styleUrls: ['./book-search-main.component.css',  './offcanvas.css']})export class BookSearchMainComponent implements OnInit {  selectedValue = null;  bookCaterory = [    {value: 'all', viewValue: '국내외도서'},    {value: 'country', viewValue: '국내도서'},    {value: 'foreign', viewValue: '국외도서'}  ];    constructor() { }  ngOnInit() {  }}그 다음은 실제 리스트가 출력되는 list-box.component.css 파일의 내용입니다.위쪽 margin을 주기 위한 style을 정의해 놓았습니다..example-container {  margin-top: 20px;}다음은 list-box.component.html 파일의 내용입니다.&lt;table class=\"example-container\"&gt;  &lt;thead&gt;  &lt;th&gt;ISBN&lt;/th&gt;  &lt;th&gt;Title&lt;/th&gt;  &lt;th&gt;Author&lt;/th&gt;  &lt;th&gt;Price&lt;/th&gt;  &lt;/thead&gt;  &lt;tbody&gt;    &lt;tr *ngFor=\"let book of books\"&gt;      &lt;td&gt;{{book.bisbn}}&lt;/td&gt;      &lt;td&gt;{{book.btitle}}&lt;/td&gt;      &lt;td&gt;{{book.bauthor}}&lt;/td&gt;      &lt;td&gt;{{book.bprice}}&lt;/td&gt;    &lt;/tr&gt;  &lt;/tbody&gt;&lt;/table&gt;코드를 수행시키기 위해 먼저 book.json 파일을 하나 준비합니다. book.json 파일의 내용은 다음과 같이 작성하시면 됩니다.단, btranslator는 번역자를 의미합니다. 이 값이 존재하면 외국서적이라는 말이겠죠. 만약 국내도서면 이 값이 \"\"로 표현됩니다.다른 key값들에 대해서는 이름에서 그 의미를 충분히 유추할 수 있을 듯 합니다.[     {        \"bauthor\": \"카일 루든(Kyle Loudon)\",      \"bdate\":\"2000년 04월\",      \"btranslator\":\"허 욱\",      \"bpublisher\":\"한빛미디어(주)\",      \"btitle\":\"C로 구현한 알고리즘\",      \"bprice\":25000,      \"bisbn\":\"89-7914-063-0\",      \"bimgurl\":\"http://image.hanbit.co.kr/cover/_m_1063m.gif\"   },   {        \"bauthor\":\"권기경, 박용우\",      \"bdate\":\"2002년 09월\",      \"btranslator\":\"\",      \"bpublisher\":\"한빛미디어(주)\",      \"btitle\":\"IT EXPERT, 모바일 자바 프로그래밍\",      \"bprice\":23000,      \"bisbn\":\"89-7914-206-4\",      \"bimgurl\":\"http://image.hanbit.co.kr/cover/_m_1206m.gif\"   },   ...   ...   ...]   작성한 데이터 파일을 src/assets/data 폴더 아래에 저장합니다. 이 JSON data를 불러오기 위해 HttpClientModule를 이용합니다.더 쉽게 파일로 import해서 쓸 수 있지만 여기서는 HttpClientModule로 처리했습니다.book-search.module.ts 파일안에 HttpClientModule에 대한 import 구문을 작성합니다.import { HttpClientModule } from \"@angular/common/http\";아래는 list-box.component.ts 파일의 내용입니다.import { Component, OnInit } from '@angular/core';import { HttpClient } from \"@angular/common/http\";interface IBook {  bauthor: string;  bdate: string;  btranslator: string;  bpublisher: string;  btitle: string;  bprice: number;  bisbn: string;  bimgurl: string;}@Component({  selector: 'app-list-box',  templateUrl: './list-box.component.html',  styleUrls: ['./list-box.component.css']})export class ListBoxComponent implements OnInit {  books: IBook[];  constructor(private http: HttpClient) {    this.http.get&lt;IBook[]&gt;('assets/data/book.json')      .subscribe(res =&gt; this.books = res);  }  ngOnInit() {  }}약간 이상한 코드가 들어있는데 그 이유는 책의 정보를 가져오기 위해 HttpClient의 get() method를 호출하면서Arrow Function을 이용해 코드를 작성했기 때문입니다. 이 부분은 나중에 RxJS를 설명할 때 더 자세히 봐야 할 듯 하고지금은 book.json에 대한 HTTP연결로 JSON 데이터를 가져온다고 이해하시면 충분합니다.문제점도서정보에 대한 JSON을 작성해서 실행해보시면 아시겠지만 출력은 잘 됩니다.하지만 몇가지 문제가 있습니다.      책이 100권이 있으면 밑으로 쭉 나열되게 됩니다. Paging 처리를 해야 하는데 이것또한 쉬운작업은 아닙니다.        Event 처리하기가 쉽지 않습니다. 각 행을 클릭하면 해당 책의 세부정보를 detail-box Component를 이용하여 View에 출력해야 합니다. 클릭이벤트를 처리하기가 쉽지 않네요.        book-search-main.component.html에서 만들어놓은 Select Box의 선택 정보를 알아와서 그에 맞추어 책들을필터링 해야 하는데 어떤 도서를 선택했는지 현재로서는 알 방법이 없습니다.  이 외에도 Table Header를 클릭해서 리스트를 Sorting하는 것과 같은 일반적인 테이블이 가지는 기능을 우리가 추가로 구현해야되는 문제가 있습니다. 제대로 사용할려면 부가적인 작업이 훨씬 더 많이 들어가야 합니다.이와 같은 문제를 Material의 Table Component를 이용하면 쉽게 해결할 수 있습니다. 다음 포스트에서는 도서 리스트를 출력하는부분을 Material Table Component를 이용하여 다시 작성해 보겠습니다.End.Angular 강좌는 아래의 책과 사이트를 참조했습니다.    조금 더 자세한 사항을 알고 싶으시면 해당 사이트를 방문하세요!!    Angular Official HomePage    Angular Material Official HomePage    Build a Mobile App with Angular 2 and Ionic 2    Angular 첫걸음 - 한빛미디어    제대로 배우는 Angular 4 - 비제이퍼블릭",
        "url": "/angular-lecture-exercise-2"
    }
    ,
    
    "mysql-5-7-archive-setting": {
        "title": "MySQL 5.7.2 Windows용 ZIP Archive 설치",
            "author": "moon9342",
            "category": "",
            "content": "IntroductionMySQL을 install하지 않고 ZIP Archive를 다운받고 압축 풀어서 사용하는 사용하는 방식에 대한 설명입니다. 기존 5.6버전은 JSON에 대한 지원이 되지 않기 때문에 5.7버전을 대상으로 진행합니다. MySQL 5.7.2 ZIP Archive DownloadMySQL을 다운로드 받기 위해 링크를 눌러 이동합니다.아래의 그림처럼 다운로드 링크가 보이게 되는데 이 중 Windows (x86, 64-bit), ZIP Archive으로 되어있는 것을 찾아 다운로드 링크를 눌러 다운로드를 받습니다. 링크를 누르면 로그인하거나 회원가입하라는 화면이 나오는데 화면 하단에 보면그냥 다운로드 할 수 있는 링크가 있습니다.다운로드가 끝나면 적절한 위치에 압축을 풀어줍니다. 저는 D:/[Tools]/mysql 이라는 폴더로 압축된 내용을 풀었습니다. 해당 폴더 하단에 보면 기본적으로 다음과 같은 폴더와 파일들이 보이게 됩니다. MySQL System Database 생성ZIP Archive 버전은 MySQL을 기동하기 위한 System Database가 제공되지 않기 때문에 기본 System Database부터 생성해야 합니다.먼저 mysql 폴더 하단에 data라는 폴더를 생성합니다.그런 다음 관리자 권한으로 command 창을 열고 다음의 명령을 실행합니다. 명령을 실행시키는 폴더는 mysql하단의 bin folder에서 실행합니다.mysqld --initialize약간의 시간이 지나면 data 폴더 하단에 필요한 파일들이 생성됩니다. root 계정 패스워드 변경root계정의 패스워드를 변경하는 부분입니다. 꼭 필요한건 아니지만 현재 root계정은 패스워드 없이 바로 사용할 수 있기 때문에 보안상 설정하는게 좋습니다.다음과 같이 mysqld 명령을 이용해 MySQL 서버를 기동시킵니다.mysqld --console --explicit_defaults_for_timestamp --skip-grant-tables정상적으로 MySQL 서버가 기동되면 다음과 같은 화면을 보실 수 있습니다.이제 별도의 command창을 열고 다음의 명령을 입력해서 MySQL console에 진입합니다. 정상적으로 수행되면 mysql&gt; 프롬프트가떨어지게 됩니다.mysql -u root mysql이제 다음의 SQL문을 이용해서 root 계정의 패스워드를 갱신합니다. 패스워드를 root1234로 변경한다면 다음과 같이 하시면 됩니다.update USER set authentication_string=password('root1234') where user='root';변경이 정상적으로 수행되었으면 다음의 구문을 실행합니다.flush privileges;이제 마지막으로 다음과 같은 구문을 실행합니다.alter user 'root'@'localhost' identified by 'root1234', 'root'@'localhost' password expire never;이제 exit를 입력해 MySQL console을 빠져나옵니다. 그런다음 다음의 명령을 실행하면 root 계정의 패스워드를 입력하라고 합니다. 아까 설정한 root1234를 입력하면 MySQL console에 정상적으로 진입할 수 있습니다.mysql -u root -p MySQL 서버 중지현재 동작중인 MySQL 서버를 중지시킬려면 command 창에서 다음과 같은 명령을 실행시키시면 됩니다.mysqladmin -u root -p shutdown성공적으로 수행되면 실행되고 있던 MySQL 서버의 실행이 중지됩니다. 새로운 사용자 생성 및 권한 부여이전까지 정상적으로 수행되었다면 현재 MySQL 서버는 기동이 중지되어 있을겁니다.초기화 작업이 이미 진행되었기 때문에 이제 MySQL 서버를 기동시키기 위해서 다음과 같이 실행하시면 됩니다.mysqld새로운 사용자 계정을 생성하기 위해 새로운 command 창을 열어서 root계정으로 MySQL console에 진입합니다.mysql -u root -p새로운 사용자를 생성합니다. 아이디는 java, 패스워드 java로 설정해서 생성하도록 하겠습니다. 아래의 두 문장을 실행합니다.create user java identified by 'java';create user java@localhost identified by 'java';이제 데이터가 입력될 새로운 데이터베이스를 하나 생성 합니다. 다음의 명령을 이용해 library라는 이름의 데이터베이스를생성하겠습니다.create database library;새로 생성된 library database에 대한 모든 권한을 조금 전에 추가한 java 계정에게 부여하려면 다음과 같이 하시면 됩니다.grant all privileges on library.* to java;grant all privileges on library.* to java@localhost; SQL Script 파일을 이용해 Database 구축만일 기존에 사용하던 Database에 대한 SQL Script 파일을 가지고 있다면 해당 파일을 이용해 간단하게 데이터베이스를구축할 수 있습니다.command 창을 열어서 다음과 같은 명령어로 Script를 실행시켜 데이터베이스를 구축할 수 있습니다.mysql -u java -p library &lt; SQL_Script_File.sqlEnd.",
        "url": "/mysql-5.7-archive-setting"
    }
    ,
    
    "angular-lecture-databinding": {
        "title": "Angular 강좌(6) - Data Binding",
            "author": "moon9342",
            "category": "",
            "content": "Angular 강좌는 여러 절로 구성되어 있습니다.     Angular 강좌(1) - Introduction    Angular 강좌(2) - 개발환경세팅    Angular 강좌(3) - Component    Angular 강좌(4) - Angular Material    Angular 강좌(5) - 실습(1)    Angular 강좌(6) - Data Binding    Angular 강좌(7) - 실습(2)    Angular 강좌(8) - Material Table    Angular 강좌(9) - 데이터공유(@Input)    Angular 강좌(10) - 데이터공유(@Output)    Angular 강좌(11) - 데이터공유(@ViewChild)    Angular 강좌(12) - 데이터공유(Content Projection)    Angular 강좌(13) - Service    Angular 강좌(14) - Service Mediator Pattern    Angular 강좌(15) - Service RxJS    Angular 강좌(16) - Material Table Event    Angular 강좌(17) - 중간 정리    Angular 강좌(18) - Directive    Angular 강좌(19) - Pipe    Angular 강좌(20) - Component LifecycleData BindingAngular는 View와 Component에서 발생한 데이터의 변경 사항을 자동으로 일치시키는 기능을 제공하는데 이를 Data Binding( 데이터 바인딩 )이라고 합니다.Angular의 데이터 바인딩은 다음과 같이 크게 두가지 종류가 있습니다.      Two-Way Data Binding : 일반적으로 양방향 바인딩이라고 합니다. Component와 View의 상태 정보를 자동으로 일치시켜 주는 기능입니다.        One-Way Data Binding : 일반적으로 단방향 바인딩이라고 합니다. Component에서 View쪽으로 혹은 View에서 Component쪽으로 한 방향으로 데이터를 바인딩 해주는 기능입니다.  위와 같이 크게 두 가지 바인딩이 있지만 실제로 양방향 바인딩은 내부적으로 두개의 단방향 바인딩으로 구성됩니다. 기존 AngularJS는 다른 방식으로 양방향 바인딩을 제공했는데 성능상의 문제가 많아서 Angular에서는 이를 단방향 바인딩 2개를 이용해서 기존의양방향 바인딩처럼 이용할 수 있도록 제공해 주고 있습니다.단방향 바인딩은 다음과 같이 다시 세가지 방식으로 나누어 집니다 .  Interpolation : Component에서 선언한 속성을 View에서 사용하는 경우입니다. 다음의 형태를 이용합니다.{{ value }}  Property binding : View의 DOM이 소유한 HTML Element property를 []를 이용하여 binding하는 경우입니다. 다음의 형태로이용합니다.[property]=\"value\"   Event bidning : View의 DOM에 대한 Event handler로 Component의 method를 사용하는 경우입니다. 다음의 형태로 이용합니다.(event)=\"function\"위에서 간단하게 Data Binding의 종류와 형태를 살펴보았는데 이전 예제를 이용해서 각각을 코드로 살펴보겠습니다.Interpolation예제를 통해 interpolation의 사용법을 알아보겠습니다. 우리가 작성하고 있는 예제에서 search-box.component.html을 다음과 같이 수정합니다.&lt;div class=\"example-container\"&gt;  &lt;mat-toolbar class=\"search-toolbar-style\"&gt;Search Keyword : {{ keyword }}&lt;/mat-toolbar&gt;  &lt;mat-form-field&gt;    &lt;input matInput placeholder=\"Search Keyword\"&gt;  &lt;/mat-form-field&gt;  &lt;button mat-raised-button color=\"warn\"&gt;Search!&lt;/button&gt;&lt;/div&gt;위의 코드에서  {{ keyword }}  부분을 찾을 수 있는데 이 표현이 바로 interpolation이라고부르는 단방향 바인딩 입니다. keyword 라는 이름의 Component 속성을 찾아 그 값을 View에 표현하라는 것이지요.따라서 우리의 Component에는 keyword라는 이름의 속성이 존재해야 합니다.search-box.component.ts 파일을 열어 class안에 해당 속성을 추가합니다.import { Component, OnInit } from '@angular/core';@Component({  selector: 'app-search-box',  templateUrl: './search-box.component.html',  styleUrls: ['./search-box.component.css']})export class SearchBoxComponent implements OnInit {  keyword = 'java';    constructor() { }  ngOnInit() {  }}SearchBoxComponent class안의 keyword 속성에 있는 Java란 값이 View에 그대로 출력되게 됩니다. 실행시켜서 확인해보시면 될 듯 합니다.Event BindingEvent bidnging 역시 단방향 바인딩의 한 종류로 DOM의 Event Handler로 Component의 method를 활용할 수 있는방법입니다.search-box Component의 View에서 Search 버튼을 클릭하면 입력된 키워드가 위쪽 Toolbar 영역에 출력되도록 코드를 작성하면 다음과 같습니다.아래는 수정된 search-box.component.html입니다.&lt;div class=\"example-container\"&gt;  &lt;mat-toolbar class=\"search-toolbar-style\"&gt;Search Keyword : {{keyword}}&lt;/mat-toolbar&gt;  &lt;mat-form-field&gt;    &lt;input matInput #inputKeyword placeholder=\"Search Keyword\"&gt;  &lt;/mat-form-field&gt;  &lt;button mat-raised-button color=\"warn\"          (click)=\"setKeyword(inputKeyword.value)\"&gt;Search!&lt;/button&gt;&lt;/div&gt;위의 코드에서 #inputKeyword 라는 걸 보실 수 있을 텐데 Angular의 Template Reference Variable입니다.Template Reference Variable은 DOM의 HTML Element에 대한 참조 변수입니다. 쉽게 설명해서 HTML Element에변수를 하나 지정했다고 보시면 됩니다. 이렇게 참조 변수를 선언해 놓으면 template내의 JavaScript코드에서#기호를 제외한 변수이름으로 참조가 가능합니다.setKeyword(inputKeyword.value)에서 알 수 있듯이 Template Reference Variable inputKeyword를 # 기호없이사용해서 변수를 참조하고 있습니다. 입력상자이기 때문에 value속성을 이용해서 입력된 값을 알아내고 있는 거지요.한가지 주의해야 하는 것은 이런 Template Reference Variable은 HTML Template상에서만 사용할 수 있습니다. 물론 위의예와 같이 Event Binding을 이용해서 Component class로 전달할 수 있지만 기본적으로 Component class와는 별개로동작합니다.참고로 Agnular는 interpolation을 사용할 때 Safe Navigation Operator를 이용할 수 있습니다. ? 기호로 표현되며Component class의 속성값이 null이거나 undefiend일 경우 interpolation을 이용하면 오류가 발생할 여지가 있습니다.이때 ?를 이용하면 그런 오류를 만났을 때 처리를 종료하고 에러를 발생시키지 않게됩니다.예를 들자면  {{ book?.btitle }}  이런식으로 사용합니다. book이라는 객체가 null인 경우 문제가 생길 수 있죠. 이런 오류를방지할 때 사용됩니다.아래는 수정된 search-box.component.ts 입니다.import { Component, OnInit } from '@angular/core';@Component({  selector: 'app-search-box',  templateUrl: './search-box.component.html',  styleUrls: ['./search-box.component.css']})export class SearchBoxComponent implements OnInit {  keyword = 'Java';  constructor() { }  ngOnInit() {  }  setKeyword(keyword: string): void {    this.keyword = keyword;  }}위의 코드는 버튼을 클릭했을 때 Template Reference Variable을 이용하여 키워드 입력상자에서 사용자가입력한 검색 keyword 값을 가져와 Component의 method를 호출하여 Component 속성의값을 변화시킵니다. 이렇게 변경된 Component의 속성은 interpolation을 통해 다시 View에 출력되게 됩니다.Two-Way Data Binding이번에는 양방향 바인딩에 대해서 알아보겠습니다. 위에서 설명한 Search버튼은 입력된 키워드를 기반으로 실제 검색을 하기 위한 버튼이지 검색어를 위쪽 Toolbar 영역에 출력하기 위한 버튼은 아닙니다. 해서 키워드 입력상자( input ) 상자에 키워드를 입력할 때 사용자가 입력한 내용이 위쪽 Toolbar 영역에 출력되도록 처리해보겠습니다.양방향 바인딩을 사용하는 가장 쉬운 방법은 FormsModule이 제공하는 NgModel directive를 이용하는 것입니다. 따라서 먼저 FormsModule을 import하는 부분부터 처리해 주셔야 합니다. book-search.module.ts 파일에 FormsModule에 대한 import 처리를 합니다.// 양방향 바인딩을 위한 FormsModule importimport { FormsModule } from '@angular/forms';다음과 같이 바인딩할 요소의 속성에 [(ngModel)] 과 함께 바인딩할 대상을 선언하시면 됩니다. 다음은 수정된 search-box.component.html 입니다.&lt;div class=\"example-container\"&gt;  &lt;mat-toolbar class=\"search-toolbar-style\"&gt;Search Keyword : {{keyword}}&lt;/mat-toolbar&gt;  &lt;mat-form-field&gt;    &lt;input matInput #inputKeyword placeholder=\"Search Keyword\"           [(ngModel)]=\"keyword\"&gt;  &lt;/mat-form-field&gt;  &lt;button mat-raised-button color=\"warn\"          (click)=\"setKeyword(inputKeyword.value)\"&gt;Search!&lt;/button&gt;&lt;/div&gt;실행을 시켜보시면 키워드 입력상자에 글자를 입력할 때 상단의 키워드 표시영역에 같이 출력되는 것을 보실 수 있습니다. 이렇게 양방향바인딩이 설정되어 있을 때 사용자가 글자를 입력하면 NgModel로 바인딩한 값이 변경이 됩니다. 이 때 이벤트가 하나 발생하는데이 이벤트를 처리하기 위해 ngModelChange를 이용할 수 있습니다.위의 코드를 약간 수정해 다음과 같이 작성해보죠.&lt;div class=\"example-container\"&gt;  &lt;mat-toolbar class=\"search-toolbar-style\"&gt;Search Keyword : {{keyword}}&lt;/mat-toolbar&gt;  &lt;mat-form-field&gt;    &lt;input matInput #inputKeyword placeholder=\"Search Keyword\"           [(ngModel)]=\"keyword\" (ngModelChange)=\"inputChange()\"&gt;  &lt;/mat-form-field&gt;  &lt;button mat-raised-button color=\"warn\"          (click)=\"setKeyword(inputKeyword.value)\"&gt;Search!&lt;/button&gt;&lt;/div&gt;  (ngModelChange)에 바인딩 된 inputChange()는 search-box.component.ts 안에 class의 method로 정의되어 있어야 합니다.데이터가 변경될 때 자동적으로 이벤트가 발생되고 바인딩된 method를 통해 특정 로직을 수행할 수 있습니다.영문일 경우는 문제없이 잘 수행되지만 한글일 경우는 약간의 문제가 있습니다. 바로바로 화면에 적용되지 않는 것이죠. 양방향 바인딩은기본적으로 문자 입력이 완료된 시점에 compositionend라는 browser 이벤트가 발생하고 이에 따라 바인딩을 처리합니다. 하지만영문과 다르게 한글은 조합형 문자이기 때문에 글자가 다 만들어 지기 전까지는 해당 이벤트가 발생하지 않고 따라서 화면에 출력되지않게 되는 것입니다.이 문제를 해결하기 위해서는 Angular에서 제공하는 COMPOSITION_BUFFER_MODE 설정을 변경하시면 됩니다. 설정하는 방법은 아래의코드를 참조하시면 됩니다.아래는 book-search.module.ts 파일 입니다.import { NgModule } from '@angular/core';import { CommonModule } from '@angular/common';import { BookSearchMainComponent } from './book-search-main/book-search-main.component';import { SearchBoxComponent } from './search-box/search-box.component';import { ListBoxComponent } from './list-box/list-box.component';import { DetailBoxComponent } from './detail-box/detail-box.component';import { MatFormFieldModule } from '@angular/material/form-field';import { MatInputModule } from '@angular/material';import { MatButtonModule } from '@angular/material/button';import { MatToolbarModule } from '@angular/material/toolbar';import { MatCardModule } from '@angular/material/card';// 양방향 바인딩을 위한 FormsModule importimport { FormsModule } from '@angular/forms';// COMPOSITION_BUFFER_MODE importimport { COMPOSITION_BUFFER_MODE } from '@angular/forms';@NgModule({  imports: [    CommonModule,    MatFormFieldModule,    MatInputModule,    MatButtonModule,    MatToolbarModule,    MatCardModule,    FormsModule  ],  providers: [    {      provide: COMPOSITION_BUFFER_MODE,      useValue: false    }  ],  declarations: [BookSearchMainComponent,                  SearchBoxComponent,                  ListBoxComponent,                  DetailBoxComponent]})export class BookSearchModule { }Property BindingProperty binding을 이용하면 DOM 상의 HTML Element에 대한 property를 Component의 속성과 바인딩 할 수 있습니다. 주의하실 점이 하나 있는데 property binding은 HTML Element의 Attribute에 값을 binding하는 것이 아니라 HTML이 browser에 의해 parsing되면메모리에 DOM이 생성되는데 이 DOM의 HTML ELement에 대한 property에 값이 binding된다는 것입니다.이번에는 detail-box Component를 이용해서 한번 알아보죠.일단 완성된 화면은 다음과 같습니다.제목, 저자, ISBN, 가격, 출판일, 이미지 정보는 interpolation을 이용해 출력하고 property binding을이용하여 만약 책의 가격이 20000을 초과하면 구입버튼을 disabled 시키게 처리했습니다.detail-box-component.css에서 사용된 CSS는 다음과 같습니다..example-card {  width: 500px;  margin: 0 auto;}.example-header-image {  background-image: url('/assets/images/book-icon.jpg');  background-size: cover;}.book-image {  width: 100px !important;}.detail-header-style {  font-family: Georgia;}아래는 detail-box.component.html 입니다.&lt;mat-card class=\"example-card\"&gt;  &lt;mat-card-header class=\"detail-header-style\"&gt;    &lt;div mat-card-avatar class=\"example-header-image\"&gt;&lt;/div&gt;    &lt;mat-card-title&gt;제목 : {{book.btitle}}&lt;/mat-card-title&gt;    &lt;mat-card-subtitle&gt;저자 : {{book.bauthor}}&lt;/mat-card-subtitle&gt;  &lt;/mat-card-header&gt;  &lt;img mat-card-image class=\"book-image\" src=\"{{book.bimgurl}}\"&gt;  &lt;mat-card-content&gt;    &lt;p&gt;      ISBN : {{book.bisbn}}, 도서 가격 : {{book.bprice }}, 출판일 : {{book.bdate}}    &lt;/p&gt;  &lt;/mat-card-content&gt;  &lt;mat-card-actions&gt;    &lt;button mat-button            mat-raised-button color=\"primary\"            [disabled]=\"book.bprice &gt; 20000\"&gt;바로 구입&lt;/button&gt;  &lt;/mat-card-actions&gt;&lt;/mat-card&gt;book 객체의 속성으로 바인딩 시켰습니다. 당연히 detail-box.component.ts 안에 class 속성으로 book 객체가 정의되어 있겠네요.주의해서 보셔야 할 부분은&lt;button mat-button        mat-raised-button color=\"primary\"        [disabled]=\"book.bprice &gt; 20000\"&gt;바로 구입&lt;/button&gt;부분입니다. disabled 라는 속성에 property binding을 이용해 조건을 걸었습니다. 현재 책 값이 20000원을 초과하면 “바로 구입”버튼을비활성화 시키는 것이죠. 사용하는 법을 잘 기억해 두시면 될 듯 합니다.다음은 데이터가 들어있는 detail-box.component.ts 입니다.import { Component, OnInit } from '@angular/core';@Component({  selector: 'app-detail-box',  templateUrl: './detail-box.component.html',  styleUrls: ['./detail-box.component.css']})export class DetailBoxComponent implements OnInit {  book = {    btitle: 'Head First Design Patterns: 스토리가 있는 패턴 학습법',    bauthor: '에릭 프리먼외 3명',    bprice: 28000,    bdate: '2005년 08월',    bisbn: '89-7914-340-0',    bimgurl: 'http://image.hanbit.co.kr/cover/_m_1340m.gif'  };  constructor() { }  ngOnInit() {  }}이번 포스트에서는 Angular의 Data Binding에 대해서 살펴보았습니다. 다음 포스트는 지금까지 배운 내용과 Directive에 대한 내용을 섞어 약간 복잡하지만 책의 리스트를 출력하는 list-box Component와 연결된 View를 살펴보도록 하겠습니다. 먼저 기본적인 HTML Table Element을 이용해 보고 그 다음에 Angular Material Table Component을 이용해 리스트를 출력해보도록 하겠습니다.End.Angular 강좌는 아래의 책과 사이트를 참조했습니다.    조금 더 자세한 사항을 알고 싶으시면 해당 사이트를 방문하세요!!    Angular Official HomePage    Angular Material Official HomePage    Build a Mobile App with Angular 2 and Ionic 2    Angular 첫걸음 - 한빛미디어    제대로 배우는 Angular 4 - 비제이퍼블릭",
        "url": "/angular-lecture-databinding"
    }
    ,
    
    "git-github": {
        "title": "Git과 GitHub의 간단 사용법",
            "author": "moon9342",
            "category": "",
            "content": "IntroductionGit과 GitHub에 대한 간단한 설명입니다. 간단한 이론과 함께 실습을 통해 command 기반의 명령어로 어떤일을 처리할 수 있는지를 알아보도록 하겠습니다. 누구나 한번쯤은 겪었던 일위의 그림은 누구나 한번쯤 겪어봤을 만한 상황입니다. 파일을 계속 수정해 나가면서 이름을 바꾸어 저장하는 경우입니다.그 당시야 최종 파일이 어떤것인지 알 수 있겠지만 시간이 흐르면 당연히 저 중 어떤 파일이 최종 Report파일인지 알 수없게 됩니다.아래의 그림은 조금 다른 경우입니다.( 이미지 출처 : http://slidedeck.io/cursor-education )여러명이 공동으로 같은 파일을 작업할 때 파일 내용을 덮어쓰는 문제가 생길 수 있습니다. 다른 사람이 작업한 사항을유실할 수 있다는 것이죠.이와 같은 문제가 항시 빈번하게 발생하게되고 이를 해결하기 위해 나온 시스템이 바로 VCS( Version Control System )입니다. Version Control System ( VCS )VCS 는 파일의 변화를 시간에 따라 기록했다가 나중에 특정 시점의 버전을 다시 꺼내올 수 있는 시스템을 의미합니다. 이런 VCS는다음과 같은 특징을 가지고 있습니다.  각 파일을 이전 상태로 되돌릴 수 있습니다.  시간에 따라 수정 내용을 비교해 볼 수 있습니다.  누가 문제를 일으켰는지 쉽게 추적할 수 있습니다.  파일을 잘못 고쳤을 때 쉽게 복구할 수 있습니다. Centralized Version Control System ( CVCS )CVCS는 중앙집중식 버전 관리 시스템입니다. 우리가 예전에 사용했던 CVS나 Subversion같은 제품이 이 범주에 들어갑니다.파일을 관리하는 서버가 별도록 존재하고 클라이언트는 중앙 서버에서 파일을 받아서 사용하는 개념입니다. 그림으로표현하면 다음과 같습니다.( 이미지 출처 : https://git-scm.com/ )여기서 Checkout이라는 용어가 나오는데 나중에 우리가 살펴볼 Git의 Checkout과는 다른 개념임에 유의하셔야 합니다.이런 CVCS는 중앙서버에 문제가 발생하면 다른 사람과의 협업 자체가 불가능해지게 됩니다. 또한 중앙서버의 하드디스크에문제가 발생하면 프로젝트의 모든 History를 잃어버리게 됩니다.Backup서버를 운영하면 이런 문제점을 일시 해결할 순 있지만 본질적인 문제는 남아있게 됩니다. ( 백업서버까지 날라간다면??? )이런 문제점을 해결하기 위해 분산형 VCS가 등장하게 됩니다. Distributed Version Control System ( DVCS )DVCS는 분산 버전 관리 시스템입니다. 우리가 알고 있는 Git이 대표적 제품입니다. 이 외에 다른 제품들도 있지만Git만 알아도 됩니다.이 방식은 CVCS처럼 클라이언트가 파일의 마지막 Snapshot을 Checkout하는 방식이 아닙니다. 클라이언트는 서버 저장소를통째로 로컬에 복제해서 사용합니다. 즉, 그림으로 보면 다음과 같습니다.( 이미지 출처 : https://git-scm.com/ ) Git의 탄생Linux kernel은 대규모의 open source project입니다. 이 project의 버전관리를 위해 초기에는BitKeeper라는 상용 DVCS를 사용했었는데 2005년도에 이 BitKeeper의 무료사용이 제고되면서 리누스 토발즈의 주도로Linux 개발 커뮤니티가 자체 VCS를 개발했는데 이게 바로 Git입니다.Git은 다음과 같은 특징을 가집니다.  단순한 구조에서 오는 빠른 속도  완벽한 분산처리  branch를 사용한 비선형적 개발 가능  속도나 크기면에서 대형 Project에 적합Git의 데이터 저장 방식은 이 포스트의 범주를 넘어가니 그 부분은 제외하겠습니다. 실제 Git이 어떤 방식으로 데이터를 저장하는가에대한 내용은 여기를 클릭해 살펴보시면 될 듯 합니다. Git의 기본Git은 파일을 3가지 상태로 관리합니다. Committed, Modified, Staged라고 불리는 3가지 상태로 파일을 관리하게 되는데각각의 의미는 다음과 같습니다.  Git의 파일 상태      Committed : 파일을 수정한 후 해당 파일에 대해 commit명령을 실행해 파일을 로컬 데이터베이스(로컬 Repository)에 안전하게 저장한 상태를 의미합니다.    Modified : 파일을 수정한 후 아직 로컬 데이터베이스에 commit하지 않은 상태를 의미합니다.    Staged : 파일을 수정한 후 수정할 파일을 곧 commit할 것이라고 표시한 상태를 의미합니다.  Git은 파일상태 관리와 더불어 3가지 영역을 사용합니다.  Git의 사용 영역      Git directory : Git이 project의 메타데이터와 객체 데이터베이스를 저장하는 곳을 의미합니다.다른말로 Local Repository라고 하며 만약 특정 폴더를 Git directory(Local Repository)로 설정하려면 git init명령을이용하면 됩니다. Repository로 설정되면 .git이라는 숨김폴더가 생성되고 이 안에 Git 관리 정보들이 생성되게 됩니다.    Working directory : project의 특정 branch를 checkout한 내용이 들어있는 폴더입니다.    Staging Area : Git directory에 존재하며 단순한 파일입니다. 곧 commit할 파일에 대한 정보를 가지고 있게 됩니다.   Git으로 하는 작업의 기본 순서작업의 기본순서는 다음과 같습니다.  Working directory에서 파일 수정  Staging Area에 수정한 파일을 Stage해서 commit할 Snapshot 생성 ( git add )  Staging Area에 있는 수정된 파일을 commit해서 Git directory에 영구적인 Snapshot으로 저장 ( git commit )( 이미지 출처 : https://git-scm.com/ )( 이미지 출처 : http://egloos.zum.com/incredible/v/7278471 ) Git 설치 &amp; 기본 설정http://git-scm.com를 클릭해서 Git Official HomePage로 이동해서 Git을다운로드 한 후 기본설정으로 install하시면 됩니다.Git을 설치하신 후 git config를 이용해 기본적인 환경설정을 하시면 됩니다. 설정파일은 크게 3가지 종류가 존재하는데 다음과 같습니다.  Git의 환경설정파일( Windows system 기준 )      $GIT_HOME/mingw64/etc/gitconfig : 시스템의 모든 사용자와 모든 저장소에 적용되는 설정으로git config --system으로 설정합니다.    $USER_HOME/.gitconfig : 특정 사용자에게만 적용되는 설정입니다. git config --global으로 설정합니다.    .git/config : Git directory안에 위치하며 특정 저장소에만 적용되는 설정입니다.  각각의 설정파일은 위에 나열된 순서의 역순으로 적용된다는 것도 같이 기억해 두셔야 합니다.Windows system에서 Git을 설치하면 Git Bash 메뉴가 생성되는데 이를 실행해 console을 실행시킨 후 사용자 이름과Email주소를 설정하시면 됩니다.  참고로 MINGW64는 Windows system으로 porting한 GNU 소프트웨어 도구 모음입니다. Git Local Repository 생성그럼 Git을 이용해 Git Repository를 만들어서 사용해 보도록 하겠습니다. 가지고 있는 project가 없기 때문에 간단하게폴더를 하나 생성하고 그 폴더를 project 폴더로 간주하고 진행하겠습니다.Git의 기본 명령과 개념을 이해하는 목적이기 때문에 command 창에서 명령어를 이용해서 작업을 진행하겠습니다.추후에 실제 project에 적용하실 때는 IDE의 기능을 이용하거나 SourceTree와같은 GUI툴을 이용하시는게 좋습니다.다음과 같은 순서로 진행합니다.  윈도우 탐색기를 이용해 먼저 프로젝트 폴더를 생성합니다. D:/MyProject로 생성합니다. 나중에 Git으로 관리할파일을 하나 생성합니다. 다음과 같은 내용을 가지고 있는 파일을 생성하고 파일 이름은 readme.txt로 저장합니다.    This is a sample text.        project 폴더로 이동해 console을 통해 git init을 실행해 Git Repository를 생성합니다. 다음과 같은 메시지가 출력되는걸확인하실 수 있습니다.    Initialized empty Git repository in D:/MyProject/.git/            메시지에서 나온것 처럼 .git 폴더가 생성되고 그 안에 Git Repository가 생성됩니다. 또한 Repository에필요한 각종 Skeleton들도 같이 생성됩니다.        이 상태에서 git status를 실행합니다. 그러면 Git이 아직 추적하고 있지 않은 readme.txt가 존재한다고 알려줍니다.        Git Repository를 생성했지만 아직 어떠한 파일도 관리를 하고 있지 않습니다. 이제 Git이 파일을 관리하게하려면 Repository에 git add를 이용해 파일을 추가하고 git commit을 이용해 commit까지 진행해야 합니다.다음의 그림처럼 명령을 이용하여 Repository에 파일 추가, 확인, commit까지 진행합니다. ( -m option은 commit message를 작성하기 위해서사용합니다. )    이제 마지막으로 readme.txt 파일의 내용을 에디터를 이용해 적당히 수정한 후에 다시 git status를 실행시켜 보시면 됩니다. 그럼 Git은 해당 파일이 변경(Modified)됬다는 것을 인식해서 보여주게 됩니다. 변경된 내용을 적용해 Repository에 저장하려면 다시 git add를 이용해 해당 파일을 staging 한 후 git commit을 실행해야 합니다. Branch 생성그 다음에 알아볼 내용은 branch 입니다. branch는 기본 project에 영향이 가지 않는 상태에서 새로운 기능을 추가하거나기존 기능을 변경해야 하는 경우에 유용하게 사용할 수 있습니다. 필요에 의해 만들어지는 이런 각각의 branch들은 서로간의 영향을 받지 않습니다. 그렇기 때문에 여러 작업을 동시에 진행시킬 수 있습니다.( 이미지 출처 : https://rogerdudler.github.io/git-guide/index.ko.html )Repository를 처음 생성하게 되면 Git는 master라는 이름의 branch를 만들어 줍니다. 위에서 우리가 readme.txt 파일을Repository에 추가하고 내용을 변경해서 commit까지 진행했었는데 모두 이 master라는 branch에서 처리했던 겁니다.master가 아닌 다른 branch를 생성할 수 있습니다. 또한 “이제부터의 작업은 xxx branch에서 진행할꺼야!” 라는 식으로명령을 줄 수 있는데 이걸 checkout이라고 합니다. 즉, checkout은 특정 branch의 내용을 가져와서 Working directory를 설정하는 작업이라고 보시면 됩니다. 특정 branch에서 일어나지 않는 모든 작업은 당연히 master branch에서 일어나게 됩니다.현재 어떤 branch가 존재하는지 알아볼려면 git branch 명령을 이용하시면 됩니다. 만약 새로운 branch를 생성하고 싶으면 git branch branch_name형태로 branch이름을 명시하시면 새로운 branch가 생성됩니다.현재 작업중인 branch는 * 기호로 표시됩니다. 아래 그림은 새로운 branch를 생성하고 git checkout 명령을 이용하여 hotfixbranch를 Working directory에 가져온 것입니다. 지금부터 하는 작업은 모두 hotfix branch에서 발생하는 것이고 master branch와는무관하게 동작합니다.실제로 파일을 변경하거나 추가해서 hotfix branch에서 작업한 후 다시 master branch를 checkout해보시면 아까 했던 작업이 masterbranch에는 영향을 미치지 않는다는 것을 확인하실 수 있습니다. 이 부분은 개별적으로 실습해 보시길 바랍니다.참고로 모든 branch를 확인하기 위해서는 다음의 명령을 실행하시면 됩니다.  git branch -a Branch MergeMerge 작업은 현재 작업중인 branch에 다른 branch를 가져와서 병합하는 작업을 의미합니다. git merge branch_name을 이용하여현재 branch에 명시된 이름의 branch를 가져와 파일을 병합하게 됩니다.만약 두개의 branch에서 같은 파일의 같은 곳을 수정했을 경우 해당 파일을 병합할 때 당연히 문제가 발생하게 됩니다. 그냥 합쳐질 수가없기 때문이지요. conflict가 발생했다고 표현합니다. 이런 경우 충돌이 일어난 내용을 살펴보고 수동으로 해결해야 합니다.  Git은 병합이 실패했을 때 그 해결을 모두 사용자에게 일임합니다.그래서 수동으로 파일을 수정한 후 다시 commit작업을 진행해야 합니다. merge 작업은 Remote Repository 를 설명하는 부분에서 다시 한번 다뤄보기로 하겠습니다. .gitignore 파일project 폴더 안에서 굳이 추적할 필요가 없는 파일들도 존재합니다. 입출력 데이터파일이나 로그파일, 혹은 .class와 같은 파일들은굳이 Git을 이용해서 관리할 필요가 없습니다. 즉, 임시로 사용되거나 결과물로 생성되는 파일들이 이 범주에 들어갑니다.이런경우 .gitignore 파일을 이용해 추적 관리할 필요가 없는 파일을 배제시킬 수 있습니다. 그냥 만들어도 되지만 여기로 이동해 보시면 조금 쉽게 .gitignore 파일의 내용을 만들어 복사해서 사용하실 수 있습니다. Remote RepositoryGit은 혼자 사용할 수 도 있지만 기본적으로 다른 사람과 협업을 하기 위한 도구입니다. 협업 도구로서 Git의 가장 큰 유용함은 Remote Repository(원격 저장소)에 있습니다.이 Remote Repository는 우리가 따로 구축해서 사용할 수 있습니다. 또한 이런 Remote Repository를 서비스하는 회사도 굉장히 많이 있습니다. Git 기반의 Remote Repository 중 가장 대표적인 것이 바로 GitHub입니다.Remote Repository를 쉽게 생각하자면 로컬에서 작업한 Git Local Repository가 외부에 있는거라고 생각하시면 됩니다. GitHub는이런 Remote Repository를 전세계적으로 서비스하고 있고 굉장히 많은 사람들이 GitHub를 자신들이 수행하고 있는 project의 Remote Repository로 이용하고 있습니다.GitHub에 있는 이런 Remote Repository는 크게 public repository와 private repository로 구분됩니다. 말 그대로 public repository는 아무나 파일들을 열람할 수 있도록 공개되어 있는 repository이고private repository는 권한을 가진 사람들만 사용할 수 있는 repository입니다.GitHub는 Fork와 Pull Request라는 기능을 제공하고 있습니다. 정확히 말하자면 이 Fork와 Pull Request는 Git이 제공하는 것이아니라 GitHub가 제공하는 서비스 입니다.      Fork : 다른 사람의 Repository를 통째로 내 GitHub 계정으로 복사해 오는 기능입니다. 즉, GitHub 계정간 Repository를 서로복사해 갈 수 있는 기능이라고 보시면 됩니다.        Pull Request : 다른 사람의 Repository를 Fork한 후 그 내용을 수정한 다음 원본 Repository에 수정된 내용을 보내 병합을요청할 수 있는데 이 작업을 Pull Request라고 합니다. 아무나 Repository를 수정할 수 있는 권한을 주게 되면 Repository는 금방엉망이 될 테니 READ기능(Fork)만 제공하고 병합시에는 요청을 받아서 처리하도록 합니다.   GitHub에 Remote Repository 생성그럼 이제 GitHub에 계정을 생성하고 Remote Repository를 생성해 사용하는 방법에 대해서 알아보겠습니다.GitHub에 계정을 생성하고 새로운 Repository를 생성하는 버튼을 클릭하면 다음과 같은 화면을 보실 수 있습니다. Repository이름을 입력하고 간단한 설명을 입력합니다. Repository의 종류를 선택할 수 있는데 private은 비용을 지불해야 사용할 수 있습니다. 우리는 아까 만들어 놓은 Local Repository와 연결시키는 목적으로 사용할 것이기 때문에 README 파일을 만들지 않고Repository를 생성합니다.Repostiroy를 생성하면 다음과 같은 화면을 보실 수 있습니다. Repository에 현재 파일이 존재하지 않기 때문에이렇게 나오는 것이고 만약 특정 파일들이 저장되어 있으면 파일의 목록들이 보여지게 됩니다. Remote Repository 관리 명령어GitHub에 생성한 Remote Repository를 관리하기 위해서 Git은 몇몇개의 명령어를 제공합니다.  git clone : Remote Repository의 모든 내용을 Local Repository로 복사합니다.  git remote : Local Repository를 특정 Remote Repository와 연결시킬 때 사용합니다.  git push : Local Repository에 추가된 파일이나 변경 사항을 연결된 Remote Repository에 저장하기 위해서 사용합니다.  get fetch : Remote Repository와 Local Repository의 변경 사항이 다를 때 이를 비교 대조해서 충돌을 해결하고최신 데이터를 반영하기 위해서 사용합니다.  git pull : 연결된 Remote Repository의 최신 내용을 Local Repository로 가져오면서 merge합니다. git push와 반대의 개념이라고 보시면 되지만 merge할 때 문제가 발생했을 때 추적이 어렵습니다. 따라서 git pull을 이용하는 것 보다는 일단git fetch로 변경사항을 받고 이를 확인해서 코드를 수정한 후 Local Repository에 commit한 다음 git push로 최종 변경 사항을Remote Repository에 반영하는게 더 좋은 방법입니다. git clonegit clone은 Remote Repository에 있는 project를 내 컴퓨터로 가져올 때 사용합니다. 즉, GitHub에서 Local 환경으로 복사하는 작업입니다. 위에서 생성했던 MyProjectRemote란 GitHub Remote Repository를 Local로 clone해 보도록 하겠습니다.      먼저 Remote Repository의 주소를 복사합니다.        로컬 컴퓨터에서 프로젝트를 저장할 폴더를 생성한 후 git clone을 이용해 저장소를 복사합니다. D:/GitHub 폴더를 생성한 후 이 폴더 안에서 다음의 명령을 실행시킵니다.    git clone https://github.com/moon9342/MyProjectRemote.git정상적으로 clone이 진행되면 저장소 이름으로 폴더가 하나 생성되는것을 볼 수 있습니다. 당연히 이 폴더는 Remote Repository와 연결되어 있는 Local Repository가 됩니다.이해를 돕기 위해 순차적으로 생각해보면 다음과 같이 project가 진행될 수 있습니다.      협업을 책임지는 사람(PM)이 GitHub에 빈 Remote Repository를 생성합니다.        PM은 자신의 Local Repository에 project에 필요한 기본 구조와 여러가지 환경설정 그리고 개발한 필요한 기타 사항들을만들어서 저장합니다.        PM은 project의 뼈대가 담겨있는 이 Local Repository를 GitHub에 생성해 놓은 빈 Remote Repository와 연결합니다. 이때 git remote 명령을 이용하게 됩니다.        PM은 자신이 Local Repository에 가지고 있는 내용을 Remote Repository에 push 합니다.        이제 협업하는 사람 모두가 이 Remote Repository를 clone해서 로컬로 복사해 간 다음 자신이 해야 하는 작업을 진행합니다.  위와 같은 식으로 생각하면 git remote와 git clone의 차이점을 이해할 수 있습니다. git remoteGitHub에 빈 Remote Repository를 생성한 후 git remote를 이용하여 Local Repository와 연결할 수 있습니다.다음과 같은 명령을 이용합니다.  git remote add origin “Remote Repository URL”연결이 성공했는지를 다음의 명령어를 이용해서 확인해 볼 수 있습니다.  git remote -v git pushgit remote를 이용하여 Local Repository와 Remote Repository가 연결되었으면 이제 자신이 작업한 내용을Remote Repository에 upload를 할 수 있습니다.이 때 git push 명령을 이용하면 파일을 upload할 수 있는데 기본적으로 Remote Repository의 master branch에upload되게 됩니다. 따라서 만약 다른 branch의 내용을 upload하려 하면 다음과 같이 명령을 실행시켜야 합니다.  git push origin “local branch명”위의 명령에서 origin은 원격 저장소의 별칭입니다. git remote를 이용하여 Remote Repository를 연결할 때 이 origin이라는 별칭을 이용해서 원격 연결을 했었습니다.만약 origin 저장소에 Local의 모든 branch를 push하려면 다음과 같이 명령을 수행하시면 됩니다.  git push origin --allgit push가 진행될 때 Remote Repository에 같은 이름의 branch가 존재한다면 내용이 변경될 것이고 만약해당 branch가 존재하지 않는다면 새로운 branch를 Remote Repository에 생성하게 됩니다. 같은 이름의 branch가존재하지만 내역이 다르다면 당연히 push는 일어나지 않고 작업이 거부됩니다.간단한 예를 들자면 Local Repository의 master branch의 내용을 Remote Repository에 push하려면 다음과 같이실행하시면 됩니다.  git push origin master만약 Local Repository의 hotfix branch의 내용을 Remote Repository에 push하려면 다음과 같이 실행하시면 됩니다.  git push origin hotfix git fetch &amp; git pullRemote Repository를 이용하다 보면 다른 누군가가 먼저 commit할 경우가 있습니다. 이런 경우git은 당연히 파일의 내용이 서로 상이하기 때문에 push를 허용하지 않습니다.Remote Repository와 Local Repository를 적절히 서로 맞춰야 하며 이럴 때 사용하는 것이 git fetch 입니다.즉, fetch는 Remote Repository의 commit들을 Local Repository로 가져오는 역할을 하고 사용자는 Local Repository로 가져온 commit들을 자신의 작업과 적절히 병합하여 Remote Repository에 push해야 합니다.git pull은 Remote Repository의 정보를 가져오면서 자동으로 Local branch에 병합하는 명령어 입니다. 편하게 사용할 수 는 있지만 만약 conflict가 발생하면 내역 확인이 쉽지 않은 단점이 있습니다. Remote Branch를 Local로 가져오기만약 Local Repository에 Remote Repository의 branch가 존재하지 않는다면 git pull을 이용한다해도 자동으로 Remote Repository에 있는 branch를 가져오지 못합니다.Remote Repository에 있는 branch를 Local Repository로 가져오실려면 다음과 같이 작업하셔야 합니다.우선 git remote에 대한 내역을 갱신해야 합니다. 해당 명령을 하지 않을 경우 나중에 branch를 찾지 못한다는 오류가 발생할 수 있기때문입니다. 다음과 같은 명령을 이용합니다.  git remote update그 다음은 Remote Repository의 branch내역을 확인해야겠죠. -a option을 이용하면 Remote Repository와 Local Repository의 모든 branch를 확인할 수 있습니다.  git branch -r이제 Local Repository에 동일 이름의 branch를 생성하면서 Remote Repostiroy의 branch를 가져온 후 해당 branch로 checkout을 해 보죠. 다음과 같이 실행하시면 됩니다.  git checkout -t &lt;Remote_Branch_Name&gt;만약 Local Repository에 같은 이름의 branch가 아니라 다름이름의 branch를 생성하고 싶을 경우는 아래처럼 -b option을 이용하시면 됩니다.  git checkout -b &lt;Local_Branch_Name&gt; &lt;Remote_Branch_Name&gt;End.",
        "url": "/git-github"
    }
    ,
    
    "angular-lecture-exercise-1": {
        "title": "Angular 강좌(5) - 실습(1)",
            "author": "moon9342",
            "category": "",
            "content": "Angular 강좌는 여러 절로 구성되어 있습니다.     Angular 강좌(1) - Introduction    Angular 강좌(2) - 개발환경세팅    Angular 강좌(3) - Component    Angular 강좌(4) - Angular Material    Angular 강좌(5) - 실습(1)    Angular 강좌(6) - Data Binding    Angular 강좌(7) - 실습(2)    Angular 강좌(8) - Material Table    Angular 강좌(9) - 데이터공유(@Input)    Angular 강좌(10) - 데이터공유(@Output)    Angular 강좌(11) - 데이터공유(@ViewChild)    Angular 강좌(12) - 데이터공유(Content Projection)    Angular 강좌(13) - Service    Angular 강좌(14) - Service Mediator Pattern    Angular 강좌(15) - Service RxJS    Angular 강좌(16) - Material Table Event    Angular 강좌(17) - 중간 정리    Angular 강좌(18) - Directive    Angular 강좌(19) - Pipe    Angular 강좌(20) - Component LifecycleSPA( Single Page Application )요즘 만들어지는 거의 대부분의 Front End Web Application은 SPA 형태입니다. Web Application이 하나의 Web Page로구성되는 것이죠. 이와 대비되는 개념이 기존에 우리가 많이 했었던 JSP, ASP, PHP같은 것들입니다.이 기술들은 모두 SSR(Server Side Rendering)기반의 Round Trip 방식의 Web Application을 개발하는데 사용됩니다.기존의 Web Application은 Client가 새로운 Web Page를 요청할 때 마다 서버쪽에서 Web Page를 동적으로 만들어서 Client Browser에게 전송하는 방식을 취했습니다. 이 방식의 장,단점을 잠깐 살펴봐야 합니다. 장점은 서버쪽에서 모든 작업이이루어지기 때문에 개발하기가 용이하다는 점입니다. 이미 개발방식도 정형화되어 있고 jQuery 정도만 익혀서 결과 WebPage에 적용하는 식으로 Client쪽 처리도 쉽게 할 수 있습니다.기존 Desktop 환경에서는 이 방식이 크게 문제가 되지 않았습니다. 하지만 Web Application의 사용환경이 Desktop환경에서 Mobile환경으로 넘어가면서 다음과 같은 문제가 발생하기 시작합니다.      클라이언트가 새로운 페이지를 요청하고 받을 때 마다 web browser 화면 전체가 결과 Page로 Refresh됩니다. 필요한 데이터만받아서 필요한 부분만 갱신하면 되지 전체 페이지를 다 받아서 새로 고침하는 것은 네트워크 사용량을 생각해봐도 비효율적입니다.        Mobile환경에서 Client는 이미 Native App을 사용하는 방식으로 UX가 확고하게 굳어져 있습니다. 따라서 우리의Web Application도 마치 Native App처럼 동작하도록 만들어 제공해야 한다는 것이죠.  결국 위와 같은 문제를 해결하기 위해 나온 모던 웹 패러다임이 바로 SPA입니다. Network traffic의 감소 및 사용성 관점에서 상당히 가치있는 Front End 개발방식이라고 볼 수 있습니다. 하지만 SPA도 단점이 없는 것은 아닙니다. 일반적으로 두가지의 단점을 많이이야기 합니다.  초기 로딩 속도 문제  검색엔진최적화(SEO, Search Engine Optimization) 문제실습인데 설명이 너무 길어지는군요. 이 문제는 여기서 따로 언급하지는 않겠습니다. 여하간 SEO 문제를 해결하기 위해Angular Router를 이용하여 PathLocationStrategy라는 Location 정책을 이용해 우리의 Angular Application을 작성하겠습니다.Module 생성우리는 이미 AppModule이라고 불리는 Root Module을 가지고 있습니다. 여기에 추가적으로 다른 Module을 만들어서 개발할 수 있습니다.먼저 Module에 대해 간단히 알아보고 우리 프로그램에 맞게 Module을 구성해 보도록 하겠습니다.Angular의 Module은  연관성이 있는 Angular의 구성요소들을 하나의 단위로 묶은 것을 지칭합니다. 또한 Angular Application은 크게 본다면 이런 Module의 집합이라고 할 수 있습니다. JavaScript에서말하는 Module과는 다른 개념입니다.아주 간단한 application인 경우 Root Module 하나로 구성할 수 있지만 일반적으로 여러개의 Module을 이용해서 구성하게 됩니다.일반적으로 다음과 같은 형태의 Module을 이용합니다.      Feature Module    특정 화면을 구성하는 구성요소를 묶어서 Module로 관리할 수 있습니다. 우리예제에서 Home은 단일 View로 구성되어 있습니다. 따로 Module을 만들어서 Home에 대한 구성요소를 관리해도 됩니다. 하지만 우리 예제에서는 Home에 대한 Component를 Root Module에서관리하도록 하겠습니다. 하지만 도서 검색이나 영화 검색같은 경우 여러 요소들이 필요할 테고 각각을 Module로 따로 관리하는게 좋습니다.Application안에 여러 화면이 존재할 경우 각 화면별로 Module화를 시키지 않으면 추후에 구성요소의 관리가 어려워짐은 당연합니다.또 Application 전역에서 사용하는 구성요소들을 따로 묶어서 Module로 만들 수도 있습니다. 이런 기능들은 Root Module에 import가 될 필요가 있는 것들로 간단한 예를 들자면Authentification Module이나 Routing Module등이 있습니다.            Shared Module    Feature Module에 의해서 공통적으로 사용되는 구성요소들을 묶어서 Module로 관리할 수 있습니다. 주로 Feature Module에서 공통적으로 사용되는 Directive나 Pipe같은 것들이 포함됩니다.  먼저 Routing Module을 생성하고 그 안에서 Router를 구성하고 등록해보겠습니다.그 후 Routing Module을 Root Module에서 가져다 사용하는 식으로 작성을 해 보죠.command 창을 열고 다음의 명령을 이용하여 새로운 Module을 하나 생성합니다.  ng generate module app-routing정상적으로 실행되면 src/app/app-routing 폴더가 생성되고 그 안에 app-routing.module.ts 파일이 생성됩니다.조금뒤에 이 Module안에 Router를 작성하게 되겠죠. 우리가 가지고 있는 app.module.ts라는 Root Module에 Router를 생성, 등록해도 됩니다. 하지만 실제 Application을 작성할 때는 사용되는 Routing이 많아지게 되는데 이때는 Routing Module로 빼서 관리하시는게 좋습니다.각 Routing이 사용할 Component 생성각 Routing 경로가 사용할 Component를 생성합니다. 그런데 위에서 특정 화면을 구성하는 구성요소를 Module화 시켜서 사용하는게 좋다고 했으니 우리의 2가지 화면에 대해 Module을 생성하고 이 안에 Component를 생성하도록 하겠습니다.Home은 아까 언급했듯이 별다른 기능이 없는 View이기 때문에 따로 Module로 생성하지 않고 도서 검색에 대한 Module과 영화 검색에 대한 Module만 만들도록 하겠습니다.Home 화면을 담당할 Component는 src/app/pages 하단에 생성하고 Root Module에서 직접 import해서 사용하도록 생성합니다.command 창에서 Angular CLI를 이용해 Component를 생성합니다.  ng generate component pages/home이제 도서 검색을 위한 Module을 생성하고 그 안에 Component를 생성합니다.  ng generate module bookSearch   ng generate component bookSearch/bookSearchMain마지막으로 영화 검색을 위한 Module을 생성하고 그 안에 Component를 생성합니다.  ng generate module movieSearch   ng generate component movieSearch/movieSearchMain정상적으로 수행되면 아래의 그럼처럼 각각의 폴더안에 파일들이 생성되게 됩니다.Routing Module 수정이제 Routing Module을 수정하여 Router를 구성합니다. app-routing.module.ts를 다음과 같이 수정합니다.import { NgModule } from '@angular/core';import { CommonModule } from '@angular/common';// Angular Router Module importimport { Routes, RouterModule } from \"@angular/router\";// Routing 처리를 할 각각의 Component importimport { HomeComponent } from \"../pages/home/home.component\";import { BookSearchMainComponent } from    \"../book-search/book-search-main/book-search-main.component\";import { MovieSearchMainComponent } from    \"../movie-search/movie-search-main/movie-search-main.component\";// Router 생성( path 표시할 때 Root path에 대한 '/'는 제외 )const routers: Routes = [  { path : '', component : HomeComponent },  { path : 'book', component : BookSearchMainComponent },  { path : 'movie', component : MovieSearchMainComponent }];@NgModule({  imports: [    CommonModule,    RouterModule.forRoot(routers)  ],  declarations: [],  exports: [RouterModule]})export class AppRoutingModule { }Root Module 수정Routing Module이 만들어졌으니 이제 Root Module에서 Routing Module을 불러들이는 코드를 작성해야 합니다.app.module.ts 파일의 내용입니다.import { BrowserModule } from '@angular/platform-browser';import { NgModule } from '@angular/core';// BrowserAnimationsModule import 구문 추가import { BrowserAnimationsModule } from '@angular/platform-browser/animations';// MatTableModule import 구문 추가import { MatTableModule } from '@angular/material/table';import { AppComponent } from './app.component';import { HomeComponent } from './pages/home/home.component';// Feature Module importimport { BookSearchModule } from \"./book-search/book-search.module\";import { MovieSearchModule } from \"./movie-search/movie-search.module\";// Routing Module importimport { AppRoutingModule } from \"./app-routing/app-routing.module\";@NgModule({  declarations: [    AppComponent,    HomeComponent  ],  imports: [    BrowserModule,    BrowserAnimationsModule,    MatTableModule,    AppRoutingModule,    BookSearchModule,    MovieSearchModule  ],  providers: [],  bootstrap: [AppComponent]})export class AppModule { }Navigation Menu 작성이제 Navigation Menu를 만들어야 합니다. Routing Module을 이용해 Router의 구성과 등록이 완성되었으나 해당 Routing Path에 대한 View를 어디에 표시할지는 아직 지정하지 않았습니다.app.component.html을 수정해 RouterOutlet directive를 이용해 View의 rendering위치를 지정해야 합니다.여기서는 Bootstrap을 이용해서 화면을 구성했습니다. Bootstrap의 예제중에 Blog 예제가 있는데 그 형식을가져다가 사용했습니다. Bootstrap을 사용하기 위해서는 다음과 같이 Bootstrap을 설치하여야 합니다.  npm install bootstrap@4.0.0-beta.2버전에 약간 주의하셔야 합니다. 현재 최신 버전(bootstrap@4.0.0-beta.3)의 Bootstrap은 Angular CLI로 Production build를 했을 때 bundling 오류가 발생합니다.설치가 완료되면 Bootstrap을 import하셔야 합니다. .angular-cli.json 파일을 다음과 같이 수정합니다.   \"styles\": [        \"../node_modules/bootstrap/dist/css/bootstrap.min.css\",        \"styles.css\"   ],이제 app.component.html 파일을 수정합니다.&lt;nav&gt;    &lt;a routerLink=\"/\"&gt;Home&lt;/a&gt;    &lt;a routerLink=\"/book\"&gt;도서검색&lt;/a&gt;    &lt;a routerLink=\"/movie\"&gt;영화검색&lt;/a&gt;&lt;/nav&gt;&lt;router-outlet&gt;&lt;/router-outlet&gt;쉽게 보기 위해 Bootstrap은 걷어내고 실제 필요한 부분만 명시했습니다. 주의해서 보셔야 할 건 routerLink 입니다.&lt;a&gt;의 href 속성을 이용하면 서버에 request를 보내게되니 href를 이용하지 않습니다.각각의 메뉴를 클릭했을 때 해당 URL을 Router에 전달하고 Router에 의해서 Component가 선택되서 &lt;router-outlet&gt;&lt;/router-outlet&gt;안에 Component가 지정한 HTML이 출력되게 됩니다.결과가 잘 나오나요? Home 화면의 내용을 바꾸실려면 src/app/pages/home 폴더 안에 home.component.html을적절히 수정하시면 됩니다.참고로 다음과 같은 routerLinkActive directive를 이용하면 routerLink directive의 값과 현재 browser URL이 정확히 일치할 때 특정 style의 class를 지정할 수 있습니다.&lt;nav&gt;    &lt;a routerLink=\"/\"&gt;Home&lt;/a&gt;    &lt;a routerLink=\"/book\"       [routerLinkActiveOptions]=\"{ exact: true }\"       routerLinkActive=\"menuActiveClass\"&gt;&gt;도서검색&lt;/a&gt;    &lt;a routerLink=\"/movie\"&gt;영화검색&lt;/a&gt;&lt;/nav&gt;&lt;router-outlet&gt;&lt;/router-outlet&gt;위의 예처럼 링크를 클릭해서 특정 경로로 Routing을 할 수도 있지만 버튼을 클릭했을 때 처럼 프로그램적으로 Routing을 변경해야 하는 경우도 있을 수 있습니다. 이런경우는 Angular Router의 navigate method를 이용하시면 됩니다.import { Router } from '@angular/router';......constructor(private route:Router) { }......gotoBook() {    // Router객체에 대해 method호출    this.route.navigate(['book']);}현재까지 우리가 작성한 Angular Project에 대해 production build를 진행하실려면 다음과 같이 하시면 됩니다.  ng build --prod --base-href=/my-base-url/도서 검색 화면3개의 메뉴 중 Home 메뉴는 단일 페이지 이기 때문에 적절하게 수정해서 화면에 보여주면 됩니다. 먼저 최종적으로 만들어진 도서 검색 화면을 한번 보고 View을 어떻게 구성할지 개념적으로 확인하면 될 듯 싶습니다. 아래의 그림이 최종 만들어진 도서검색 화면입니다.총 4개의 View로 구성되어 있습니다. 파란색으로 되어 있는 가장 큰 View안에 검색결과를 보여주는 영역과 도서 종류를 선택하는 Select Box가 들어 있습니다. 부모 View안에 빨간색으로 되어있는 3개의 자식 View가 포함되어 있네요. 맨 위의 View는 검색어를 입력할 수 있는 View이고 제일 아래의 View는 검색어에 해당하는 책에 대한 리스트를 표현하는 View입니다. 가운데 View는 리스트에서 특정 책을 선택하면 그 책의 내용을 자세하게 출력해주는 View입니다.일단 화면을 만드는데 집중하고 실제 프로그램이 동작하는 로직에 관련된 부분은 나중에 service를 설명하면서 추가하도록 하겠습니다.AppComponent 수정이전에 만들어 놓은 mySearchProject를 수정하여 도서검색 화면을 만들고그에 따른 Component들을 생성, 등록까지 진행하도록 하겠습니다.src/app 폴더안에 app.component.ts 파일을 열면 다음과 같은 내용을 보실 수 있습니다.import { Component } from '@angular/core';@Component({  selector: 'app-root',  templateUrl: './app.component.html',  styleUrls: ['./app.component.css', './blog.css']})export class AppComponent {  title = 'app';}이 Component가 우리의 Root Component입니다.selector: 'app-root' 설정에 의해 이 Component는 template 코드내에서 &lt;app-root&gt;&lt;/app-root&gt;로 되어 있는 부분을 rendering 한다는 것을 알 수 있습니다.또한 templateUrl에 의해 app.component.html을 이용해 rendering한다는 것도파악할 수 있겠네요.index.html을 보시면 다음과 같이 &lt;app-root&gt;&lt;/app-root&gt;로 되어있는 부분이 보이고 이 부분이 우리 Component에 의해서rendering되게 됩니다.&lt;!doctype html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt;  &lt;meta charset=\"utf-8\"&gt;  &lt;title&gt;MySearchProject&lt;/title&gt;  &lt;base href=\"/\"&gt;  &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt;  &lt;link rel=\"icon\" type=\"image/x-icon\" href=\"favicon.ico\"&gt;  &lt;!-- Material Icon 설정. --&gt;  &lt;link href=\"https://fonts.googleapis.com/icon?family=Material+Icons\" rel=\"stylesheet\"&gt;&lt;/head&gt;&lt;body&gt;  &lt;app-root&gt;&lt;/app-root&gt;&lt;/body&gt;&lt;/html&gt;결국 index.html안의 &lt;app-root&gt;&lt;/app-root&gt; 부분은 app.component.html의 내용으로 rendering된다는 것을 파악할 수 있습니다.이제 app.component.html의 코드를 보죠. 위에서 Routing Module을 이용했기 때문에 다음과 같은 코드가 나옵니다.Bootstrap 코드도 포함시켰습니다.&lt;div class=\"container\"&gt;  &lt;header class=\"blog-header py-3\"&gt;    &lt;div class=\"row flex-nowrap justify-content-between align-items-center\"&gt;      &lt;div class=\"col-4 pt-1\"&gt;      &lt;/div&gt;      &lt;div class=\"col-4 text-center\"&gt;        &lt;a class=\"blog-header-logo text-dark\" href=\"#\"&gt;my Search Project&lt;/a&gt;      &lt;/div&gt;      &lt;div class=\"col-4 d-flex justify-content-end align-items-center\"&gt;      &lt;/div&gt;    &lt;/div&gt;  &lt;/header&gt;  &lt;div class=\"nav-scroller py-1 mb-2\"&gt;    &lt;nav class=\"nav d-flex justify-content-between\"&gt;      &lt;a class=\"p-2 text-muted\" routerLink=\"/\"&gt;Home&lt;/a&gt;      &lt;a class=\"p-2 text-muted\" routerLink=\"/book\"&gt;도서 검색&lt;/a&gt;      &lt;a class=\"p-2 text-muted\" routerLink=\"/movie\"&gt;영화 검색&lt;/a&gt;      &lt;a class=\"p-2 text-muted\" href=\"#\"&gt;&lt;/a&gt;      &lt;a class=\"p-2 text-muted\" href=\"#\"&gt;&lt;/a&gt;      &lt;a class=\"p-2 text-muted\" href=\"#\"&gt;&lt;/a&gt;      &lt;a class=\"p-2 text-muted\" href=\"#\"&gt;&lt;/a&gt;      &lt;a class=\"p-2 text-muted\" href=\"#\"&gt;&lt;/a&gt;      &lt;a class=\"p-2 text-muted\" href=\"#\"&gt;&lt;/a&gt;      &lt;a class=\"p-2 text-muted\" href=\"#\"&gt;&lt;/a&gt;      &lt;a class=\"p-2 text-muted\" href=\"#\"&gt;&lt;/a&gt;      &lt;a class=\"p-2 text-muted\" href=\"#\"&gt;&lt;/a&gt;    &lt;/nav&gt;  &lt;/div&gt;  &lt;div class=\"jumbotron p-3 p-md-5 text-dark rounded bg-warning\"&gt;    &lt;div class=\"col-md-12 px-0\"&gt;      &lt;router-outlet&gt;&lt;/router-outlet&gt;    &lt;/div&gt;  &lt;/div&gt;&lt;/div&gt;Bootstrap을 이용했기 때문에 Style에 관련된 코드가 많네요. 여하간 Navigation Menu를 작성하고 각 Menu를클릭하면 Router에게 routerLink에 명시된 경로를 전달하게 됩니다. 그러면 Router는 해당 경로에 매핑되는 Component를찾게되고 해당 Component는 &lt;router-outlet&gt;&lt;/router-outlet&gt;위치에 View를 Rendering 하게 됩니다.결과적으로 도서 검색 메뉴를 클릭하면 &lt;router-outlet&gt;&lt;/router-outlet&gt; 부분에 book-search-main.component.html의내용이 rendering되게 되고 이제 그 내용을 수정해서 화면을 다시 구성합니다. View를 추가하기 위해 Component를 생성하는 작업을 진행해야 합니다.Component 추가book-search-main.component.html은 내부에 3개의 View 영역을 포함하고 있습니다.  첫번째 영역 : 검색 키워드를 입력하고 검색 버튼을 눌러 실행시키는 View 영역.  두번째 영역 : 검색된 책을 선택하면 책의 세부정보가 출력되는 View 영역.  세번째 영역 : 검색된 책들의 리스트를 출력하기 위한 View 영역.이렇게 3개의 View를 이용해서 화면을 구성할 것이고 3개의 Component를 추가하여 화면을 구성하려 합니다.Angular CLI를 이용하여 다음과 같이 실행해서 새로운 Component를 추가합니다.  ng generate component bookSearch/search-boxAngular CLI의 generate를 이용하여 Component 생성 시 Component를 구성하는 관련 파일들을 자동으로 손쉽게 생성할 수 있습니다. generate를 다 쓰지 않고 앞글자인 g 만 써도 됩니다. generate는 뒤에 어떤 요소를 생성할 것인지 그리고 요소명은무엇인지를 받아 특정 요소를 생성하게 됩니다. 즉, Component만 생성할 수 있는건 아닙니다.생성된 src/app/book-search/search-box 폴더 안에 있는 search-box.component.ts 파일을 열어서 selector를 확인해보니 app-search-box로 지정되어 있습니다. 우리가 template 코드에서 &lt;app-search-box&gt;&lt;/app-search-box&gt;을 이용하면이 Component가 해당 영역을 rendering하게 되겠네요.이와 유사하게 2개의 Component를 더 생성합니다. 다음과 같이 실행해서 새로운 Component를 추가합니다.  ng generate component bookSearch/detail-box  ng generate component bookSearch/list-box자 이제 생성된 각각의 Component에 대한 selector를 참조해 src/app/book-search/book-search-main 안의 book-search-main.component.html의 내용을 다음과 같이 수정합니다.&lt;div class=\"bookSearch-outer\"&gt;  &lt;div class=\"d-flex align-items-center p-3 my-3 text-white-50 bg-purple rounded box-shadow\"&gt;    &lt;img class=\"mr-3\" src=\"assets/images/search-icon.png\" alt=\"\" width=\"48\" height=\"48\"&gt;    &lt;div class=\"lh-100\"&gt;      &lt;h5 class=\"mb-0 text-white lh-100\"&gt;Search Result&lt;/h5&gt;    &lt;/div&gt;  &lt;/div&gt;  &lt;div class=\"form-group col-md-4\"&gt;    &lt;label for=\"inputState\"&gt;도서 종류&lt;/label&gt;    &lt;select id=\"inputState\" class=\"form-control\"&gt;      &lt;option selected&gt;선택하세요...&lt;/option&gt;      &lt;option&gt;국내외도서&lt;/option&gt;      &lt;option&gt;국내도서&lt;/option&gt;      &lt;option&gt;국외도서&lt;/option&gt;    &lt;/select&gt;  &lt;/div&gt;  &lt;div&gt;    &lt;app-search-box&gt;&lt;/app-search-box&gt;  &lt;/div&gt;  &lt;div&gt;    &lt;app-detail-box&gt;&lt;/app-detail-box&gt;  &lt;/div&gt;  &lt;div&gt;    &lt;app-list-box&gt;&lt;/app-list-box&gt;  &lt;/div&gt;&lt;/div&gt;또한 src/app/book-search/book-search-main 안의 book-search-main.component.css의 내용을 다음과 같이 작성합니다. CSS에 대한 설명은 생략합니다..bookSearch-outer {  font-family: Georgia !important;  width: 70%;  text-align: center;  margin: 0 auto;}각 Component의 View 작성이제 각각의 Component의 templateUrl에 명시된 html을 Angular Material을 이용해 우리가사용할 화면을 만들어 냅니다.제일 먼저 상단의 search-box 영역에 대한 HTML을 작성합니다.다음과 같이 src/app/book-search/search-box 폴더안의 search-box.component.html의 내용을 수정합니다.&lt;div class=\"example-container\"&gt;  &lt;mat-toolbar class=\"search-toolbar-style\"&gt;Search Keyword : &lt;/mat-toolbar&gt;  &lt;mat-form-field&gt;    &lt;input matInput placeholder=\"Search Keyword\"&gt;  &lt;/mat-form-field&gt;  &lt;button mat-raised-button color=\"warn\"&gt;Search!&lt;/button&gt;&lt;/div&gt;search-box.component.css의 내용은 다음과 같이 수정합니다..search-toolbar-style {  font-family: Georgia;  color: white;  background-color: teal;  margin-bottom: 20px;}Angular Material을 이용했기 때문에 해당 Element에 대한 Material Module을 book-search.module.ts안에import해 줍니다.다음은 book-search.module.ts 파일의 내용입니다.import { NgModule } from '@angular/core';import { CommonModule } from '@angular/common';import { BookSearchMainComponent } from './book-search-main/book-search-main.component';import { SearchBoxComponent } from './search-box/search-box.component';import { ListBoxComponent } from './list-box/list-box.component';import { DetailBoxComponent } from './detail-box/detail-box.component';import { MatFormFieldModule } from '@angular/material/form-field';import { MatInputModule } from '@angular/material';import { MatButtonModule } from '@angular/material/button';import { MatToolbarModule } from '@angular/material/toolbar';@NgModule({  imports: [    CommonModule,    MatFormFieldModule,    MatInputModule,    MatButtonModule,    MatToolbarModule  ],  declarations: [BookSearchMainComponent,                  SearchBoxComponent,                  ListBoxComponent,                  DetailBoxComponent]})export class BookSearchModule { }일단 여기까지 작성하고 실행을 시켜보면 다음과 같은 화면을 볼 수 있습니다.화면이 잘 나오나요? 아직 데이터 바인딩과 이벤트에 대한 내용은 설명하지 않았기 때문에 키워드를 입력하거나 버튼을 눌러도 아무런 반응을 하지 않습니다.이와 비슷하게 가운데 detail-box의 View는 다음과 같이 작성하시면 됩니다. list-box는 데이터 바인딩에 대한 내용을배워야지 사용할 수 있으니 list-box의 View는 데이터 바인딩에 대해 설명하고 작성하겠습니다.아래는 detail-box Component에 대한 각각의 코드입니다.detail-box.component.css 파일입니다. src/assets/images 폴더안에 book-icon.jpg 파일을 하나 넣어두셔야 합니다..example-card {  width: 500px;  margin: 0 auto;}.example-header-image {  background-image: url('/assets/images/book-icon.jpg');  background-size: cover;}.book-image {  width: 100px !important;}.detail-header-style {  font-family: Georgia;}detail-box.component.html 파일입니다.&lt;mat-card class=\"example-card\"&gt;  &lt;mat-card-header class=\"detail-header-style\"&gt;    &lt;div mat-card-avatar class=\"example-header-image\"&gt;&lt;/div&gt;    &lt;mat-card-title&gt;제목 : Angular 일주일 완성&lt;/mat-card-title&gt;    &lt;mat-card-subtitle&gt;저자 : 홍길동&lt;/mat-card-subtitle&gt;  &lt;/mat-card-header&gt;  &lt;img mat-card-image class=\"book-image\" src=\"\"&gt;  &lt;mat-card-content&gt;    &lt;p&gt;      ISBN : 123-456, 도서 가격 : 5000, 출판일 : 2017년 12월    &lt;/p&gt;  &lt;/mat-card-content&gt;  &lt;mat-card-actions&gt;    &lt;button mat-button mat-raised-button color=\"primary\"&gt;바로 구입&lt;/button&gt;  &lt;/mat-card-actions&gt;&lt;/mat-card&gt;Material Card Layout Component를 사용했기 때문에 해당 Module에 대한 처리를 book-search.module.ts에 해주어야 하겠죠?import { NgModule } from '@angular/core';import { CommonModule } from '@angular/common';import { BookSearchMainComponent } from './book-search-main/book-search-main.component';import { SearchBoxComponent } from './search-box/search-box.component';import { ListBoxComponent } from './list-box/list-box.component';import { DetailBoxComponent } from './detail-box/detail-box.component';import { MatFormFieldModule } from '@angular/material/form-field';import { MatInputModule } from '@angular/material';import { MatButtonModule } from '@angular/material/button';import { MatToolbarModule } from '@angular/material/toolbar';import { MatCardModule } from '@angular/material/card';@NgModule({  imports: [    CommonModule,    MatFormFieldModule,    MatInputModule,    MatButtonModule,    MatToolbarModule,    MatCardModule  ],  declarations: [BookSearchMainComponent,                  SearchBoxComponent,                  ListBoxComponent,                  DetailBoxComponent]})export class BookSearchModule { }결과 화면지금까지 작성한 내용을 실행시켜보면 다음과 같은 화면을 보실 수 있습니다.이번 포스트에서는 Component를 추가하고 Angular Material을 이용해 View를 작성해보았습니다. 다음 포스트에서는데이터 바인딩에 대한 내용을 알아보도록 하겠습니다.End.Angular 강좌는 아래의 책과 사이트를 참조했습니다.    조금 더 자세한 사항을 알고 싶으시면 해당 사이트를 방문하세요!!    Angular Official HomePage    Angular Material Official HomePage    Build a Mobile App with Angular 2 and Ionic 2    Angular 첫걸음 - 한빛미디어    제대로 배우는 Angular 4 - 비제이퍼블릭",
        "url": "/angular-lecture-exercise-1"
    }
    ,
    
    "angular-lecture-material": {
        "title": "Angular 강좌(4) - Angular Material",
            "author": "moon9342",
            "category": "",
            "content": "Angular 강좌는 여러 절로 구성되어 있습니다.     Angular 강좌(1) - Introduction    Angular 강좌(2) - 개발환경세팅    Angular 강좌(3) - Component    Angular 강좌(4) - Angular Material    Angular 강좌(5) - 실습(1)    Angular 강좌(6) - Data Binding    Angular 강좌(7) - 실습(2)    Angular 강좌(8) - Material Table    Angular 강좌(9) - 데이터공유(@Input)    Angular 강좌(10) - 데이터공유(@Output)    Angular 강좌(11) - 데이터공유(@ViewChild)    Angular 강좌(12) - 데이터공유(Content Projection)    Angular 강좌(13) - Service    Angular 강좌(14) - Service Mediator Pattern    Angular 강좌(15) - Service RxJS    Angular 강좌(16) - Material Table Event    Angular 강좌(17) - 중간 정리    Angular 강좌(18) - Directive    Angular 강좌(19) - Pipe    Angular 강좌(20) - Component LifecycleAngular MaterialMaterial Design은 모바일과 데스크탑 그리고 그 외 다양한 디바이스들의 application을 개발할 때 하나의 일관된 디자인을 적용하고자 Google이 공개한 design guideline입니다.  머티리얼 디자인(Material Design, 코드명: Quantum Paper)이란 플랫 디자인의 장점을 살리면서도 빛에 따른 종이의 그림자 효과를 이용하여 입체감을 살리는 디자인 방식을 말한다. 2014년 구글이 안드로이드 스마트폰에 적용하면서 널리 퍼지기 시작했다. 플랫 디자인과 마찬가지로 최소한의 요소만을 사용하여 대상의 본질을 표현하는 디자인 기법인 미니멀리즘(minimalism)을 추구한다.( 자료출처 : https://ko.wikipedia.org )제가 Design에 대한 관심과 지식이 상대적으로 많지 않아서 Material Design에 대한 정의는 위키에서 가져왔습니다.여하간 이런 Material Design에 대한 concept을 Angular application에 적용하기 위해 만든 Component가 바로 Angular Material입니다.우리의 예제는 이 Angular Material로 작성할 것이기 때문에 Angular Material을 어떻게 사용하는지에 대해서 먼저 알아볼 필요가 있습니다.  참고로 Angular Material은 정식버전이 나온지 얼마 되지 않았습니다. 해서 생각만큼 많은 Component와 기능을 지원하고있지 못합니다. Angular Material Official HomePage의 공식 문서 역시 아직은 좀 사용하기 불편합니다. 차차 나아지겠죠 ^^;;우리예제는 Bootstrap도 같이 이용합니다.Bootstrap에 대해서는 그 때 알아보기로 하겠습니다.자 그럼 Angular Material에 대해 알아보도록 하죠.Angular Material &amp; Angular Material CDK 설치제일 먼저 해야 할 일은 Angular Material과 Angular Material CDK를 설치하는 것입니다.우리가 만들어 놓은 mySearchProject에서 command 창을 열고 다음 명령을 수행시켜 package를 설치합니다. ( 현재 경로는 C:/mySearchProject 입니다. )  npm install --save @angular/material @angular/cdk--save option은 npm@5부터 기본 option으로 바뀌었습니다. 즉, --save는 생략하셔도 됩니다. 잘 아시겠지만 저 명령을 수행하면 package.json의 dependencies에 설치된 패키지와 버전 정보가 기록되게 됩니다.참고로 만약 개발 시에만 사용하는 package를 설치하실려면 --save-dev option을 주시면 됩니다. TypeScript와 같은것은사실 transpiler이기 때문에 개발시에만 필요하고 실제 배포까지 할 필요는 없으니 TypeScript같은 건 --save-dev로devDependencies에 포함시키는게 좋습니다. 그런데 우리는 그냥 전역으로 설치해서 쓰고 있죠 ^^;;여하간 약간의 시간이 지나면 package가 설치됩니다.Angular Animation Module 설치몇몇개의 Material Component는 Angular Animation Module에 의존성을 가지고 있습니다. 따라서 다음 명령을 수행시켜 Angular Animation Module을 설치해야 합니다.  npm install --save @angular/animations이 @angular/animations module은 내부적으로 WebAnimation API을 이용합니다. 그런데 모든 browser들이 이 API를 지원하는건 아닙니다. 만약 WebAnimation API를 지원하지 않는 browser를 이용할 경우는 여기를클릭해서 나온 내용에 따라 따로 처리해 주셔야 합니다.이제 우리 project에서 src/app 폴더 안에 있는 Root Module인 app.module.ts 파일을 열어 다음과 같이 수정합니다.import { BrowserModule } from '@angular/platform-browser';import { NgModule } from '@angular/core';// BrowserAnimationsModule import 구문 추가import { BrowserAnimationsModule } from '@angular/platform-browser/animations';import { AppComponent } from './app.component';@NgModule({  declarations: [    AppComponent  ],  imports: [    BrowserModule,    BrowserAnimationsModule  // BrowserAnimationsModule 추가  ],  providers: [],  bootstrap: [AppComponent]})export class AppModule { }사용할 Component import설치가 다 되었으니 이제 사용할 Angular Material Module을 import해야 합니다.사실 이부분은 나중에 View에 대한 HTML을 작성할 때 해야 되는 작업입니다. 어떤 Component를 이용하여 View를 구성할지결정이 되어야 import할 수 있기 때문이지요.나중에 추가할 내용이지만 일단 하나만 먼저 연습삼아 추가해보도록 하겠습니다. 여기서 사용할 것은 Material Table Component입니다. 해당 Component를 사용하기 위해 import하는 작업이 필요합니다.추후에 구현에 필요한 Component들이 더 추가되어야 하는데 이런 Component들은 실습을 진행하면서 추가하도록 하겠습니다.우리 project에서 src/app 폴더 안에 있는 Root Module인 app.module.ts 파일을 열어 다음과 같이 수정합니다.import { BrowserModule } from '@angular/platform-browser';import { NgModule } from '@angular/core';// BrowserAnimationsModule import 구문 추가import { BrowserAnimationsModule } from '@angular/platform-browser/animations';// Material Table Component 사용을 위한 MatTableModule importimport { MatTableModule } from '@angular/material/table';import { AppComponent } from './app.component';@NgModule({  declarations: [    AppComponent  ],  imports: [    BrowserModule,    BrowserAnimationsModule,  // BrowserAnimationsModule 추가    MatTableModule            // MatTableModule 추가  ],  providers: [],  bootstrap: [AppComponent]})export class AppModule { }사용할 Theme 설정application에 적용할 Theme를 설정해 보도록 하죠. 기본적으로 제공되는 built-in theme는 현재 4가지가 존재하는데 그 중 하나를 설정하시면 됩니다.우리는 Angular CLI를 이용하고 있기 때문에 src 폴더 안에 있는 styles.css 파일을열어서 다음의 코드를 넣어주면 됩니다. styles.css 파일은 우리 application 전역에 적용되는global CSS 파일입니다.@import '~@angular/material/prebuilt-themes/indigo-pink.css';만약 다른 theme를 이용하고 싶으면 여기를 참조해 다른 이름의 CSS 파일을 이용하시면 됩니다.Gestures 지원을 위한 HammerJS 설치사용자 Gestures를 지원하기 위해 몇몇개의 Material Component들은 HammerJS에 의존하고 있습니다. 그렇게 때문에 이 HammerJS 역시 설치하고 설정까지 잡아줘야 합니다.  npm install --save hammerjs설치가 끝나면 우리 application의 시작지점(entry point)인 main.ts 파일을 열어서 제일 상단에다음과 같은 코드를 추가해 줘야 합니다.// hammerjs import 추가import 'hammerjs';Material Icon 사용을 위한 설정Material은 쉽게 사용할 수 있는 Icon을 제공해 줍니다. 마치 Font-Awesome처럼 사용할 수 있습니다. Material Icon을 사용하기 위해서는 index.html을 다음과 같이 수정합니다.&lt;!doctype html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt;  &lt;meta charset=\"utf-8\"&gt;  &lt;title&gt;BookSearchAngular&lt;/title&gt;  &lt;base href=\"/\"&gt;  &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt;  &lt;link rel=\"icon\" type=\"image/x-icon\" href=\"favicon.ico\"&gt;  &lt;!-- Material Icon 설정 --&gt;  &lt;link href=\"https://fonts.googleapis.com/icon?family=Material+Icons\" rel=\"stylesheet\"&gt;&lt;/head&gt;&lt;body&gt;  &lt;app-root&gt;&lt;/app-root&gt;&lt;/body&gt;&lt;/html&gt;Material Icon의 사용방법에 대한 자세한 내용은 여기를 확인해 보시면 됩니다.Angular Material을 사용하기 위한 설정이 끝났습니다. 이제 Angular Material Official HomePage의 Components 메뉴를 클릭해 사용할 Component의 종류와 사용방법을 찾아 적절하게 작성만 해 주면 될 듯 싶습니다. 다음 포스트에서Angular Material을 이용해 화면구성과 Component 설정을 해 보도록 하겠습니다.End.Angular 강좌는 아래의 책과 사이트를 참조했습니다.    조금 더 자세한 사항을 알고 싶으시면 해당 사이트를 방문하세요!!    Angular Official HomePage    Angular Material Official HomePage    Build a Mobile App with Angular 2 and Ionic 2    Angular 첫걸음 - 한빛미디어    제대로 배우는 Angular 4 - 비제이퍼블릭",
        "url": "/angular-lecture-material"
    }
    ,
    
    "angular-lecture-component": {
        "title": "Angular 강좌(3) - Component",
            "author": "moon9342",
            "category": "",
            "content": "Angular 강좌는 여러 절로 구성되어 있습니다.     Angular 강좌(1) - Introduction    Angular 강좌(2) - 개발환경세팅    Angular 강좌(3) - Component    Angular 강좌(4) - Angular Material    Angular 강좌(5) - 실습(1)    Angular 강좌(6) - Data Binding    Angular 강좌(7) - 실습(2)    Angular 강좌(8) - Material Table    Angular 강좌(9) - 데이터공유(@Input)    Angular 강좌(10) - 데이터공유(@Output)    Angular 강좌(11) - 데이터공유(@ViewChild)    Angular 강좌(12) - 데이터공유(Content Projection)    Angular 강좌(13) - Service    Angular 강좌(14) - Service Mediator Pattern    Angular 강좌(15) - Service RxJS    Angular 강좌(16) - Material Table Event    Angular 강좌(17) - 중간 정리    Angular 강좌(18) - Directive    Angular 강좌(19) - Pipe    Angular 강좌(20) - Component LifecycleComponent 개요Angular는 Front End Web Application Framework입니다.우리는 Angular로 Web Browser상에서 동작하는 Client가 사용하는 응용 프로그램을 만들어 낼 수 있습니다. 이런 프로그램은 사용자가 직접 접근할 수 있는 View라는 것을 가지고 동작합니다.전체 웹 어플리케이션 화면이 하나의 View가 될 수도 있고 어플리케이션 화면의 기능이나 목적에 따라 세부 View들로 분할 되어 웹 어플리케이션의 화면을 구성할 수 도 있습니다.예를 들면 다음과 같이 View를 분할해서 화면을 구성할 수 있습니다.( 이미지 출처 : https://msdn.microsoft.com )위의 그림에서 A는 로고영역, B는 사진에 대한 설명영역, C는 주 사진보기 영역, D는 컬렉션에 있는 다른 사진의 미리보기영역입니다.이렇듯 우리는 화면을 여러 View들로 분할해서 구성할 수 있다는 것이죠. 분할된 View들은 결국 Angular에서 Component의 단위가 됩니다.위의 그림은 View들이 화면을 분할하고 있는 형태입니다. 이렇게 할 수도 있지만 아래의 그림처럼 하나의 View안에 여러 View들을 넣어 화면을 구성 할 수도 있습니다. 파란색 View안에 2개의 빨간색 View가 들어가 있고 그 안에 다시 View들이구성되어 있는 형태입니다. 이렇게 View간의 포함관계가 성립될 수 있고 결국 View들간에 부모와 자식의 관계가 성립되게 됩니다.View는 결국 Component의 단위가 된다고 했으니 View들의 관계에 의해서 Component들도 부모와 자식간의 관계가 생기게 됩니다.이런 Component간의 관계가 크게 보면 tree모양으로 구성되게 되는데 이를 Component Tree라고 하는데 Angular의 중요한 개념 중 하나입니다.이 Component tree의 제일 위쪽에 위치한 Component를 우리는 Root Component라고 부릅니다.Component는 View를 rendering하는 주체가 되기 때문에 어떤 정보로 View를 rendering할 것인가에 대한 정보를 가지고 있어야 합니다. 이 정보를 우리는 Template이라고 합니다.TemplateTemplate은 View를 rendering하기 위해 필요한 HTML Element와 Angular의 문법요소 그리고 클라이언트 이벤트 처리 코드를 담고 있습니다.  Application 실행 시 Angular는 Component와 Template의 정보를 이용하여 View를 그리게 됩니다.( 이미지 출처 : https://angular.io/guide/architecture )Component - class기존에 만들어 놓았던 MySearchProject를 살펴보면서 코드상으로 Component를 이해해보죠. WebStorm에서 우리가작성한 프로젝트를 보면 src 폴더가 보입니다. 이 src폴더를 보면 index.html 파일이 존재하는데 이 파일이 우리 Web application의 시작 HTML파일입니다. 즉, http://localhost:4200 으로 접속하면 rendering되는 파일이 바로 이 index.html입니다.아래의 내용은 index.html 입니다.&lt;!doctype html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt;  &lt;meta charset=\"utf-8\"&gt;  &lt;title&gt;MySearchProject&lt;/title&gt;  &lt;base href=\"/\"&gt;  &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt;  &lt;link rel=\"icon\" type=\"image/x-icon\" href=\"favicon.ico\"&gt;&lt;/head&gt;&lt;body&gt;  &lt;app-root&gt;&lt;/app-root&gt;&lt;/body&gt;&lt;/html&gt;&lt;app-root&gt;&lt;/app-root&gt;라는 태그 대신에 특정 내용이 화면에 보이는 구조이군요. 즉, &lt;app-root&gt;&lt;/app-root&gt;가 하나의 View라는 의미입니다. 당연히 그에 대응되는 Component가 존재하겠네요.src/app 폴더에 보면 app.component.ts 파일이 있습니다. Component를 정의한 파일이고 TypeScript로 작성되어 있기 때문에확장자는 .ts를 이용합니다. 파일을 열어보면 다음과 같은 내용이 들어있습니다.import { Component } from '@angular/core';@Component({  selector: 'app-root',  templateUrl: './app.component.html',  styleUrls: ['./app.component.css']})export class AppComponent {  title = 'app';}코드에서 맨 마지막에 나타나듯이 Component는 class입니다. 하지만 class를 선언한다고 해서해당 class가 무조건 Component가 되는것은 아닙니다. 이 class가 Component로 사용된다는 것을 Angular에게알려주어야 Angular가 Component로 동작을 시킬수 있을 겁니다. 그래서 특정 표현을 이용해 해당 class가 Component임을 Angular에게 알려주어야 합니다.@Component라고 표현되는 부분이 바로 Component decorator입니다. 무언가와 많이 비슷하죠? 의미상 Java의Annotation과 하는일이 유사하다고 보시면 됩니다. class상단에 Component decorator를 이용해 Angular가 해당 class를 Component로인지할 수 있도록 합니다.@Component를 이용하려면 당연히 Component decorator를 사용할 수 있는 상태여야 하고 이 Component decorator는@angular/core라고 표현되는 Angluar Core Module Package에서 제공합니다. 해서 아래와 같은 코드가 필요합니다.import { Component } from '@angular/core';Component - Metadata위에서 Component decorator에 대해서 알아봤는데 이 Component decorator를 이용해 설정 정보를 Angular Framework에게전달할 수 있습니다. 이 설정정보를 Metadata라고 하며 다음과 같은 코드로 표현됩니다.@Component({  selector: 'app-root',  templateUrl: './app.component.html',  styleUrls: ['./app.component.css']})Component decorator안에 표현될 수 있는 Metadata는 상당히 종류가 많지만 필수요소는 없습니다. 하지만 selector와 template 정보는 존재하지 않으면 화면에 rendering이 되지 않기 때문에 필수요소라 볼 수 있습니다.      selector : template 코드안에서 해당 Component를 사용하고자 할 때 이용할 HTML Element명을 정의합니다. 위와 같은 경우 해당 Component는 &lt;app-root&gt;&lt;/app-root&gt; HTML Element로 사용될 수 있습니다.        template 정보 :  template 혹은 templateUrl을 이용할 수 있습니다. template은 View를 rendering할 때 필요한HTML을 inline형태로 직접 기술할 때 사용됩니다. templateUrl은 template code를 따로 HTML 파일로 분리해서 작성할 때 사용합니다.        style 정보 : styles 혹은 styleUrls을 이용할 수 있습니다. template 정보에 명시된 HTML에 대한 style을정의한 CSS가 inline형태 혹은 파일 형태로 포함될 수 있습니다. 여러 CSS 정의와 파일을 이용할 수 있기 때문에 배열형태로 표현합니다.  Module &amp; BootstrappingBootstrapping이란 browser에서 application이 최초로 실행될 때 진행되는 과정을 의미합니다. 우리가 작성한 Component는application이 bootstrapping될 때 Angular에 의해서 제어되게 됩니다.Angular에는 Module 개념이 있습니다. Module은 Application을 구성하는 단위로 관련된 요소를 하나로 묶어 놓은 것으로 생각하시면됩니다. Angular는 Module단위로 application 코드를 인식하기 때문에 모든 Angular application은 반드시 하나 이상의 Module을 가지게 되며 최상위 모듈을 우리는 Root Module이라고 부릅니다.  이러한 Module안에 Component와 같은 것들을 선언해 놓아야 비로소 사용할 수 있게 됩니다.Root Module은 관례상 AppModule이라 명하고 class로 표현하게 됩니다. src/app 폴더안에 app.module.ts 파일이 존재하는데이 파일안에 Root Module이 정의되어 있습니다.// BrowserModule은 Web Application인 경우 Root Module에서 // 반드시 import 처리를 해야 합니다.import { BrowserModule } from '@angular/platform-browser';import { NgModule } from '@angular/core';import { AppComponent } from './app.component';@NgModule({  declarations: [    AppComponent  ],  imports: [    BrowserModule  ],  providers: [],  bootstrap: [AppComponent]})export class AppModule { }  BrowserModule은 Web Browser를 위한 Module입니다. 지금 우리가 작성하는 프로젝트처럼 브라우저에서 동작하는Web Application인 경우 Root Module은 반드시 BrowserModule을 import해야 합니다.위의 코드에서처럼 AppModule class가 정의되어 있고상단에 @NgModule decorator를 이용하여 우리의 class가 Module임을 명시했습니다.import { AppComponent } from './app.component';위의 코드는 아까 살펴본 Component인 app.component.ts 파일로부터 AppComponent class를 import하는 부분입니다. 아까 위에서AppComponent class를 export 처리했던 걸 보셨을 텐데 이렇게 export된 class를 외부에서 import해서 사용할 수 있습니다..ts파일로부터 import를 할 경우 확장자인 .ts는 명시하지 않습니다. 이렇게 import한 class를 Module안에서 declarations를 이용해 선언해서 사용하게 됩니다.  declarations안에는 Component, Directive, Pipe에 대한 리스트가 선언됩니다. 이렇게 선언된요소만이 Module내에서 사용이 가능합니다.  imports안에는 의존 관계에 있는 Angular Library Module과 하위 Module, Routing Module,Ionic과 같은 Third Party Module이 포함됩니다.@NgModule decorator의 Metadata 중 bootstrap은 오직 Root Module만 가지고 있는 property입니다.application이 bootstrapping될 때 Root Module에 의해서 어떤 Component가 사용될 것인지를배열로 선언합니다. 즉, bootstrap은 browser가 최초로 index.html을 읽어들여 application을 시작할 때 사용할 Component를 명시하게 됩니다.@NgModule decorator의 Metadata에 사용되는 Component를 등록해 놓아야 우리가 작성한 Component의 TypeScript 코드를 browser에서 실행 가능한 JavaScript 코드로 compile해서 변환시킬 수 있습니다.마지막으로 src/main.ts 파일을 열어보면 다음과 같은 코드를 볼 수 있습니다.platformBrowserDynamic().bootstrapModule(AppModule)  .catch(err =&gt; console.log(err));Angular는 저 위의 코드로 AppModule을 읽어들이고 Module안에 등록된 여러 Component들을 JavaScript 코드로 compile하게되는 것 입니다.정리하자면 Root Module은 최상위 Module로 main.ts에 의해 bootstrap됩니다. 이 때 위에서 언급한 Component Tree의 최상위 Component인 Root Component가 Root Module에 의해서 bootstrap되는 것이지요. 따라서 모든 Angular 프로젝트는Root Module과 Root Component를 반드시 가지고 있어야 합니다.  지금까지 살펴본 것처럼 만약 Angular CLI를 이용하지 않으면 우리가 .ts 파일을 만들어서 등록하는 과정을 직접해야합니다. Angular CLI를 이용하면 기본 Skeleton 코드의 생성과 등록절차까지 자동으로 처리되게 됩니다.Component Tree사실 위에서 언급한 내용인데 중요한 부분이니 다시한번 정리하고 넘어가겠습니다.Angular application안에는 여러 View들이 존재할 수 있습니다. 개념적으로 하나의 View안에 여러개의 View들이 child형태로 존재할 수 있습니다. View는 Component와 대응된다고 했으니 결국 Component안에Component가 child형태로 구성될 수 있다는 의미겠네요.  이것을 우리는 Component Tree라고 합니다.그림으로 표현하자면 다음과 같이 표현될 수 있습니다.( 이미지 출처 : https://angular.io/guide/architecture )좀 어렵게 표현하자면 application의 화면구성을 끝내면 그 내용을 토대로 View를 결정해서 Component단위로 Modeling 해야합니다.이번 포스트에서는 Angular Component의 기본적인 사항에 대해서 알아보았습니다. 여기까지의 내용을 가지고 간단한 실습을 진행하면서 다른 사항들도 하나씩 알아보도록 하겠습니다. 실습을 진행하기에 앞서 Angular Material에 대해 먼저 알아보고 Material을 이용하여 우리 mySearchProject의 화면을 분할 하고 Component를 생성해 보는 실습을 진행하도록 하겠습니다.End.Angular 강좌는 아래의 책과 사이트를 참조했습니다.    조금 더 자세한 사항을 알고 싶으시면 해당 사이트를 방문하세요!!    Angular Official HomePage    Angular Material Official HomePage    Build a Mobile App with Angular 2 and Ionic 2    Angular 첫걸음 - 한빛미디어    제대로 배우는 Angular 4 - 비제이퍼블릭",
        "url": "/angular-lecture-component"
    }
    ,
    
    "angular-lecture-development-environment": {
        "title": "Angular 강좌(2) - 개발환경세팅",
            "author": "moon9342",
            "category": "",
            "content": "Angular 강좌는 여러 절로 구성되어 있습니다.     Angular 강좌(1) - Introduction    Angular 강좌(2) - 개발환경세팅    Angular 강좌(3) - Component    Angular 강좌(4) - Angular Material    Angular 강좌(5) - 실습(1)    Angular 강좌(6) - Data Binding    Angular 강좌(7) - 실습(2)    Angular 강좌(8) - Material Table    Angular 강좌(9) - 데이터공유(@Input)    Angular 강좌(10) - 데이터공유(@Output)    Angular 강좌(11) - 데이터공유(@ViewChild)    Angular 강좌(12) - 데이터공유(Content Projection)    Angular 강좌(13) - Service    Angular 강좌(14) - Service Mediator Pattern    Angular 강좌(15) - Service RxJS    Angular 강좌(16) - Material Table Event    Angular 강좌(17) - 중간 정리    Angular 강좌(18) - Directive    Angular 강좌(19) - Pipe    Angular 강좌(20) - Component LifecycleAngular 개발환경 - Node.js, WebStorm, TypeScript이번 포스트에서는 Angualr의 개발환경을 세팅하고 Angular CLI를 이용하여 기본적인 Hello World App을 생성, 실행하는 것까지 진행하도록 하겠습니다.제일 먼저 해야 할 일은 Node.js를 설치하는 것입니다. Angular CLI와 TypeScript가 node module로 존재하기 때문에npm을 이용하여 이 두가지를 설치해야 합니다.먼저 Node.js사이트에 접속해 LTS 버전이나 최신버전 둘 중 하나를 선택해다운로드 합니다. (어떤것을 설치해도 상관없습니다.)저는 LTS 버전으로 다운로드 했습니다. 다운로드가 끝나면 기본 형태로 설치를 진행합니다. 설치가 끝나면C:/Program Files/nodejs 폴더가 만들어지게 됩니다.이제 command 창을 열어서 다음과 같은 명령어를 실행합니다.  npmnpm(Node Package Manager)이 정상적으로 동작하면 이제 npm을 이용해 typescript를 설치할 수 있습니다.설치는 local mode와 global mode로 설치가 가능합니다. 여기서는 편의상 global mode로 설치합니다.global mode로 모듈을 설치하면 모든 프로젝트에서 사용가능한 형태로 시스템에 설치됩니다. local mode로 설치하면해당 프로젝트에서만 사용가능한 형태로 모듈이 설치 되게 됩니다. (일반적으로는 local mode를 선호합니다.)command 창에서 다음의 명령어를 실행해 typescript를 global mode로 설치합니다.  npm install -g typescripttypescript 2.6.2가 설치되었습니다.  global mode로 설치하면 windows 시스템을 기준으로 $USER_HOME/AppData/Roaming/npm/node_modules에 설치됩니다.이제 사용할 IDE(Integrated Development Environment)를 설치합니다. 여기서는 WebStorm(유료)을 이용합니다.Visual Studio Code(무료)를 사용하셔도 됩니다. WebStorm은 유료이지만 30일 trial을 사용할 수 있고 Student 라이선스를이용하면 1년간 무료로 사용할 수 도 있습니다. 개인적으로는 비용이 좀 들지만 WebStorm을 추천합니다. Front End 개발은 역시WebStorm이 편합니다. ( 사실 손에 익어서 그렇습니다. Visual Studio Code를 이용해도 아무 문제 없습니다. )JetBrains 사이트로 접속한 후WebStorm을 다운로드 받습니다.다운로드가 완료되면 기본형태로 설치합니다. 설치가 끝나면 프로젝트를 생성할 수 있는 화면이 나오게 되는데 일단 이 화면에서 대기합니다.프로젝트는 Angular CLI를 이용해서 생성합니다.Angular 개발환경 - Angular CLI일반적으로 Framework를 도입할 때 가장 힘든점 중 하나는 개발환경 구축입니다. 기본적인폴더구조를 숙지해서 만들어야 하고 기본적으로 사용되는 설정 파일들도 다수 존재합니다. 처음에는 대부분 뭐가먼지 알기 힘들죠.코드를 작성한 후 Build 설정, Bundler 설정, 테스팅과 배포등 너무 많은 일을 해야하고 설정방법 또한 복잡합니다.Angular 역시 마찬가지입니다. Mike Brocchi( Angular CLI contributor )의 Twitter 설문을 예로 들어보죠. 설문에서나온것처럼 초기 환경 세팅과 복잡성을 가장 큰 문제 중 하나로 여기고 있는걸 볼 수 있습니다.다행스럽게 Angular는 Angular CLI를 제공함으로 이런 복잡함을 해결하고 있습니다. Angular CLI를 이용할 경우와 그렇지 않는 경우를 간단히 그림으로 표현하면 다음과 같습니다.( 이미지 출처 : https://www.quora.com/What-is-Angular-CLI )Angular Project를 쉽게 생성하고 프로젝트를 시작하기 위한 scaffolding을 포함해서 다양한 기능을 제공하는 것이 바로 Angular CLI입니다. 사실 쓰지 않을 이유가 없습니다.그럼 Angular CLI를 설치해보도록 하죠. command 창을 열어서 다음과 같이 실행합니다.  npm install -g @angular/clinpm을 이용하여 Angular CLI를 global mode로 설치합니다. 설치하는데 시간이 좀 걸립니다. 설치가 끝나면 다음과 같이 실행해서 Angular CLI의 버전을 확인해 보세요.  ng --versionAngular 프로젝트 생성Angular CLI의 설치가 끝났으니 이제 Angular CLI를 이용하여 프로젝트를 하나 생성합니다. 프로젝트명은 mySearchProject로 하겠습니니다.프로젝트 폴더는 C:/mySearchProject로 생성할 것이기 때문에 저는 현재 command 창의 working directory를 C:/로 잡아놓고 다음과 같이 입력합니다.  ng new mySearchProject시간이 제법 오래 걸립니다. 필요한 의존 모듈들을 npm을 이용해 다운로드 받기 때문입니다. 프로젝트 생성이 끝나면자동으로 생성된 설정 파일과 기본 Skeleton 코드가 프로젝트 폴더안에 위치하게 됩니다. 만약 의존 모듈을 설치하지않고 프로젝트 기본 구조와 파일만 scaffolding할 목적이라면 --skip-install option을 이용하시면 됩니다.  Angular CLI는 나름대로의 Coding Convention을 가지고 있습니다. 그 규칙에 대해서는 나중에 다른포스트에서 알아보겠습니다.이렇게 Angular CLI를 이용해서 프로젝트를 생성할 수 있는데 이 프로젝트 구조와 Coding Convention이 Angular의 표준형태라고 보시면 됩니다.설정파일에 대한 내용은 나중에 다시 보기로 하고 일단 WebStorm으로 해당 프로젝트 폴더를 open합니다.아래의 그림처럼 WebStorm에서 프로젝트 폴더가 보이게 됩니다.기본적으로 Git Repository가 같이 생성됩니다. 꼭 그렇게 하실 필요는 없지만 가능한 Git과 GitHub를이용하여 Project의 버전관리를 하시는게 좋습니다.개발환경 서버를 이용한 Angular 프로젝트 실행command 창을 열어 프로젝트 root로 working directory를 이동시킨 후 다음의 명령을 실행하면 Webpack을 이용하여 우리 소스를 bundling하고 로컬 웹서버를 이용하여 우리 프로젝트를 서비스하게 됩니다.  ng serve명령 수행이 끝나면 webpack: Compiled successfully. 메시지가 출력됩니다. 이제 browser를 실행시켜 다음 URL로 접속해 정상적으로 출력되는지 확인하시면 됩니다.  http://localhost:4200참고로 아래와 같이 --o option을 이용해서 ng serve를 실행시키면 default browser를 실행시켜서 해당 URL에 접속해 결과를 쉽게 확인할 수 있습니다.  ng serve --o이번 포스트에서는 Angular application을 개발하기 위한 개발환경을 구축했습니다. 우리 강좌에서는 Testing과 관련된 사항은 다루지 않을 예정입니다. Testing과 관련된 사항은추후에 다른 포스트에서 다루도록 하겠습니다.이제 기본으로 만들어진 MySearchProject application을 조금씩 수정하면서 우리의 Angular 프로그램을 완성해 나가면 될 듯 합니다.End.Angular 강좌는 아래의 책과 사이트를 참조했습니다.    조금 더 자세한 사항을 알고 싶으시면 해당 사이트를 방문하세요!!    Angular Official HomePage    Angular Material Official HomePage    Build a Mobile App with Angular 2 and Ionic 2    Angular 첫걸음 - 한빛미디어    제대로 배우는 Angular 4 - 비제이퍼블릭",
        "url": "/angular-lecture-development-environment"
    }
    ,
    
    "angular-lecture-introduction": {
        "title": "Angular 강좌(1) - Introduction",
            "author": "moon9342",
            "category": "",
            "content": "Angular 강좌는 여러 절로 구성되어 있습니다.     Angular 강좌(1) - Introduction    Angular 강좌(2) - 개발환경세팅    Angular 강좌(3) - Component    Angular 강좌(4) - Angular Material    Angular 강좌(5) - 실습(1)    Angular 강좌(6) - Data Binding    Angular 강좌(7) - 실습(2)    Angular 강좌(8) - Material Table    Angular 강좌(9) - 데이터공유(@Input)    Angular 강좌(10) - 데이터공유(@Output)    Angular 강좌(11) - 데이터공유(@ViewChild)    Angular 강좌(12) - 데이터공유(Content Projection)    Angular 강좌(13) - Service    Angular 강좌(14) - Service Mediator Pattern    Angular 강좌(15) - Service RxJS    Angular 강좌(16) - Material Table Event    Angular 강좌(17) - 중간 정리    Angular 강좌(18) - Directive    Angular 강좌(19) - Pipe    Angular 강좌(20) - Component LifecycleAngular VersionAngualr의 History와 개요부터 간단하게 살펴보겠습니다.Angular는 JavaScript based Open Source Front End Web Application Framework 입니다.초기 버전인 AngularJS는 2010년 발표되었습니다. 지금은 Angular 1이라고 표현하기도 합니다. 버전 정책이 AngularJS 1.x로 올라가는 것이죠. 그렇게 발전해오다가2016년 9월에 Angular 2가 정식으로 release되었습니다. 그러면서 Angular 2라고 명시하지 않고 Angular라는 이름으로 호명하기로결정합니다. 지금 우리가 Angular라고 부르는 것은 모두 Angular 2 이후 버전입니다. 2017년 3월에 Angular 4가 release되었고 현재(2018년 1월)기준으로 Angular 5 까지 나온 상태입니다.  2017년 12월 3일부로 다음의 사항들이 정식으로 release되었습니다.      Angular 5.1.0    Angular CLI 1.6.0    Angualr Material    Angular Material CDK(component dev kit)  정리를 하자면 AngularJS라고 표현되는 Angular 1은 버전이 AngularJS 1.0, AngularJS 1.1, AngularJS 1.2, … 이렇게 올라가고 Angular라고 표현되는 Angular 2는 버전이 Angular 2.x.x, Angular 3.x.x, Angular 4.x.x, … 이렇게 올라갑니다. Angular 3는 Router issue때문에 release가 최소되었습니다. 그래서 Angular 2 다음 Major 버전이 Angular 4가 됩니다. 2017년 11월에 release된 Angular 5는 Angular 2의 3번째 Major 배포판 이라는 말이지요.Angular는 유의적버전(SemVer)을 도입해서 버전 체계를 Major.Minor.Patch로 표현합니다. 즉, Angular 5.2.4 이렇게 표현하는 것이지요. 6개월을 기준으로 1회의 Major, 3회의 Minor 그리고 주단위로 패치가 실시되고 있습니다. Major Release는 Breaking Change가 포함될 수 있습니다. Breaking Change란 이전버전과 호환성이 없는 변화를 지칭합니다. 따라서 시간이 좀 지나면 지금의 Angular와또 많이 다른 모습의 Angular가 될 확률도 있습니다. 물론 Google에서는 가능한 그런 경우를 없앤다고 발표했지만 모를일이죠.기존의 AngularJS와 지금의 Angular는 Architecture측면이나 구현측면에서 큰 차이가 있습니다. 그렇기 때문에 Angular 2 architecture가 발표되었을 때 많은 AngularJS 개발자들이 황당해 했던것도 사실입니다. 여하간 AngularJS는 역사속으로 사라지고 있습니다. 사실 Google에서도 AngularJS 시절에는 내부적으로 AngulraJS를 사용하지 않았습니다. 하지만 Angular로 넘어오면서 자사의 개발자체도Angular로 진행하고 있고 Angular를 단지 web framework에서만 사용하는 기술이 아닌 모든 platform에 대응할 수 있는 형태로 발전시키고 있습니다.  다음은 기존의 AngularJS와 지금의 Angular의 중요 차이점 중 몇가지 입니다.      AngularJS의 Controller와 $scope 기반 개발방식에서 Angular의 컴포넌트 기반 개발방식(CBD, Component Based Development)으로 개발방법 변경되었습니다.    Angular의 주력 개발 언어로 TypeScript가 도입되었습니다.    Angular는 개발환경 지원도구인 Angular CLI를 제공합니다.  이외에도 더 많지만 일단 저 위의 3가지만 기억하시면 될 듯 합니다. 저 위의 3가지로 인해 개발 생산성과 성능면에서 큰 향상을이루었습니다. 하지만 결정적(?)인 단점이 있습니다. Angular는 대부분의 browser를 지원하고 있는데 IE의 경우 9버전 이상부터 지원합니다. 따라서 Cross Browsing의 issue를 가지고 있습니다.아참..로고도 바꾸었습니다. 테두리가 있는 방패모양의 로고에서 테두리를 빼고 A글자를 흰색으로 바꾸었습니다. ^^;;( 이미지출처 : http://nodesimplified.com/angularjs-to-angular/ )이 링크를 클릭해 보시면 Angular의 버전 업데이트에 대한 ChangeLog를 확인할 수 있습니다. 일 무지 열심히 하네요. 따라가기 힘들정도입니다.Angular 학습을 위한 pre-requisiteAngular는 Steep Learning Curve를 가집니다. 배우기가 힘들다는 거죠. 적어도 기본적인 JavaScript 개발에 대한 지식과TypeScript에 대한 지식, 그리고 객체지향개발(OOP)에 대한 지식을 필수로 요구합니다. 물론 Angular를 배우면서 같이 하면 되긴 하지만 힘든건 사실입니다.해서 Angular 강좌 역시 기본적으로 다음과 같은 선행지식을 필요로 합니다.  JavaScript  TypeScript  OOP(Object Oriented Programming)  Front End 개발 도구 ( npm, babel, webpack, gulp 등등)참고로 이 링크에 가보시면 현재 Front End 개발환경에 대한 간단한 포스트를 보실 수 있습니다. 또한 이 링크에 가보시면 TypeScript에 대한 강좌 역시 보실 수 있습니다.말은 어렵다고 했지만 하다보면 또 그냥 저냥 하게 됩니다. 일단 기본적인 소개는 이정도로 하고 개발환경부터세팅해 보도록 하겠습니다.End.Angular 강좌는 아래의 책과 사이트를 참조했습니다.    조금 더 자세한 사항을 알고 싶으시면 해당 사이트를 방문하세요!!    Angular Official HomePage    Angular Material Official HomePage    Build a Mobile App with Angular 2 and Ionic 2    Angular 첫걸음 - 한빛미디어    제대로 배우는 Angular 4 - 비제이퍼블릭",
        "url": "/angular-lecture-introduction"
    }
    ,
    
    "typescript-class": {
        "title": "TypeScript 강좌(7) - Class",
            "author": "moon9342",
            "category": "",
            "content": "TypeScript 강좌는 여러 절로 구성되어 있습니다.    TypeScript 강좌(1) - Introduction    TypeScript 강좌(2) - Data Type(Part 1)    TypeScript 강좌(3) - Data Type(Part 2)    TypeScript 강좌(4) - 변수 선언    TypeScript 강좌(5) - Destructuring    TypeScript 강좌(6) - Interface    TypeScript 강좌(7) - Class TypeScript Class기존의 JavaScript는 재사용 가능한 component를 만들기 위해 함수와 prototype에 기반한 상속을 이용했습니다. 하지만기존 객체지향에 익숙해 있는 개발자들에게는 상당히 생소한 개념이었죠. 그래서 ECMAScript 2015( ES6 )에서는 개발자들이 좀 더 쉽게 JavaScript Application을 구현할 수 있도록 전통적인 class 기반의 객체지향 개념을 도입했습니다.TypeScript 역시 이 class기반의 객체지향 기법을 이용해 Application을 개발할 수 있습니다.일단 ECMAScript 2015( ES6 )의 class는 다음과 같이 정의하고 사용할 수 있습니다.class Book {    constructor(btitle,bauthor) {        this.btitle = btitle;        this.bauthor = bauthor;    }    printInfo() {        console.log(`제목: ${this.btitle}, 저자: ${this.bauthor}`);    }}let book = new Book('젊은 베르테르의 슬픔','괴테');book.printInfo();위의 코드는 data type의 정보를 포함하고 있지 않기 때문에 TypeScript로 변형하면 오류가 발생합니다.적절히 타입 정보를 포함해 코드를 수정하면 다음과 같습니다.class Book {    btitle: string;    bauthor: string;    constructor(btitle:string, bauthor:string) {        this.btitle = btitle;        this.bauthor = bauthor;    }    printInfo(): void {        console.log(`제목: ${this.btitle}, 저자: ${this.bauthor}`);    }}let book:Book = new Book('젊은 베르테르의 슬픔','괴테');book.printInfo();위의 코드는 Java에서 우리가 익히 보아왔던 class의 형태입니다. 생성자를 표현하는 부분이 좀 생소하지만 쉽게이해할 수 있을 듯 합니다. Inheritance일반적인 객체지향언어의 Inheritance 개념 역시 TypeScript에도 사용할 수 있습니다. 다음의 코드를 보죠.class Book {    btitle: string;    bauthor: string;    // 상위 클래스의 생성자    constructor(btitle:string, bauthor:string) {        this.btitle = btitle;        this.bauthor = bauthor;    }    // 상위 클래스의 method    // 입력 인자가 있으면 사용하고 없으면 default 사용    printInfo(input:string = 'Initial'): void {        console.log(input);        console.log(`제목: ${this.btitle}, 저자: ${this.bauthor}`);    }}// class의 상속class EBook extends Book {    btype: string;    constructor(btitle:string, bauthor:string, btype:string) {        // 상위 class 생성자 호출        super(btitle, bauthor);        this.btype = btype;    }    // method overriding    printInfo(): void {        // 상위 class의 method 호출        super.printInfo();        console.log(`제목: ${this.btitle},                      저자: ${this.bauthor},                     타입: ${this.btype}`);    }}// IS-A relationship에 의한 상위 class type 사용let book:Book = new EBook('젊은 베르테르의 슬픔','괴테',    'PDF');// dynamic binding에 의한 overriding method 호출.book.printInfo();기존 class를 확장하여 새로운 class를 정의하는 방법입니다. IS-A Relationship 역시 성립합니다. 그로 인한상위 타입으로 객체를 사용할 수 있습니다. 또한 위의 예에서 처럼 method overriding의 개념 역시 존재하고 dynamic binding 개념 역시 존재합니다. 물론 TypeScript에서는 공식적으로 저 용어를 사용하지는 않습니다.다만 우리가 Java언어에서 알고 있던 객체지향 개념이 그대로 TypeScript에도 일부 적용된다고 보시면 됩니다. Access ModifierTypeScript는 3가지 종류의 접근제어 연산자를 제공합니다. 우리에게 익숙한 public, protected, private 키워드로 제공되며 default값은 public입니다. 즉, Access Modifier를 명시하지 않으면 모두 public으로 간주됩니다.  public : 접근제한이 없습니다. class외부에서 자유롭게 접근이 가능합니다.  protected : class 외부에서 접근할 수 없습니다. 단, 상속받은 하위 class에서는 접근이 가능합니다.  privatre : class 외부에서 접근할 수 없습니다. 상속받은 하위 class에서도 접근이 불가능합니다.class Book {    protected btitle: string;    public constructor(btitle:string, private _bauthor:string) {        this.btitle = btitle;    }    public printInfo(): void {        console.log(`제목: ${this.btitle}, 저자: ${this._bauthor}`);    }    // private property인 _bauthor의 getter    get bauthor(): string {        return this._bauthor;    }    // private property인 _bauthor의 setter    set bauthor(value: string) {        this._bauthor = value;    }}class EBook extends Book {    private btype: string;    public constructor(btitle:string, bauthor:string, btype:string) {        super(btitle, bauthor);        this.btype = btype;    }    public printInfo(): void {        console.log(`제목: ${this.btitle},                      저자: ${this.bauthor},                     타입: ${this.btype}`);    }}let book:Book = new EBook('젊은 베르테르의 슬픔','괴테',    'PDF');book.printInfo();위의 예제에서는 다음의 코드를 주의해서 보아야 합니다. 생성자의 인자로 private _bauthor:string라고 선언된 부분이 보입니다.    protected btitle: string;    public constructor(btitle:string, private _bauthor:string) {        this.btitle = btitle;    }생성자에 인자를 명시할 때 access modifier를 같이 명시하면 위의 예처럼 명시적으로해당 property가 선언되어 사용할 수 있게 됩니다.일반적으로 private property의 이름은 앞에 _를 관용적으로 써주게 됩니다. 이렇게 사용하는 이유는관용적 coding convention 때문에 그렇습니다. ECMAScript에서는 개발자들이 private의 의미로 사용되는property에 일반적으로 _를 붙여서 사용했었습니다.또 다른 이유는 setter와 getter의 이름때문에 그렇습니다. 다음의 코드에서 보듯이 TypeScript에서 getter와 setter의 표현은 우리가 알고 있는 다른 언어의 getter, setter와 다릅니다. 그리고 이렇게선언된 getter와 setter가 어떻게 사용되는지도 유의해서 보시기 바랍니다.    // private property인 _bauthor의 getter    get bauthor(): string {        return this._bauthor;    }    // private property인 _bauthor의 setter    set bauthor(value: string) {        this._bauthor = value;    } Readonly Propertyclass의 property를 readonly로 지정할 수 있습니다. readonly로 지정되면 property가 선언될 때 혹은 생성자안에서반드시 초기화를 진행해야 합니다. 다음의 예제를 참고하시면 됩니다.class Book {    public readonly btitle: string;    constructor(btitle: string) {        this.btitle = btitle;    }}let book:Book = new Book('젊은 베르테르의 슬픔');book.btitle = '파우스트';   // 코드 에러다음의 예제처럼 생성자의 parameter를 readonly로 선언하면 따로 class의 property로 선언할 필요가 없습니다.class Book {    constructor(readonly btitle: string) {        this.btitle = btitle;    }}let book:Book = new Book('젊은 베르테르의 슬픔');console.log(book.btitle); Static Propertystatic 키워드 역시 사용할 수 있습니다. ECMAScript 2015에서는 static을 method에만 적용할 수 있었지만TypeScript는 property에도 적용할 수 있습니다. static property는 class의 이름으로 직접 access를 할 수 있습니다.class Book {    public btitle:string;    static count: number;    constructor(btitle: string) {        this.btitle = btitle;        Book.count++;    }}let book1:Book = new Book('젊은 베르테르의 슬픔');let book2:Book = new Book('파우스트');console.log(Book.count); Abstract Classabstract class는 하나이상의 abstract method를 가지고 있는 class를 의미합니다. method의 선언만을 가지고 있기때문에 직접적인 객체생성을 할 수 없고 상속을 이용해 하위 클래스에서 abstract method를 overriding해서 사용하게 됩니다.abstract class Book {    public btitle:string;    constructor(btitle: string) {        this.btitle = btitle;    }    abstract printInfo(): void;}class EBook extends Book {    printInfo(): void {        console.log(this.btitle);    }}let book:Book = new EBook('젊은 베르테르의 슬픔');book.printInfo(); interface의 의미로 class사용이 부분은 기존의 다른 언어와 다릅니다. class를 확장해서 interface를 정의할 수 있습니다. 다음의 코드를 참조하세요class Book {    btitle: string;}interface EBook extends Book {    bauthor: string;}let book:EBook = {    btitle: '파우스트',    bauthor: '괴테'};이번 포스트에서는 TypeScript의 class에 대해서 살펴보았습니다. 객체지향 언어의 class와 상당히 유사하면서도약간의 차이점이 있었습니다. 차이점 위주로 기억하시면 될 듯 합니다.End.이 포스트의 내용은 아래의 사이트를 참조했습니다. 조금 더 자세한 사항을 알고 싶으시면    해당 사이트를 방문하세요!!    TypeScript Official HomePage",
        "url": "/typescript-class"
    }
    ,
    
    "front-end-ecosystem": {
        "title": "Front-End 발전 역사와 개발 생태계",
            "author": "moon9342",
            "category": "",
            "content": "Introduction이번 포스트는 과거 JavaScript 탄생부터 시작해서 어떻게 발전해왔는지에 대한 내용과 현재 Front End 개발에 있어서 무엇을 알아야 하는 지에 대한 전반적인 기술 상황에 대해서 알아보겠습니다. JavaScript 탄생JavaScript라는 언어의 역사는 저의 다른 포스트에서도 볼 수 있지만 여기서도 간단하게 언급하고 넘어가겠습니다.JavaScript언어의 역사는 1995년 Netscape사의 Brendan Eich(브랜든 아이크)에 의해 개발된 Mocha라는 언어부터 시작됩니다.이 Mocha라는 언어는 “Prototype의 개념과 Functional Language(함수형 언어)의 특성을 가지고 Web에 동적으로 활용할 수 있는 언어를 만들어보자” 라는 취지로 2주일 이라는 굉장히 짧은 기간안에 만들어졌습니다.추후에 Mocha -&gt; LiveScript -&gt; JavaScript로 개명되었고 ECMA에 ECMA-262 기술규격으로 ECMAScript라는 이름으로 표준화를진행하게 됩니다. 이에 대응해 1996년 MicroSoft 측에서는 JScript라는 걸 만들어내서 자사의 IE 3안에 포함시켜 제공하기 시작했습니다.이런 JavaScript는 여러가지 문제점을 내포하고 있었는데 가장 큰 문제를 꼽자면  구현의 어려움  언어의 모호성  Cross Browsing의 한계정도를 들 수 있습니다. 즉, 사용자 입력값을 검사하는 용도, 사용자의 이벤트를 감지해서 처리하는 용도로는 사용할 수 있지만 언어 자체가 가지고 있는 근본적인 문제때문에 사용이 힘들었습니다. 구세주의 등장 - jQuery이 때 구세주가 등장합니다. 우리가 잘 알고 있는 jQuery library입니다.jQuery는 open source javascript library로 순수 javascript가 가지고 있었던 DOM처리의 어려움과 Cross Browsing에 대한 issue를해결하면서 JavaScript의 대표적 library로 사용되게 되었습니다. jQuery로 인해 JavaScript가 조금은 쓸만한 언어로 여기지면서사용되기 시작했습니다.그러면서 그냥 그냥 아주 소소하게 client web browser안에서 JavaScript 코드와 jQuery 코드가 이용되었던 거지요. 특별히 중요하지도 않은단위코드 위주로 사용이 되는 그런 수준이었습니다. 그러면서 우리 기억에도 “알면 좋고 몰라도 상관없는 언어”로 인식되었습니다.그렇게시간은 흘러갑니다.!!1997년 ECMAScript의 초판이 나오게 됩니다. ES1이라고 합니다. 그 후 1999년에 ES3가 나오게 됩니다. 여기까지 하고 한동안ECMAScript 표준은 쿨쿨 잠을 자게 됩니다. 다시 JavaScript에 날개를 달아보자 - HTML51999년 12월 W3C(World Wide Web Consortium)에서 하나의 발표를 합니다. 아시다시피 W3C는 HTML과 CSS의 표준을 관장하는 기구입니다. 이때까지 우리가 사용하는 HTML의 버전은 4.01버전이었습니다. W3C는 이 버전을 마지막으로 더 이상 HTML의 버전업은 없을 것이라고 공표하게 됩니다. 그때까지 잘 사용해왔던 HTML을 왜 버전업하지 하지 않겠다고 했을까요?여러가지 이유가 있지만 프로그래밍 언어의 측면에서 바라보면 HTML이란 언어는 다음과 같은 한계점이 있습니다.  정형성 : HTML언어는 정형성이 없기때문에 유지보수에 적합하지 않다.  확장성 : 정해진 Tag만 이용하기 때문에 언어자체에 대한 기능적 확장이 어렵다.W3C는 저 두가지 이유를 들어 HTML언어를 이대로 끌고 가기 보다는 좀 더 다른 수단을 강구해야 겠다고 판단합니다. W3C의 선택은바로 XML의 도입이었습니다. 즉, HTML이 가지는 두가지 문제점을 해결할 수 있는 XML을 도입해서 새로운 Web언어의 표준을끌고 나갈 생각이었습니다. 그 결과 2000년 들어오면서 HTML과 XML이 결합된 새로운 표준인 XHTML 1.0이 발표되게 됩니다.W3C의 이런 의도와는 다르게 몇몇개의 회사들이 모여서 조금 다른 접근을 모색합니다. XML을 도입하지 말고 순수하게 HTML을 기능을버전업시킬 수 있는 방법을 찾기 시작한 것이죠. 그래서 WHATWG(Web Hypertext Application Technology Working Group)이라는 Working Group이 만들어지고 이 안에서 기존의 HTML을 발전시킬 방법을 연구하게 됩니다. ( 사실 여기서 할 말이 많기 한데 자꾸 산으로 가는 느낌이라 적당히 짜르겠습니다. ) 이 WG에서 나온것이 바로 현재의 표준인 HTML5입니다. HTML을 이용해서 Web Application을 만들자는 취지입니다. 이 HTML5안에 Client Web Application을 작성할 수 있는 API가 포함되어 있는데 이게 JavaScript로되어 있습니다. 결국 HTML5가 issue화 되면서 JavaScript의 위상도 조금씩 더 올라가게 됩니다.그래서인지 쿨쿨 잠을자던 ECMAScript 개정판(ES5)이 2009년에 등장합니다. 참고로 4판(ES4)은 버려졌습니다. 이제 슬슬JavaScript에 대한 발전이 시작됩니다. JavaScript의 획기적 전환점 - Node.js2013년 Node.js가 출시됩니다. 아무리 HTML5라고 해도 이때까지의 JavaScript는 Browser안에서 동작하는 언어였습니다.우리가 알고 있는 Java, C#과 같은 언어가 될 수 없는 태생적 한계가 있는거죠. 이런 browser에 갇힌 JavaScript를browser 외부로 탈출하게끔 만들어준 일등공신이 바로 Node.js입니다. 결국 JavaScript로 다른 언어처럼 OS위에서 동작하는일반 application을 작성할 수 있는 길이 열린것이고 그에 따라 언어의 위상이 완전히 변했습니다.그에 발맞춰 ECMAScript도 빠르게 변화하기 시작했습니다. 2015년에 ECMAScript 2015(ES6)가 등장하면서 JavaScript 언어자체에아주 큰 변화들이 많이 생겼습니다. 현재 ECMAScript 2016(ES7)까지 나온 상태입니다. 조금 지나면 ES8이 표준화되어서 나오겠네요.거의 1년마다 새로운 배포판이 나올정도로 빠르게 변화하면서 언어적 측면에서 가지고 있던 많은 문제점들을 극복하려고 노력하고 있습니다.현재(2018년 1월) 대부분의 browser들은 ES6를 지원하고 있습니다. 여기에 접속해 보시면 특정 browser에 대해 각 ECMAScript의 버전 호환성을 보실 수 있습니다.  이제 IE는 고만쓰도록 해요. 제발….아직 완벽하게 Cross Browsing이 안되는데 어떻게 하느냐에 대한 문제는 Babel, TypeScript와 같은 transpiler를 이용해서 해결할 수 있습니다. Babel, TypeScript는 ES6(ES7) 문법으로 쓰여있는 JavaScript code를 ES5 형태의 JavaScript로 변환시켜주기 때문에 IE에서 ES6지원이 안됨에도 불구하고 ES5로 변환해서 사용할 수 있습니다. 변화의 속도가 너무 빠름그런데 문제는 기술의 발전 속도가 너무 빠르다는데 있습니다. 또한 알아야 할게 한두 가지가 아니구요. 과거 Back End에서 사용했던 프로그래밍 기술과 여러가지 개발 툴의 개념들이 다 Front End로 넘어왔기 때문입니다.너무 많은기술들이 빠르게 생기고 빠르게 사라지고 있습니다.사실 2-3년전에 자주 사용했던 JavaScript Library와 Framework들 중 많은 것들이 이미 다른 것으로 대체되었습니다. 그렇다고 손 놓고 있을 순 없으니 현재 상태에서 우리가 Front End 개발을 하기 위해 필수적으로 알아야 하는 것 몇가지만살펴보도록 하겠습니다. 이것정도는 알고 가자  Package Manager : NPM, Yarn외부 라이브러리를 사용할 경우 해당 라이브러리를 설치, 삭제, 의존성 관리등을 해야 하는데 이를 위한 도구가 몇몇 존재합니다. 그중 하나만 하자면 당연 npm입니다. Node Package Manager의 약자이고 Node.js를 살짝 맛보시면npm이 어떻게 동작하는지 아실 수 있습니다. 굳이 Node.js에 대해서 학습할 필요는 없습니다. 당연히 알면 좋지만요.  Transpiler : Babel, TypeScript( 이미지 출처 : http://news.softpedia.com/news )Cross Browsing을 위한 Transpiler입니다. 비교 대상은 아닙니다. 둘 다 알아둘 필요는 있지만 저는 TypeScript는 반드시 해야 한다고 생각합니다. 앞으로 TypeScript는 더 발전할 듯 보이거든요. 하지만 배우기 쉽지 않습니다. 언어적 측면을 파고 들면 내용이 꽤나 많습니다.다행히 TypeScript는 ECMAScript의 superset이니 ECMAScript 공부한다고 생각하시면 속 편합니다.또한 제 개인적인 생각과는 반대로 TypeScript언어의 단점도 분명히 존재합니다. 엄격한 type checking덕분에JavaScript가 가지는 프로그래밍의 유연함이 많이 떨어진다는 것이죠.  자동화 도구 : Grunt, Gulp빌드, 테스트, 배포등을 위한 자동화 도구입니다. 과거에는 Grunt를 많이 사용했지만 현재는 Gulp인듯 합니다. 시간 좀 지나면 Gulp도 Grunt와 마찬가지로 역사속으로 사라지게 되겠지만 지금은 Gulp가 대세입니다.  module bundler : webpack, rollup코드 재사용을 위한 모듈화 도구들과 bundler 역시 여러가지 있는데 요즘 많이 사용하는 건 webpack입니다.ES6 들어오면서 언어적 차원에서 Module을 지원하기 시작했고 이런 Module들을 하나로 모아 Packaing하는 작업이필요하게 되었습니다. 이를 위한 도구 역시 발전을 하고 있구요. 과거에는 Common.js, Require.js를 이용하여처리했다면 최근에는 webpack, rollup을 이용하여 처리합니다.  Framework &amp; Library : Angular, React, Vue.js우리의 목적은 사실 저 위의 3가지를 배우는 것입니다. 각기 나름대로의 장점과 특징들을 가지고 있습니다. 개인적으로는 블로그내에 저 세가지의 강좌를 개설하는게 2018년 상반기의 블로그 목표입니다. 대세는 Angular이지만 React의 성장세역시 가히 폭발적입니다. 아직까지(2018년 1월기준) Vue.js는 Angular와 React 만큼의 성장세는 보이지 않고 있지만 이 역시 어떻게 될지는모를일이죠 정리위에서 “이것정도는 알고가자”라고 했지만 그 내용을 전부 다 알고 있으면 상당한 경험과 실력을 가진Front End 개발자일 것입니다. 또 위에 포함을 안했지만  Git같은 것은 기본적으로 숙지해야 할 것이구요. 할게 너무 많네요천천히 하나씩 해보도록 하죠 머…그리고 “이것정도는 알고가자”에서 제가 강조한 것들은 제가 현재 사용하는 것들입니다.그것들이 더 좋다는 보장은 어디에도 없습니다. 자기 손에 익숙한게 최고입니다. ^^End.",
        "url": "/front-end-ecosystem"
    }
    ,
    
    "continuous-integration": {
        "title": "What is Continuous Integration?",
            "author": "moon9342",
            "category": "",
            "content": "IntroductionCI는 Continuous Integration의 약자로 우리나라 말로 굳이 번역하자면 “지속적인 통합” 정도가 되겠네요.여기서는 간단하게 Continuous Integration이 어떤 개념인지 살펴보도록 하겠습니다. CI(Continuous Integration)란 무엇인가?소프트웨에 개발은 다음과 같은 라이프 사이클을 가지고 있습니다.  계획 =&gt; 요구사항 분석 =&gt; 설계 =&gt; 코드화 =&gt; Build =&gt; Testing =&gt; Release =&gt; Deploywaterfall 방식으로 한 단계가 끝나면 다음 단계로 이동하기도 하지만 일반적으로는 프로젝트가진행되는 동안 이 안의 단계가 반복적으로 실행되게 됩니다.하지만 우리는 코드를 작성한 후 통합 Build작업과 통합 Test작업을 하지 않고 넘어가는 경우가 많습니다. 가장 큰 이유는 Build작업과 Test작업에 시간이 오래 걸리고 만약 중간에 문제가 발생하면 이걸 수정하는게 쉽지 않고 결국 또 시간을 잡아먹게 되기 때문이죠. 심한경우 프로젝트의 중반 이후에 개별적으로 작성한 코드를 통합 build하고 Test하는 경우도 있습니다. 이런 경우 소프트웨어 통합작업은 결국 산으로 올라가게 됩니다.Continuous Integration은 이런 문제점을 해결하기 위해 코드를 최대한 자주 통합하여 개발하는 소프트웨에 개발 방법론중의하나라고 볼 수 있습니다. 이런 CI를 도와주는 여러가지 툴들이 존재하는데 이를 이용하면 통합 시 필요한 여러가지 자잘한(?) 문제들을 자동화시켜서 최대한 빨리 오류를 발견하고 문제를 해결해 나갈 수 있습니다. 결과적으로는 상당히 품질이 좋은 소프트웨어를개발할 수 있게 되는 거지요.그림으로 표현하면 아래와 같이 단순하게 표현할 수 있겠네요.( 이미지 출처 : https://blog.snap-ci.com/categories/continuous-integration )사실 더 복잡하지만 위의 그림처럼 단순하게 바라보시면 될 듯 합니다. CI Server가 통합된 코드를 자동으로 Build-Test-Release-Deploy까지 진행하고 그 결과를 개발자나 다른 관련있는 사람에게 알려주게 됩니다.CI Server가 일련의 과정을 자동으로 처리해 줌으로써 개발자는 Business Logic 작성에 더 집중할 수 있고 오류에 대한 내용도 빨리수정을 할 수 있습니다. 일반적으로 Git과 같은 VCS(Version Control System)과 연계해서 사용하게 됩니다.현재 많이 사용되는 CI 제품들은 다음과 같습니다.      Jenkins : Java로 작성된 open source CI tool입니다. open source CI 진영에서는 압도적 사용자를 보유하고 있습니다. Java 개발자들에겐 진리입니다. 설치형이기 때문에 설정이 조금 복잡합니다.        Travis CI: Github와의 편한 연동 및 public repository에 대해서는 무료로 사용할 수 있다는 장점이 있습니다. 설정이 Jenkins만큼복잡하지 않고 Travis Server를 이용하여 동작시키는 것이기 때문에 편합니다. private repository에 대해서는 일정량의 비용을 지불해야합니다.        TEAMCITY, BAMBOO, GITLAB CI, CIRCLECI, CODESHIP 등등이 있습니다. 이놈들은 저도 써보질 않아서 할말이 없네요.  간단하게 CI의 개념에 대해서만 살펴보았습니다. Travis CI와 같은 것은 사용하기 그리 어렵지 않으니 한번 사용해 보시면 느낌이 확오실겁니다.End.",
        "url": "/continuous-integration"
    }
    ,
    
    "architecture-platform-terminology": {
        "title": "Library, Framework, Architecture, Platform",
            "author": "moon9342",
            "category": "",
            "content": "IntroductionLibrary, Framework, Architecture, Platform은 우리가 너무나 많이 들어본 용어이고 그 의미도 대충 알고 있습니다. 하지만 명확하게 설명해봐!! 라고 한다면 주춤 주춤하게 만드는 용어이기도 합니다.이번 포스트는 저 위에 나열된 4개의 용어에 대한 간략한 정리입니다. Library가장 쉬운 개념입니다. 일반적으로 Library는 다른 프로그램에서 링크 되기 위해 사용되는 하나 이상의 function 혹은 class들의 집합이며 이들은 일반적으로 파일형태로 존재합니다.Library를 사용하는 가장 큰 목적은 코드의 재사용성을 높이기 위함이지요. 자주 사용되는 기능들은 매번 새롭게 작성하지 말고 function이나 class 형태로 만들어 놓고 필요할 때 그 기능을 쉽게 불러다가 사용하자는 개념입니다.      Library의 가장 간단한 예로는 jQuery가 있습니다. Front-End 작업을 할 때 DOM 구조에서 내가 원하는 Element를 빠르고 쉽게 찾아 DOM 에서 제거하고 싶을 때 jQuery Library를 이용하면 단 1줄에 해결할 수 있습니다. 순수 JavaScript로 작업하려면 많은 양의 복잡한 코드를 직접 작성해야 합니다.        Java에서 사용하는 여러 외부 class 역시 모두 Library입니다. Java에서 랜덤값을 얻고싶을 때 우리는 Random class를이용해 instance를 생성하고 method를 호출해서 간단하게 원하는 범위의 랜덤값을 도출할 수 있습니다. 만약 Library를이용하지 않고 랜덤값을 구할려면 역시나 복잡한 로직과 연산을 우리가 직접 구현해야 됩니다.        비슷한 예로 Java에서 JSON 데이터를 처리할 때 역시 특정 Library class를 이용하면 쉽게 처리할 수 있습니다. 가장 대표적인 Library는 Jackson이 아닐까 합니다. 이 Library class들을 이용하면 프로그램에서 JSON 데이터를 아주 쉽게 핸들링 할 수 있습니다.  이렇듯 Library는 프로그램을 작성할 때 필요한 단위 기능을 모아놓은 모듈이라고 볼 수 있습니다. PlatformPlatform은 “Software를 실행시킬 수 있는 실행환경(Runtime Environment)”을 의미합니다.예를 들어 보자면, 우리가 사용하는 모든 OS(Operation System)는 모두 Platform입니다. Windows Platform은windows 응용 프로그램을 실행시키기 위한 실행 환경이고 Linux Platform은 Linux 응용 프로그램을 실행시키기 위한실행 환경이란 말이지요.Java 배울 때 처음에 JVM(Java Virtual Machine)이란 걸 배우게 됩니다. 우리가 작성한 모든 Java 프로그램은 JVM위에서 동작하게 됩니다. 다시 말하면 JVM은 Platform입니다. Java 프로그램을 실행시켜 줄 수 있는 실행 환경이란 말이지요.개념적으로 본다면 우리가 사용하는 Web이라는 서비스 역시 Platform 범주에 들어가게 됩니다. 정확하게는 Web 이라는 서비스가 아닌Web Server와 Web Client(browser)로 구성되는 실행환경이 우리가 작성한 Front-End Web Application이 실행되는 Platform 이라볼 수 있습니다.Java의 예에서 알 수 있듯이 Platform은 Hierarchical 구조를 가질 수 있습니다. 제일 하단에 OS Platform이 있고 그 위에 JVM이실행되는 것이죠. 다시 JVM은 Java 프로그램을 실행시킬 수 있는 Platform이 되고 그 위에 사용자가 작성한 Java 프로그램이실행되는 것입니다. Architecture알고는 있지만 딱히 설명하라면 어버버하게 만드는 개념입니다. Architecture는 소프트웨어의 특징을 결정짓는 설계 구조입니다. 말이 좀 어렵습니다.Architecture는 다음과 같은 내용을 포함합니다.      소프트웨어의 주요 구성 요소에 대한 정의가 포함됩니다. 소프트웨어의 주요 구성 요소란 소프트웨어를 구성하고 있는 컴포넌트 혹은 모듈을 의미합니다. 어떤 기능의 컴포넌트들이 소프트웨어에 필요한지를 구상해서 구성 요소를 정의합니다.( View Component, Service Component, Database Component, Transaction component, Message Component 등등)        이런 소프트웨어 주요 구성 요소들 간에 어떤식의 구성이 이루어지고 있는지 정의합니다. 한 컴포넌트가 다른 컴포넌트와 어떤 관계로 연결되는지에 대한 정의를 지칭한다고 보시면 됩니다. 일반적으로 유지보수성을높이기 위해 Layered Model을 기반으로 컴포넌트간의 연결 관계를 정의합니다.        결국 소프트웨어의 주요 구성 요소들 간에 연관관계가 맺어지는데 이들 간의 상호 인터페이스는 어떻게 할지를 정의합니다. 어떤 값이 넘어가고 이 값을 받아서 결과값으로 어떤 값을 리턴해주는지에 대한 명세를 포함합니다.        소프트웨어의 주요 구성 요소가 하는 중요한 동작 방식을 정의합니다.  위와 같은 내용으로 Architecture를 이해하시면 됩니다. Architecture는 결국 소프트웨어의 주요 특징을 결정하기 때문에 개발에 미치는 영향이 아주 높은 상당히 중요한 부분이라 볼 수 있습니다.Architecture에 대해 한가지 더 기억하셔야 할 점은 Architecture는 구체적인 구현을 포함하지 않습니다. 즉, 어떤 프로그래밍 언어를 사용할 것인지, Library는 어떤것을 사용할 것인지, 개발 지원 프로그램은 어떤것들을 이용할 것인지에 대한 내용은 Architecture에는 포함되지 않습니다. 하지만 특수한 경우 Architecture안에 구체적인 표현이 포함 될 수는 있습니다. 하지만 본질적으로 Architecture는 기술적인 설계를 명시하는 것이지 구체적인 구현 방법은 포함하지 않습니다. FrameworkFramework은 소프트웨어 프로젝트가 개발 될 수 있는 뼈대 구조를 지칭합니다. 역시 말이 좀 어려운데요. 다음과 같은 사항을포함합니다.  소프트웨어 개발시 필요한 지원프로그램  Library (Framework은 Library를 포함하는 상위개념입니다.)  프로그래밍 언어  소프트웨어 구성 요소들을 연결시켜주고 동작시켜주는 소프트웨어(일반적으로 Container라고 합니다.)Framework은 소프트웨어 구성 요소들이 어떻게 동작하는지에 대한 규약이 정해져 있습니다. 이 규약대로프로그램은 진행이 될 것이고 프로그래머는 기능 구현에만 초점을 맞추어 빠르게 개발을 진행 시킬 수 있습니다.Framework 도입의 가장 큰 목적 중 하나는 바로 유지보수입니다. 정해진 규칙대로 프로그램이 동작하고 작성되어야 하다보니다른 사람이 프로그램을 분석하는데 시간이 오래 걸리지 않고 유지보수하는것도 상대적으로 쉽게 진행이 됩니다. Library를기반으로 하는 프로그램은 모든 로직을 개발자가 직접 구현하기 때문에 다른 개발자가 유지보수하기 쉽지 않은 것에 비해Framework은 이런 유지보수 측면에서 강점을 가질 수 있습니다.개발 시 기본 골격이 되는 프로그램 코드가 제공되는것이 일반적인데 이 또한 Framework의 특징이라고 할 수 있습니다.( Scaffolding 이라고 합니다. )Framework부분은 사실 더 써야 하는 사항이 많습니다. 하지만 차이점 위주로 살펴본 것이니 위의 내용 정도만이해해도 충분하지 않을까 합니다.End.",
        "url": "/architecture-platform-terminology"
    }
    ,
    
    "browser-detect-script": {
        "title": "클라이언트 Browser 확인방법",
            "author": "moon9342",
            "category": "",
            "content": "Introduction사이트에 접속한 Client Web Browser의 종류를 알아내는 방법입니다. Client Browser를 확인하기 위한 JavaScript code제 블로그는 Chrome 전용입니다. IE를 이용하면 화면이 보란듯이 깨지게됩니다. 그래서 접속한 client의 browser를 알아내서 만약 chrome이 아니면 안내를 해 줄 필요가 있습니다.  실제 업무에서는 당연히 cross browsing을 염두에 두고 작업을 해야되겠죠?다음과 같은 JavaScript 코드를 이용하시면 됩니다.var agent = navigator.userAgent.toLowerCase();if (agent.indexOf(\"chrome\") != -1) {        alert(\"Chrome browser\");}if (agent.indexOf(\"safari\") != -1) {        alert(\"Safari browser\");}if (agent.indexOf(\"firefox\") != -1) {    alert(\"FireFox browser\");}JavaScript의 navigator객체를 조사하면 browser의 종류를 판별할 수 있습니다. IE 10까지는 저 위의 방법으로 알아낼 수 있으나 Edge와 그 이후 버전은 이름이 또 바뀌어서 다른 식으로 판단해야 합니다. 전 IE는 관심밖이라… userAgent 객체의 값 확인위의 방법은 가장 간단한 방법 중 하나입니다. Mobile browser까지 생각한다면 경우의 수가 훨씬 더 많아지겠죠.특정 사이트와 Chrome 확장 프로그램을 이용하면 간단하게 어떤 browser로 접속했을 때 userAgent객체에 어떤데이터가 들어가는지 확인해 볼 수 있습니다.그럼 간단히 한번 해 볼까요?먼저 크롬 웹 스토어에 접속해서user-agent switcher로 검색합니다. 확장 프로그램이 검색되는데 다음 그림과 같은 것을 설치합니다. (전 이미 설치되어 있습니다.)확장 프로그램이 설치되면 Chrome browser 우측 상단에 안경 모양의 아이콘이 보이실 겁니다. 그걸 누르면 다른 browser로 switching할 수 있습니다.자 이제 링크로 접속해 보시면 userAgent 객체의 값을보실 수 있습니다. user-agent switcher를 이용하여 다른 browser로 바꾸어서 접속하면 browser마다 userAgent값이 바뀌는 것을확인할 수 있습니다.아래 그림은 iPhone6로 browser를 switch한 후 사이트에 접속한 결과 화면입니다.추가적으로 해당 구현에 대한 소스코드까지 프로그래밍 언어별로 제공하고 있으니 필요하면 다운로드 받아서 사용하면 될 듯 싶습니다.여하간 제 블로그는 Chrome 전용이기 때문에 제가 사용하는 Jasper2 theme의 head.html에 저 위의 코드를적당히 수정해서 이용중입니다. 언제까지 이런 cross browsing issue에 시달려야하는지 안타깝습니다. ㅎㅎEnd.",
        "url": "/browser-detect-script"
    }
    ,
    
    "css-fontawesome-list": {
        "title": "Font Awesome Icon List",
            "author": "moon9342",
            "category": "",
            "content": "Introduction블로그나 사이트 작성 시 icon 이미지들이 많이 필요하게 되는데 이 아이콘을 마치 폰트처럼 사용할 수 있도록서비스를 제공하는 곳이 있습니다. Font Awesome이라는 곳인데 이 곳에서 제공하는 icon 리스트입니다. Font Awesome블로그나 사이트 작성 시 icon 이미지들이 많이 필요하게 됩니다. 과거에는 이미지를 찾아서 수정해서 쓰는 형식으로이용하였으나 근래에는 icon들을 font와 비슷하게 만들어서 마치 font처럼 icon을 사용할 수 있도록 제공하고 있습니다.이런 icon font는 Vector 이미지이기 때문에 크기에 상관없이 항상 선명한 화질을 보장받을 수 있고 font처럼 사용되다 보니 색상도 자유롭게 변경할 수 있다는 장점이 있습니다.이런 특징을 가지는 icon font를 제공하는 대표적인 사이트 중 하나가 바로 Font Awesome 입니다. Font Awesome의 폰트는 GPL 라이선스입니다. 사용방법자 그럼 우리 블로그에 어떻게 사용하면 되는지 한번 알아보도록 하죠제일 먼저 할일은 제공된 CDN을 이용해 style에 대한 링크를 걸어줍니다. &lt;head&gt; tag안에 명시하면 되겠죠? 제공된 CDN은 다음과 같습니다.&lt;link rel=\"stylesheet\" href=\"https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css\"&gt;이제 적절한 style을 만들고 우리가 적용할 곳에 해당 style을 설정하면 됩니다. 아래의 style은 Font Awesome을 사용하기 위한 일반적인 예제 style입니다. 적절히 수정해서 사용하시면 됩니다..element {    position: relative;} .element:before {    content: \"\\f000\";    font-family: FontAwesome;    font-style: normal;    font-weight: normal;    text-decoration: inherit;        color: #000;    font-size: 18px;    padding-right: 0.5em;    position: absolute;    top: 10px;    left: 0;} 아이콘 리스트위쪽 css의 content property에 명시하게 될 아이콘의 value값 입니다.만약 태그로 표현하고자 한다면 다음과 같은 형식을 이용합니다.&lt;i class=\"fa fa-glass\"&gt;&lt;/i&gt; fa-glass\"\\f000\" fa-music\"\\f001\" fa-search\"\\f002\" fa-envelope-o\"\\f003\" fa-heart\"\\f004\" fa-star\"\\f005\" fa-star-o\"\\f006\" fa-user\"\\f007\" fa-film\"\\f008\" fa-th-large\"\\f009\" fa-th\"\\f00a\" fa-th-list\"\\f00b\" fa-check\"\\f00c\" fa-times\"\\f00d\" fa-search-plus\"\\f00e\" fa-search-minus\"\\f010\" fa-power-off\"\\f011\" fa-signal\"\\f012\" fa-cog\"\\f013\" fa-trash-o\"\\f014\" fa-home\"\\f015\" fa-file-o\"\\f016\" fa-clock-o\"\\f017\" fa-road\"\\f018\" fa-download\"\\f019\" fa-arrow-circle-o-down\"\\f01a\" fa-arrow-circle-o-up\"\\f01b\" fa-inbox\"\\f01c\" fa-play-circle-o\"\\f01d\" fa-repeat\"\\f01e\" fa-refresh\"\\f021\" fa-list-alt\"\\f022\" fa-lock\"\\f023\" fa-flag\"\\f024\" fa-headphones\"\\f025\" fa-volume-off\"\\f026\" fa-volume-down\"\\f027\" fa-volume-up\"\\f028\" fa-qrcode\"\\f029\" fa-barcode\"\\f02a\" fa-tag\"\\f02b\" fa-tags\"\\f02c\" fa-book\"\\f02d\" fa-bookmark\"\\f02e\" fa-print\"\\f02f\" fa-camera\"\\f030\" fa-font\"\\f031\" fa-bold\"\\f032\" fa-italic\"\\f033\" fa-text-height\"\\f034\" fa-text-width\"\\f035\" fa-align-left\"\\f036\" fa-align-center\"\\f037\" fa-align-right\"\\f038\" fa-align-justify\"\\f039\" fa-list\"\\f03a\" fa-outdent\"\\f03b\" fa-indent\"\\f03c\" fa-video-camera\"\\f03d\" fa-picture-o\"\\f03e\" fa-pencil\"\\f040\" fa-map-marker\"\\f041\" fa-adjust\"\\f042\" fa-tint\"\\f043\" fa-pencil-square-o\"\\f044\" fa-share-square-o\"\\f045\" fa-check-square-o\"\\f046\" fa-arrows\"\\f047\" fa-step-backward\"\\f048\" fa-fast-backward\"\\f049\" fa-backward\"\\f04a\" fa-play\"\\f04b\" fa-pause\"\\f04c\" fa-stop\"\\f04d\" fa-forward\"\\f04e\" fa-fast-forward\"\\f050\" fa-step-forward\"\\f051\" fa-eject\"\\f052\" fa-chevron-left\"\\f053\" fa-chevron-right\"\\f054\" fa-plus-circle\"\\f055\" fa-minus-circle\"\\f056\" fa-times-circle\"\\f057\" fa-check-circle\"\\f058\" fa-question-circle\"\\f059\" fa-info-circle\"\\f05a\" fa-crosshairs\"\\f05b\" fa-times-circle-o\"\\f05c\" fa-check-circle-o\"\\f05d\" fa-ban\"\\f05e\" fa-arrow-left\"\\f060\" fa-arrow-right\"\\f061\" fa-arrow-up\"\\f062\" fa-arrow-down\"\\f063\" fa-share\"\\f064\" fa-expand\"\\f065\" fa-compress\"\\f066\" fa-plus\"\\f067\" fa-minus\"\\f068\" fa-asterisk\"\\f069\" fa-exclamation-circle\"\\f06a\" fa-gift\"\\f06b\" fa-leaf\"\\f06c\" fa-fire\"\\f06d\" fa-eye\"\\f06e\" fa-eye-slash\"\\f070\" fa-exclamation-triangle\"\\f071\" fa-plane\"\\f072\" fa-calendar\"\\f073\" fa-random\"\\f074\" fa-comment\"\\f075\" fa-magnet\"\\f076\" fa-chevron-up\"\\f077\" fa-chevron-down\"\\f078\" fa-retweet\"\\f079\" fa-shopping-cart\"\\f07a\" fa-folder\"\\f07b\" fa-folder-open\"\\f07c\" fa-arrows-v\"\\f07d\" fa-arrows-h\"\\f07e\" fa-bar-chart\"\\f080\" fa-twitter-square\"\\f081\" fa-facebook-square\"\\f082\" fa-camera-retro\"\\f083\" fa-key\"\\f084\" fa-cogs\"\\f085\" fa-comments\"\\f086\" fa-thumbs-o-up\"\\f087\" fa-thumbs-o-down\"\\f088\" fa-star-half\"\\f089\" fa-heart-o\"\\f08a\" fa-sign-out\"\\f08b\" fa-linkedin-square\"\\f08c\" fa-thumb-tack\"\\f08d\" fa-external-link\"\\f08e\" fa-sign-in\"\\f090\" fa-trophy\"\\f091\" fa-github-square\"\\f092\" fa-upload\"\\f093\" fa-lemon-o\"\\f094\" fa-phone\"\\f095\" fa-square-o\"\\f096\" fa-bookmark-o\"\\f097\" fa-phone-square\"\\f098\" fa-twitter\"\\f099\" fa-facebook\"\\f09a\" fa-github\"\\f09b\" fa-unlock\"\\f09c\" fa-credit-card\"\\f09d\" fa-rss\"\\f09e\" fa-hdd-o\"\\f0a0\" fa-bullhorn\"\\f0a1\" fa-bell\"\\f0f3\" fa-certificate\"\\f0a3\" fa-hand-o-right\"\\f0a4\" fa-hand-o-left\"\\f0a5\" fa-hand-o-up\"\\f0a6\" fa-hand-o-down\"\\f0a7\" fa-arrow-circle-left\"\\f0a8\" fa-arrow-circle-right\"\\f0a9\" fa-arrow-circle-up\"\\f0aa\" fa-arrow-circle-down\"\\f0ab\" fa-globe\"\\f0ac\" fa-wrench\"\\f0ad\" fa-tasks\"\\f0ae\" fa-filter\"\\f0b0\" fa-briefcase\"\\f0b1\" fa-arrows-alt\"\\f0b2\" fa-users\"\\f0c0\" fa-link\"\\f0c1\" fa-cloud\"\\f0c2\" fa-flask\"\\f0c3\" fa-scissors\"\\f0c4\" fa-files-o\"\\f0c5\" fa-paperclip\"\\f0c6\" fa-floppy-o\"\\f0c7\" fa-square\"\\f0c8\" fa-bars\"\\f0c9\" fa-list-ul\"\\f0ca\" fa-list-ol\"\\f0cb\" fa-strikethrough\"\\f0cc\" fa-underline\"\\f0cd\" fa-table\"\\f0ce\" fa-magic\"\\f0d0\" fa-truck\"\\f0d1\" fa-pinterest\"\\f0d2\" fa-pinterest-square\"\\f0d3\" fa-google-plus-square\"\\f0d4\" fa-google-plus\"\\f0d5\" fa-money\"\\f0d6\" fa-caret-down\"\\f0d7\" fa-caret-up\"\\f0d8\" fa-caret-left\"\\f0d9\" fa-caret-right\"\\f0da\" fa-columns\"\\f0db\" fa-sort\"\\f0dc\" fa-sort-desc\"\\f0dd\" fa-sort-asc\"\\f0de\" fa-envelope\"\\f0e0\" fa-linkedin\"\\f0e1\" fa-undo\"\\f0e2\" fa-gavel\"\\f0e3\" fa-tachometer\"\\f0e4\" fa-comment-o\"\\f0e5\" fa-comments-o\"\\f0e6\" fa-bolt\"\\f0e7\" fa-sitemap\"\\f0e8\" fa-umbrella\"\\f0e9\" fa-clipboard\"\\f0ea\" fa-lightbulb-o\"\\f0eb\" fa-exchange\"\\f0ec\" fa-cloud-download\"\\f0ed\" fa-cloud-upload\"\\f0ee\" fa-user-md\"\\f0f0\" fa-stethoscope\"\\f0f1\" fa-suitcase\"\\f0f2\" fa-bell-o\"\\f0a2\" fa-coffee\"\\f0f4\" fa-cutlery\"\\f0f5\" fa-file-text-o\"\\f0f6\" fa-building-o\"\\f0f7\" fa-hospital-o\"\\f0f8\" fa-ambulance\"\\f0f9\" fa-medkit\"\\f0fa\" fa-fighter-jet\"\\f0fb\" fa-beer\"\\f0fc\" fa-h-square\"\\f0fd\" fa-plus-square\"\\f0fe\" fa-angle-double-left\"\\f100\" fa-angle-double-right\"\\f101\" fa-angle-double-up\"\\f102\" fa-angle-double-down\"\\f103\" fa-angle-left\"\\f104\" fa-angle-right\"\\f105\" fa-angle-up\"\\f106\" fa-angle-down\"\\f107\" fa-desktop\"\\f108\" fa-laptop\"\\f109\" fa-tablet\"\\f10a\" fa-mobile\"\\f10b\" fa-circle-o\"\\f10c\" fa-quote-left\"\\f10d\" fa-quote-right\"\\f10e\" fa-spinner\"\\f110\" fa-circle\"\\f111\" fa-reply\"\\f112\" fa-github-alt\"\\f113\" fa-folder-o\"\\f114\" fa-folder-open-o\"\\f115\" fa-smile-o\"\\f118\" fa-frown-o\"\\f119\" fa-meh-o\"\\f11a\" fa-gamepad\"\\f11b\" fa-keyboard-o\"\\f11c\" fa-flag-o\"\\f11d\" fa-flag-checkered\"\\f11e\" fa-terminal\"\\f120\" fa-code\"\\f121\" fa-reply-all\"\\f122\" fa-star-half-o\"\\f123\" fa-location-arrow\"\\f124\" fa-crop\"\\f125\" fa-code-fork\"\\f126\" fa-chain-broken\"\\f127\" fa-question\"\\f128\" fa-info\"\\f129\" fa-exclamation\"\\f12a\" fa-superscript\"\\f12b\" fa-subscript\"\\f12c\" fa-eraser\"\\f12d\" fa-puzzle-piece\"\\f12e\" fa-microphone\"\\f130\" fa-microphone-slash\"\\f131\" fa-shield\"\\f132\" fa-calendar-o\"\\f133\" fa-fire-extinguisher\"\\f134\" fa-rocket\"\\f135\" fa-maxcdn\"\\f136\" fa-chevron-circle-left\"\\f137\" fa-chevron-circle-right\"\\f138\" fa-chevron-circle-up\"\\f139\" fa-chevron-circle-down\"\\f13a\" fa-html5\"\\f13b\" fa-css3\"\\f13c\" fa-anchor\"\\f13d\" fa-unlock-alt\"\\f13e\" fa-bullseye\"\\f140\" fa-ellipsis-h\"\\f141\" fa-ellipsis-v\"\\f142\" fa-rss-square\"\\f143\" fa-play-circle\"\\f144\" fa-ticket\"\\f145\" fa-minus-square\"\\f146\" fa-minus-square-o\"\\f147\" fa-level-up\"\\f148\" fa-level-down\"\\f149\" fa-check-square\"\\f14a\" fa-pencil-square\"\\f14b\" fa-external-link-square\"\\f14c\" fa-share-square\"\\f14d\" fa-compass\"\\f14e\" fa-caret-square-o-down\"\\f150\" fa-caret-square-o-up\"\\f151\" fa-caret-square-o-right\"\\f152\" fa-eur\"\\f153\" fa-gbp\"\\f154\" fa-usd\"\\f155\" fa-inr\"\\f156\" fa-jpy\"\\f157\" fa-rub\"\\f158\" fa-krw\"\\f159\" fa-btc\"\\f15a\" fa-file\"\\f15b\" fa-file-text\"\\f15c\" fa-sort-alpha-asc\"\\f15d\" fa-sort-alpha-desc\"\\f15e\" fa-sort-amount-asc\"\\f160\" fa-sort-amount-desc\"\\f161\" fa-sort-numeric-asc\"\\f162\" fa-sort-numeric-desc\"\\f163\" fa-thumbs-up\"\\f164\" fa-thumbs-down\"\\f165\" fa-youtube-square\"\\f166\" fa-youtube\"\\f167\" fa-xing\"\\f168\" fa-xing-square\"\\f169\" fa-youtube-play\"\\f16a\" fa-dropbox\"\\f16b\" fa-stack-overflow\"\\f16c\" fa-instagram\"\\f16d\" fa-flickr\"\\f16e\" fa-adn\"\\f170\" fa-bitbucket\"\\f171\" fa-bitbucket-square\"\\f172\" fa-tumblr\"\\f173\" fa-tumblr-square\"\\f174\" fa-long-arrow-down\"\\f175\" fa-long-arrow-up\"\\f176\" fa-long-arrow-left\"\\f177\" fa-long-arrow-right\"\\f178\" fa-apple\"\\f179\" fa-windows\"\\f17a\" fa-android\"\\f17b\" fa-linux\"\\f17c\" fa-dribbble\"\\f17d\" fa-skype\"\\f17e\" fa-foursquare\"\\f180\" fa-trello\"\\f181\" fa-female\"\\f182\" fa-male\"\\f183\" fa-gratipay\"\\f184\" fa-sun-o\"\\f185\" fa-moon-o\"\\f186\" fa-archive\"\\f187\" fa-bug\"\\f188\" fa-vk\"\\f189\" fa-weibo\"\\f18a\" fa-renren\"\\f18b\" fa-pagelines\"\\f18c\" fa-stack-exchange\"\\f18d\" fa-arrow-circle-o-right\"\\f18e\" fa-arrow-circle-o-left\"\\f190\" fa-caret-square-o-left\"\\f191\" fa-dot-circle-o\"\\f192\" fa-wheelchair\"\\f193\" fa-vimeo-square\"\\f194\" fa-try\"\\f195\" fa-plus-square-o\"\\f196\" fa-space-shuttle\"\\f197\" fa-slack\"\\f198\" fa-envelope-square\"\\f199\" fa-wordpress\"\\f19a\" fa-openid\"\\f19b\" fa-university\"\\f19c\" fa-graduation-cap\"\\f19d\" fa-yahoo\"\\f19e\" fa-google\"\\f1a0\" fa-reddit\"\\f1a1\" fa-reddit-square\"\\f1a2\" fa-stumbleupon-circle\"\\f1a3\" fa-stumbleupon\"\\f1a4\" fa-delicious\"\\f1a5\" fa-digg\"\\f1a6\" fa-pied-piper\"\\f1a7\" fa-pied-piper-alt\"\\f1a8\" fa-drupal\"\\f1a9\" fa-joomla\"\\f1aa\" fa-language\"\\f1ab\" fa-fax\"\\f1ac\" fa-building\"\\f1ad\" fa-child\"\\f1ae\" fa-paw\"\\f1b0\" fa-spoon\"\\f1b1\" fa-cube\"\\f1b2\" fa-cubes\"\\f1b3\" fa-behance\"\\f1b4\" fa-behance-square\"\\f1b5\" fa-steam\"\\f1b6\" fa-steam-square\"\\f1b7\" fa-recycle\"\\f1b8\" fa-car\"\\f1b9\" fa-taxi\"\\f1ba\" fa-tree\"\\f1bb\" fa-spotify\"\\f1bc\" fa-deviantart\"\\f1bd\" fa-soundcloud\"\\f1be\" fa-database\"\\f1c0\" fa-file-pdf-o\"\\f1c1\" fa-file-word-o\"\\f1c2\" fa-file-excel-o\"\\f1c3\" fa-file-powerpoint-o\"\\f1c4\" fa-file-image-o\"\\f1c5\" fa-file-archive-o\"\\f1c6\" fa-file-audio-o\"\\f1c7\" fa-file-video-o\"\\f1c8\" fa-file-code-o\"\\f1c9\" fa-vine\"\\f1ca\" fa-codepen\"\\f1cb\" fa-jsfiddle\"\\f1cc\" fa-life-ring\"\\f1cd\" fa-circle-o-notch\"\\f1ce\" fa-rebel\"\\f1d0\" fa-empire\"\\f1d1\" fa-git-square\"\\f1d2\" fa-git\"\\f1d3\" fa-hacker-news\"\\f1d4\" fa-tencent-weibo\"\\f1d5\" fa-qq\"\\f1d6\" fa-weixin\"\\f1d7\" fa-paper-plane\"\\f1d8\" fa-paper-plane-o\"\\f1d9\" fa-history\"\\f1da\" fa-circle-thin\"\\f1db\" fa-header\"\\f1dc\" fa-paragraph\"\\f1dd\" fa-sliders\"\\f1de\" fa-share-alt\"\\f1e0\" fa-share-alt-square\"\\f1e1\" fa-bomb\"\\f1e2\" fa-futbol-o\"\\f1e3\" fa-tty\"\\f1e4\" fa-binoculars\"\\f1e5\" fa-plug\"\\f1e6\" fa-slideshare\"\\f1e7\" fa-twitch\"\\f1e8\" fa-yelp\"\\f1e9\" fa-newspaper-o\"\\f1ea\" fa-wifi\"\\f1eb\" fa-calculator\"\\f1ec\" fa-paypal\"\\f1ed\" fa-google-wallet\"\\f1ee\" fa-cc-visa\"\\f1f0\" fa-cc-mastercard\"\\f1f1\" fa-cc-discover\"\\f1f2\" fa-cc-amex\"\\f1f3\" fa-cc-paypal\"\\f1f4\" fa-cc-stripe\"\\f1f5\" fa-bell-slash\"\\f1f6\" fa-bell-slash-o\"\\f1f7\" fa-trash\"\\f1f8\" fa-copyright\"\\f1f9\" fa-at\"\\f1fa\" fa-eyedropper\"\\f1fb\" fa-paint-brush\"\\f1fc\" fa-birthday-cake\"\\f1fd\" fa-area-chart\"\\f1fe\" fa-pie-chart\"\\f200\" fa-line-chart\"\\f201\" fa-lastfm\"\\f202\" fa-lastfm-square\"\\f203\" fa-toggle-off\"\\f204\" fa-toggle-on\"\\f205\" fa-bicycle\"\\f206\" fa-bus\"\\f207\" fa-ioxhost\"\\f208\" fa-angellist\"\\f209\" fa-cc\"\\f20a\" fa-ils\"\\f20b\" fa-meanpath\"\\f20c\" fa-buysellads\"\\f20d\" fa-connectdevelop\"\\f20e\" fa-dashcube\"\\f210\" fa-forumbee\"\\f211\" fa-leanpub\"\\f212\" fa-sellsy\"\\f213\" fa-shirtsinbulk\"\\f214\" fa-simplybuilt\"\\f215\" fa-skyatlas\"\\f216\" fa-cart-plus\"\\f217\" fa-cart-arrow-down\"\\f218\" fa-diamond\"\\f219\" fa-ship\"\\f21a\" fa-user-secret\"\\f21b\" fa-motorcycle\"\\f21c\" fa-street-view\"\\f21d\" fa-heartbeat\"\\f21e\" fa-venus\"\\f221\" fa-mars\"\\f222\" fa-mercury\"\\f223\" fa-transgender\"\\f224\" fa-transgender-alt\"\\f225\" fa-venus-double\"\\f226\" fa-mars-double\"\\f227\" fa-venus-mars\"\\f228\" fa-mars-stroke\"\\f229\" fa-mars-stroke-v\"\\f22a\" fa-mars-stroke-h\"\\f22b\" fa-neuter\"\\f22c\" fa-genderless\"\\f22d\" fa-facebook-official\"\\f230\" fa-pinterest-p\"\\f231\" fa-whatsapp\"\\f232\" fa-server\"\\f233\" fa-user-plus\"\\f234\" fa-user-times\"\\f235\" fa-bed\"\\f236\" fa-viacoin\"\\f237\" fa-train\"\\f238\" fa-subway\"\\f239\" fa-medium\"\\f23a\" fa-y-combinator\"\\f23b\" fa-optin-monster\"\\f23c\" fa-opencart\"\\f23d\" fa-expeditedssl\"\\f23e\" fa-battery-full\"\\f240\" fa-battery-three-quarters\"\\f241\" fa-battery-half\"\\f242\" fa-battery-quarter\"\\f243\" fa-battery-empty\"\\f244\" fa-mouse-pointer\"\\f245\" fa-i-cursor\"\\f246\" fa-object-group\"\\f247\" fa-object-ungroup\"\\f248\" fa-sticky-note\"\\f249\" fa-sticky-note-o\"\\f24a\" fa-cc-jcb\"\\f24b\" fa-cc-diners-club\"\\f24c\" fa-clone\"\\f24d\" fa-balance-scale\"\\f24e\" fa-hourglass-o\"\\f250\" fa-hourglass-start\"\\f251\" fa-hourglass-half\"\\f252\" fa-hourglass-end\"\\f253\" fa-hourglass\"\\f254\" fa-hand-rock-o\"\\f255\" fa-hand-paper-o\"\\f256\" fa-hand-scissors-o\"\\f257\" fa-hand-lizard-o\"\\f258\" fa-hand-spock-o\"\\f259\" fa-hand-pointer-o\"\\f25a\" fa-hand-peace-o\"\\f25b\" fa-trademark\"\\f25c\" fa-registered\"\\f25d\" fa-creative-commons\"\\f25e\" fa-gg\"\\f260\" fa-gg-circle\"\\f261\" fa-tripadvisor\"\\f262\" fa-odnoklassniki\"\\f263\" fa-odnoklassniki-square\"\\f264\" fa-get-pocket\"\\f265\" fa-wikipedia-w\"\\f266\" fa-safari\"\\f267\" fa-chrome\"\\f268\" fa-firefox\"\\f269\" fa-opera\"\\f26a\" fa-internet-explorer\"\\f26b\" fa-television\"\\f26c\" fa-contao\"\\f26d\" fa-500px\"\\f26e\" fa-amazon\"\\f270\" fa-calendar-plus-o\"\\f271\" fa-calendar-minus-o\"\\f272\" fa-calendar-times-o\"\\f273\" fa-calendar-check-o\"\\f274\" fa-industry\"\\f275\" fa-map-pin\"\\f276\" fa-map-signs\"\\f277\" fa-map-o\"\\f278\" fa-map\"\\f279\" fa-commenting\"\\f27a\" fa-commenting-o\"\\f27b\" fa-houzz\"\\f27c\" fa-vimeo\"\\f27d\" fa-black-tie\"\\f27e\" fa-fonticons\"\\f280\"",
        "url": "/css-fontawesome-list"
    }
    ,
    
    "github-gist": {
        "title": "What is GitHub Gist?",
            "author": "moon9342",
            "category": "",
            "content": "IntroductionCode Snippet을 관리하기 위한 도구입니다. 블로그로 IT 관련 포스팅을 하는 사람들에게는 굉장히 유용한 도구로사용이 됩니다. Gist는 우리나라말로 “지스트”라고 발음하며 GitHub에서 서비스 하고 있습니다.만일 Gist에 대해서는 알고 있고 jekyll기반의 GitHub Page에서 사용하는 방법에 대해서 알고 싶으신 분은 여기를 참조하세요! Code Snippet 관리IT 개발관련 블로그를 운영하다보면 여러 코드조각들을 블로그에 같이 올리게됩니다. 어떤 경우는 말 그대로 완성되지 않은“코드조각” 형태의 코드를 올리기도 하고 어떤 경우는 완성된 형태의 코드를 올리기도 합니다.텍스트 형태로 그냥 포스팅을 하면 보기가 너무 좋지 않으니 일반적으로 Syntax Highlighter를 많이 이용하게 됩니다. 다양한 종류의 Syntax Highlighter가 있고 이를 이용하면 보기 좋게 코드들을 블로그에 올릴 수 있습니다.설명을 하기 위한 코드조각들은 일반적으로 수정이나 공유의 빈도가 상대적으로 적기 때문에 그냥 Rouge와 같은Syntax Highlighter를 이용하여 올리면 편합니다. 하지만 완성된 코드를 포스팅하는 경우 추후에 기능의 보완이라든지오류에 대한 수정같은 이슈가 생길 수 있고 이렇게 변경된 코드는 다른 사람과 공유할 때 문제가 발생할 수 밖에 없습니다.하나의 완성된 코드를 블로그 여기저기에서 가져다가 쓰는 경우 역시 마찬가지의 이슈가 발생할 수 있겠죠.결국 “YouTube에 동영상을 올리고 블로그에 삽입하는 것처럼 이런 코드조각들도 그렇게 관리하고 공유하면 편하겠다” 라고 사람들이 생각하게 되고 이를 위한 온라인 서비스도 여러 개 생기게 되었는데 그 중 하나가 GitHub에서 제공하는 Gist입니다.결론적으로 Gist는 Code Snippet을 관리하고 공유하도록 도와주는 서비스라고 생각하시면 됩니다. 사용방법사용방법은 상당히 간단합니다. 일단 GitHub에 로그인해서 노란색 영역을 클릭하시면다음과 같은 화면을 보실 수 있습니다.New gist 메뉴를 선택하면 Code Snippet을 생성할 수 있는 화면으로 전환됩니다.코드 내용을 입력하고 public 혹은 secret 형태로 gist를 생성합니다.생성이 되면 아마 다음과 같은 화면을 보실 수 있을텐데 이렇게 작성된 gist를 블로그에올리려면 Embed라고 되어있는 JavaScript link code를 가져다가 블로그에 삽입하면 됩니다.실제로 한번 작업해 보시면 자신이 작성한 Code Snippet을 블로그에 쉽게 포함 시킬 수있으실 겁니다.저는 Jekyll기반의 GitHub Page에서 블로그를 운영하고 있기 때문에 조금 다른 방식을 이용합니다.Liquid template을 이용해서 블로그에 포함시키는 방법을 이용합니다.이 방식에 대해서는 여기를 참조하세요!End.",
        "url": "/github-gist"
    }
    ,
    
    "i18n-l10n": {
        "title": "What is i18n, l10n?",
            "author": "moon9342",
            "category": "",
            "content": "Introduction국제화와 지역화 작업을 의미하는 i18n과 l10n에 대해서 알아보도록 하겠습니다. i18n, l10ni18n은 internationalization(국제화)를 표현한 것입니다. 첫글자인 i와 마지막 글자인 n사이에 18개의 글자가 있다고해서 저렇게 표현한 겁니다. 아마 IT쪽에 관심이 있는 사람이라면 i18n이 어떤 약자인지는 몰랐어도 국제화라는걸 알고는 있었으리라생각됩니다.l10n역시 마찬가지로 localization(현지화)를 표현한 것입니다. 첫글자인 l과 마지막 글자인 n사이에 10개의 글자가 있다라는 것이겠죠?일반적으로 우리가 작성한 프로그램을 다른 언어로 출시할때는 당연히 해당 언어로 현지화를 진행해야 합니다. 내용의 번역부터 시작해서각종 단위(통화단위, 도량형 단위, 숫자의 표현, 날짜표현 양식 등)의 변환등을 의미하겠죠. 하지만 현지화의 가장 중요한 점은 타겟문화에 맞도록 컨텐츠를 조절하는 것입니다. 이게 힘든 작업이죠. 개발자에게 맡기면 산으로 갑니다. (^^)여하간 이런 현지화를 다른 여러 타겟(여러 나라)를 대상으로 우리의 프로그램을 조정하는 작업이 바로 i18n support라고 불리는 국제화작업이라고 보시면 될 듯 합니다.그냥 그렇다구요.i18n 작업을 할 때 주의해야 할 점에 대해서는 다른 훌륭한 포스트들을 참조해주세요~ 사실 저도작업 경험이 딱 한번 있습니다. (하고 싶지 않아요.. 할 생각도 없구요)End.",
        "url": "/i18n-l10n"
    }
    ,
    
    "typescript-interface": {
        "title": "TypeScript 강좌(6) - Interface",
            "author": "moon9342",
            "category": "",
            "content": "TypeScript 강좌는 여러 절로 구성되어 있습니다.    TypeScript 강좌(1) - Introduction    TypeScript 강좌(2) - Data Type(Part 1)    TypeScript 강좌(3) - Data Type(Part 2)    TypeScript 강좌(4) - 변수 선언    TypeScript 강좌(5) - Destructuring    TypeScript 강좌(6) - Interface    TypeScript 강좌(7) - Class TypeScript Interfaceinterface는 우리가 알고 있는 Java의 interface와 문법적으로 유사합니다. 하지만 객체지향에서 말하는 interface와는의미적으로 좀 차이가 있습니다. 그 부분은 예제 중간중간에 살펴보기로 하고 지금은 TypeScript의 interface 에 대해서만 살펴보도록 하겠습니다.TypeScript에서 interface는 새로운 데이터 타입을 만드는 추상 데이터 타입(abstract data type)으로 사용이 되며일반 변수, 함수, 클래스의 type check를 위해 사용됩니다. interface 이용하여 타입을 선언하면 interface안에 명시된 property의 선언과 method의 구현이 강제되기 때문에 프로그래밍의 일관성을 확보할 수 있습니다.참고로 ES6는 interface를 지원하지 않습니다. TypeScript만 지원합니다. 그렇기 때문에 interface를 컴파일 한 결과물을 보면 interface의 내용은 나타나지 않게됩니다. Basic Exam그럼 간단한 예를 통해 알아보도록 하겠습니다.interface IBook {    bookName: string;    bookAuthor: string;}let myBook: IBook;myBook = {    bookName: \"젊은 베르테르의 슬픔\",    bookAuthor: \"괴테\"};console.log(myBook);해당 .ts 파일을 컴파일 한 결과 .js 파일을 살펴보면 다음과 같습니다.\"use strict\";var myBook;myBook = {    bookName: \"젊은 베르테르의 슬픔\",    bookAuthor: \"괴테\"};console.log(myBook);위에서 언급한 대로 interface에 대한 내용은 포함되어 있지 않습니다. TypeScript의 interface는 type check를 위한용도로 사용되게 됩니다. Parameter Type Check비슷한 용도로 함수의 인자를 넘길 때 인자의 type으로 interface를 이용할 수 있습니다. 아래의 예를 한번 살펴보죠.interface IBook {    bookName: string;    bookAuthor: string;}function printBookInfo(paramBook: IBook) : void {    console.log(paramBook.bookName);}let myBook: IBook = {    bookName: \"젊은 베르테르의 슬픔\",    bookAuthor: \"괴테\"};printBookInfo(myBook);굳이 설명할 것도 없는거 같습니다. printBookInfo()의 인자로 interface type의 객체가 전달되어사용된 것이죠.여기까지는 별 문제 없이 이해할 수 있습니다. 이제 그 다음이 살짝 이상합니다. Duck Typing아래의 코드에서 문법 오류가 일어날까요?interface IBook {    bookName: string;    bookAuthor: string;}function printBookInfo(paramBook: IBook) : void {    console.log(paramBook.bookName);}let myBook = {    bookName: \"젊은 베르테르의 슬픔\",    bookAuthor: \"괴테\",    bookPrice: 3000};printBookInfo(myBook);원래 예상대로라면 이 코드는 문제가 있는 것이 맞습니다. myBook이라는 객체는 IBook interface type으로 지정되지 않고 parameter로 전달이 되었거든요. 하지만 이 코드는 에러없이 컴파일이 진행됩니다.왜 이런 현상이 발생할까요?TypeScript의 중요한 원칙 중 하나는 가지고 있는 값들의 형태를 가지고 type-checking을 수행한다는 것입니다. 말이 좀 어렵네요. 풀어서 설명하자면 TypeScript에서 type-checking은 선언된 타입만을 비교하는것이 아니라 실제 이용될 수 있는 형태의 값들을 가지고 있느냐 그렇지 않느냐를 가지고 한다는 의미입니다.위의 예제에서 myBook 객체는 비록 IBook interface type은 아니지만 IBook interface type을 모두 커버할 수 있는 값들의 형태를가지고 있습니다. 이런 경우 myBook 객체는 IBook interface 타입으로 간주한다는 말이지요.이런걸 동적 typing의 한 종류인 duck typing이라고 합니다. TypeScript는 duck typing을 지원하는 언어입니다. 일반적으로말하자면 class의 상속이나 interface의 구현으로 타입을 구분하는 것이 아니라 객체가 특정 타입에 걸맞는 property와 method를 가지고 있으면 해당 type으로 간주한다는 의미로 받아들이시면 됩니다.해서 저 위의 코드는 에러없이 사용할 수 있습니다. Optional PropertiesTypeScript interface의 모든 property와 method는 구현하는 클래스 혹은 구현 객체에서 기본적으로 모두 재정의되어야 합니다. 하지만 Optional Property( property 중 ? 가 붙어있는 property를 의미합니다. )를 이용하면 해당 property는 재정의하지 않아도 상관없습니다. 즉, 선택적으로 구현여부를 결정할 수 있는 property가 optional property입니다.아래의 예를 가지고 살펴보겠습니다.interface IBook {    bookName: string;    bookAuthor: string;    bookISBN?: string;   // Optional Property    getName(): string;}function printBookInfo(paramBook: IBook) : void {    console.log(paramBook.bookName);    console.log(paramBook.getName());}let myBook: IBook = {    bookName: \"젊은 베르테르의 슬픔\",    bookAuthor: \"괴테\",    getName: function() {       return this.bookName;    }};printBookInfo(myBook); Readonly Propertiesreadonly keyword를 이용해 객체가 처음 생성되는 시점에만 property들을 수정가능하도록 설정할 수 있습니다.한번 값이 세팅되면 그 후에는 수정할 수 없게됩니다.interface Point {    readonly x: number;    y: number;}let p1: Point = { x: 10, y: 20 };p1.x = 100;    // 오류 발생TypeScript는 또 ReadonlyArray&lt;T&gt; 형태의 Array를 지원합니다. 이름에서 의미하는 것처럼 생성된 후에는Array를 변경할 수 없습니다.let arr: number[] = [1, 2, 3, 4];let roArray: ReadonlyArray&lt;number&gt; = arr;roArray[0] = 100;   // 코드 에러roArray.push(100);  // 코드 에러arr = roArray;             // 코드 에러arr = roArray as number[]; // 가능위의 코드도 쉽게 이해할 수 있습니다. 마지막 코드 정도만 주의하면 될 듯 합니다.이렇게 readonly property는 const와 비슷한 역할을 하게됩니다. 단 const는 변수의 선언에사용되며 readonly는 property 지정에 사용된다는 점만 기억하시면 됩니다. Function Typesinterface는 function의 type을 지정하는데 사용할 수 있습니다. 이 경우 parameter의 리스트와리턴타입만을 가지고 있는 함수의 선언과 비슷한 형태를 가지게 됩니다. 아래의 예를 보죠.interface myInterface {    (myName: string, myAge: number): void;}let myFunc: myInterface = function(myName:string, myAge:number): void {    console.log(`이름 : ${myName}, 나이 : ${myAge}`);};myFunc(\"홍길동\",30); Indexable TypesJavaScript의 객체를 사용하기 위해서는 일반적으로 \".\" operator를 이용합니다. 일반적인 객체지향언어에서객체를 사용하는 방식이죠. JavaScript는 추가적으로 객체를 사용하는 방법으로 배열방식을 이용할 수 있습니다.다음과 같이 사용합니다.아래의 코드는 JavaScript 코드입니다.let obj = {    myName: '홍길동',    myAddress: '서울'};console.log(obj.myName);           // \".\" operator 이용let keys = Object.keys(obj);       // 객체의 key값들에 대한 배열 획득for(let i = 0; i&lt; keys.length; i++) {    console.log(obj[keys[i]]);     // 배열형식을 이용}위의 코드는 문법에러가 발생하지 않고 결과도 잘 출력이 됩니다. obj 객체에 접근할 때[ ] 형태를 이용해서 key값에 접근해서 value값을 출력하는 간단한 예제입니다.하지만 이 코드를 TypeScript로 작성하면 코드에러가 발생합니다. 해당 파일에 대한 확장자만.js에서 .ts로 변경해보면 obj[keys[i]에서 다음과 같은 에러가 발생하는 것을 볼 수 있습니다.Element implicitly has an 'any' type because type '{ myName: string; myAddress: string; }' has no index signature.쉽게 말하면 index signature를 이용하지 않았기 때문에 property에 접근할 때 어떤 타입인지를 확인할 수 없어서 묵시적으로 any 타입을 이용하게 된다는 의미입니다. 하지만 우리는 TypeScriptcompiler 옵션 중 noImplicitAny 속성을 true로 해 놓았기 때문에 문제가 발생하는 것입니다.(noImplicitAny: true가 default로 설정됩니다.)해결하기 위해서는 컴파일러 옵션을 수정하던지 아니면 interface를 이용하여 index signature를 설정해 type을명시적으로 알려주면 됩니다.컴파일러 옵션을 수정하는 방법은 tsconfig.json 설정에서 \"noImplicitAny\": false 옵션을 추가하시면 됩니다. 하지만 좋지 않습니다. any 타입은 특별한 이유가 있지 않는 한 가능한 사용하지 않는게 좋고 명시적으로 타입을 지정해서 사용하셔야 합니다.좀 더 좋은 해결책은 interface로 index signature를 설정해서 사용하는 것입니다. 이걸 Indexable Type이라고 합니다.아래의 코드처럼 interface를 이용해 index signature를 설정합니다.interface IObj {    [idx: string]: string;}let obj: IObj = {    myName: '홍길동',    myAddress: '서울'};console.log(obj.myName);           // \".\" operator 이용let keys = Object.keys(obj);       // 객체의 key값들에 대한 배열 획득for(let i = 0; i&lt; keys.length; i++) {    console.log(obj[keys[i]]);     // 배열형식을 이용}추가적으로 union type을 이용한 다음의 코드도 살펴보시면 됩니다.interface IObj {    [idx: string]: string | number;    [index: number]: string | number;    myName: string;    myAddress: string;    myAge: number}let obj: IObj = {    myName: '홍길동',    myAddress: '서울',    myAge: 30};console.log(obj.myName);           // \".\" operator 이용let keys = Object.keys(obj);       // 객체의 key값들에 대한 배열 획득for(let i = 0; i&lt; keys.length; i++) {    console.log(obj[keys[i]]);     // 배열형식을 이용}마지막으로 앞에서 나온 readonly property를 이용하면 ReadonlyArray처럼 사용할 수 있습니다.interface ReadonlyStringArray {    readonly [index: number]: string;}let myArr: ReadonlyStringArray = [\"홍길동\", \"강감찬\"];myArr[2] = \"이순신\"; // 코드 오류( readonly ) Class Typesinterface의 가장 일반적인 사용법은 Java나 C#언어처럼 class의 구현을 명시적으로 강제하는 것입니다.아직 class에 대해서는 배우지 않았지만 Java같은 객체지향 언어를 해 보신 분이라면 쉽게 이해하실거라 생각됩니다.interface IPerson {    [idx: string]: string | number | Function;    myName: string;    myAddress: string;    myAge: number;    printInfo(obj:IPerson): void;}class Person implements IPerson {    [index: string]: string | number | Function;    myName: string;    myAddress: string;    myAge: number;    constructor(name:string, address:string, age:number) {        this.myName = name;        this.myAddress = address;        this.myAge = age;    }        printInfo(obj: IPerson): void {        Object.keys(obj).forEach(t =&gt; console.log(obj[t]));    }}const obj = new Person(\"홍길동\", \"서울\", 30);obj.printInfo(obj);위와 같은 일반적인 경우가 사실은 대부분입니다. ^^; 여기에 추가적인 몇가지만 살펴보겠습니다. 이전 강좌에서 일급함수(first class function)개념에 대해서 언급했었는데기억하시나요? 한마디로 요약하자면 “JavaScript는 함수를 값으로 취급한다” 입니다. 그래서 함수를변수에 저장하거나 함수를 다른 함수의 인자로 넘기거나 함수의 리턴값으로 함수를 활용할 수 있는 것이지요.그래서 다음의 JavaScript코드는 정상적으로 동작합니다.const PersonFactory = {    getInstance: function(construct,name,age) {        return new construct(name,age);    }};class Person {    constructor(name, age) {        this.myName = name;        this.myAge = age;    }    printInfo() {        console.log(\"이름:\" + this.myName + \", 나이:\" + this.myAge);    }}let obj = PersonFactory.getInstance(Person, \"홍길동\", 30);obj.printInfo();위의 코드에서 Person 생성자를 PersonFactory.getInstance 함수의 인자로 넘겨서사용했습니다. JavaScript에서는 문제없이 잘 동작합니다. 하지만 이 코드를 그대로TypeScript에서 작성하면 코드에러가 발생합니다.일단 타입지정부터 엉망이니 좀 수정해서 보면 TypeScript코드는 다음과 같게 됩니다.const PersonFactory = {    getInstance: function(construct:any,name:string,age:number) {        return new construct(name,age);    }};class Person {    myName: string;    myAge: number;    constructor(name:string, age:number) {        this.myName = name;        this.myAge = age;    }    printInfo() {        console.log(\"이름:\" + this.myName + \", 나이:\" + this.myAge);    }}let obj = PersonFactory.getInstance(Person, \"홍길동\", 30);obj.printInfo();데이터 타입을 적절하게 지정해서 일단 코드 오류는 제거했습니다. 그런데 문제가 하나 있습니다.const PersonFactory = {    getInstance: function(construct:any,name:string,age:number) {        return new construct(name,age);    }};위의 코드에서 생성자를 인자로 받아올 때 타입을 어떻게 지정해야 할지 몰라 일단 모든 타입에 대응되는any로 설정했습니다. any로 설정하면 문제없지만 우리는 any를 사용하지 않습니다. 좀 심하게 표현하자면 any를사용할꺼면 굳이 TypeScript를 할 필요가 없습니다. 여하간 이 any를 없애고 정확한 타입을 명시하려 합니다. 그런데 어떤 타입을 써야하나요? any대신 만만한 Function을 이용해 보면 다음과 같은 오류를 보실 수 있습니다.Cannot use 'new' with an expression whose type lacks a call or construct signatureconstruct signature 없이 new를 사용할 수 없답니다. 그럼 이 construct signature를 어떻게 만들어야 할까요?저 위에서는 index signature라는 걸 interface를 이용해서 선언하고 사용했습니다. 기억하시죠? 이와 비슷합니다.interface를 이용해 생성자의 signature를 지정해 줄 수 있습니다. 다음과 같이 사용합니다.interface IPersonConstructor {    new (n:string, a:number): Person;}const PersonFactory = {    getInstance: function(construct:IPersonConstructor,                          name:string,                          age:number) {        return new construct(name,age);    }};class Person {    myName: string;    myAge: number;    constructor(name:string, age:number) {        this.myName = name;        this.myAge = age;    }    printInfo() {        console.log(\"이름:\" + this.myName + \", 나이:\" + this.myAge);    }}let obj = PersonFactory.getInstance(Person, \"홍길동\", 30);obj.printInfo();이렇게 사용하는 interface를 constructor interface 라고 표현하기도 합니다. 중요한 것은interface로 constructor의 타입을 지정해 줄 수 있다는 것이고 construct signature라는 표현으로interface내에 정의해서 사용합니다. interface의 확장하나의 interface는 다른 interface로 부터 상속받아서 확장될 수 있습니다. Java와 유사합니다. 다음의 코드로이해하시면 됩니다.interface Shape {    color: string;}interface Square extends Shape {    sideLength: number;}let square = &lt;Square&gt;{};square.color = \"blue\";square.sideLength = 10;let square = &lt;Square&gt;{}; 에서 &lt;Square&gt; 부분이 어떤것인지 기억하시나요? 그렇습니다. Type assertions이죠.위의 코드는 크게 어렵지 않을 듯 보입니다. 하지만 Java와 다른점이 있습니다. 동시에 여러 interface로 부터 상속을받을 수 있다는 것이죠. 하지만 여기서 상속이라는 표현은 맞지 않습니다. 상속은 객체지향 언어에서 나오는 특성입니다.여기서는 단지 interface의 확장일 뿐입니다.interface Shape {    color: string;}interface PenStroke {    penWidth: number;}interface Square extends Shape, PenStroke {    sideLength: number;}let square = &lt;Square&gt;{};square.color = \"blue\";square.sideLength = 10;square.penWidth = 5.0;interface는 type check를 위해 사용되기 때문에 interface로는 객체를 생성할 수 없습니다.일단 이 정도만 알아두어도 될 듯 보입니다. 내용이 생각보다 많은데 생각보다 많이 어렵지는 않습니다. 단지 헷갈릴 뿐이죠 ^^여러번 정독하면서 쓰임새를 알아두고 실제 코드에서 활용하면서 익히셔야 합니다.End.이 포스트의 내용은 아래의 사이트를 참조했습니다. 조금 더 자세한 사항을 알고 싶으시면    해당 사이트를 방문하세요!!    TypeScript Official HomePage",
        "url": "/typescript-interface"
    }
    ,
    
    "javascript-babel": {
        "title": "JavaScript Babel을 사용해보자",
            "author": "moon9342",
            "category": "",
            "content": "Introduction아무 생각없이 Babel을 쓰고 있지만 예전부터 궁금했던 Babel이란 이름이 내가 알고 있는 그 바벨탑의 바벨인가? 라는 의문에 이름의 근원을 찾아보고 이왕 찾아본 김에 Babel의 간단한 사용법 정도만 정리해 보도록 하겠습니다.( 도데체 이런게 왜 궁금한건대? ) Babel이란 이름의 기원결론적으로 Babel Official HomePage 에서는 이름에 대한 근원을 찾을수는 없었습니다. 어딘가에 숨어있는지는 모르겠지만요. 여하간 Babel은 성경 영어로 구약성서 창세기에 그 근원을 두고 있습니다.( 왠지 산으로 가는 느낌입니다. )노아의 홍수 이후로 인간은 다시 번성하기 시작했고 그 당시에는 전 세계의 언어가 하나였다고 합니다. 하나님은 인간들에게흩어져 살 것을 명하셨지만, 사람들은 하나님의 말씀에 불순종하여 Shinar 라는 곳에 모여 살았답니다. 그리고 그들은자신들을 위해 하나의 도시를 건설하고 하늘에까지 닿는 높은 탑도 같이 세워 자신들의 이름을 높이고 흩어지지 않겠다는 의미로하나의 높은 탑을 건설하게 되었는데 이게 그 Babel(바벨탑)이랍니다.하지만 인간들의 그러한 동기를 아시는 하나님께서 그들이 탑을 세우지 못하고 전 세계로 흩어지게끔 그들의 언어를 여러개로나누셔서 서로간의 의사소통이 되지 않도록 하셨답니다. 서로 말이 통하지 않자 탑 공사는 중단되고 결국 언어가 맞는 사람끼리 뿔뿔히흩어져 살게되었다라는 이야기지요.그래서 Babel의 사전적 의미는 “와글와글”, “바벨탑”, “거대한 탑” 의 의미를 가지게 되었다고 합니다. Babel의 목적Babel은 JavaScript transpiler입니다. 공식 홈에는 compiler라고 표현했지만 사실 compiler보다는 transpiler라는 용어가더 맞지 않나 싶습니다. 여하간 Babel의 입력은 JavaScript이고 출력 역시 JavaScript입니다.잘 알다시피 ES5 표준은 2009년도에 표준화되었습니다. 그리고 한동안 변경이 없다가 2015년에 ES6가 표준화가 됩니다.현재 시점은 ES7 이 최신표준이지만 아직까지 ES6가 대세라고 볼 수 있습니다. 이 ES6에 들어와서는 여러가지 획기적인변화가 생기게 되었습니다.변화된 내용 중 대표적인 것들은 다음과 같습니다.  class  arrow function  template string  generator  destructuring  let &amp; const문제는 이런 최신의 문법들로 쓰여진 JavaScript 코드를 런타임 환경인 browser가 인식하고 실행할 수 있는냐는 것입니다. browser는 최신 ECMAScript 문법을 다 지원하지 못하거든요. 특히 구형 browser나 IE같은 경우는 그 정도가 심합니다.하지만 생산성과 유지보수성등의 이유로 코드자체는 ECMAScript 최신버전으로 구현하는게 당연히 좋습니다. 즉, 구현과 실행환경과의 버전차이가 생기게 됩니다. Babel은  ECMAScript 6,7 으로 작성된 코드를 browser가 인식할 수 잇는 문법(ES5)으로변환시켜주는 transpiler입니다.한가지 주의해야 할 점은 Babel을 사용한다고 해서 모든 최신의 JavaScript함수를 다 사용할 수 있는건 아닙니다. Babel은문법만 변환시켜 주는 역할만 할 뿐입니다. 따라서 프로그램이 처음에 시작될 때 browser에서 지원하지 않는 함수를 검사해 처리해주는작업이 이루어져야 하고 이 부분은 babel-ployfill이 runtime에 담당하게 됩니다. ( 이 기능을 사용하기 위해서는 추가적인 설정이 필요합니다. ) Babel의 사용자 그럼 실제 사용하는 예를 알아보도록 하겠습니다.Babel역시 다른 node module과 마찬가지로 npm으로 설치하면 됩니다.npm install --save-dev babel-cli babel-preset-es2015package.json에 다음과 같이 npm script 작성{  ...  ...  \"scripts\": {    \"build\": \"babel babelTest.js -d lib\",    \"test\": \"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\"  },  ...  ...}ES6로 다음과 같은 코드 작성하고 babelTest.js로 저장합니다.let [a,,b] = [1,2,3];let myName = \"홍길동\";console.log(`Hello ${myName}`);class Student {    constructor(sName) {        this.sName = sName;    }}let stu = new Student(\"Moon\");console.log(stu.sName);다음과 같이 .babelrc 파일을 작성합니다.{  \"presets\": [    \"es2015\"  ]}다음과 같이 npm script를 실행시켜 lib폴더에 생성된 컴파일된 결과 파일을 확인합니다.npm run build결과로 생성된 ES5 파일의 내용\"use strict\";function _classCallCheck(instance, Constructor) {     if (!(instance instanceof Constructor)) {         throw new TypeError(\"Cannot call a class as a function\");     } }var _ref = [1, 2, 3],    a = _ref[0],    b = _ref[2];var myName = \"홍길동\";console.log(\"Hello \" + myName);var Student = function Student(sName) {    _classCallCheck(this, Student);    this.sName = sName;};var stu = new Student(\"Moon\");console.log(stu.sName);여기서는 Babel이 어떤 역할을 하고 어떻게 사용하는 것인지에 대해서 간단하게 알아보았습니다.이 포스트의 내용은 Babel Official Home Page을 참조했습니다.조금 더 자세한 사항을 알고 싶으시면 해당 사이트를 방문하세요!!End.",
        "url": "/javascript-babel"
    }
    ,
    
    "javascript-use-strict": {
        "title": "JavaScript의 strict mode란 무엇인가?",
            "author": "moon9342",
            "category": "",
            "content": "Introductionuse strict는 ES5에서 새롭게 나온 directive입니다. 실제 수행 문장이 아니라 literal expression이기 때문에 이전 버전의 JavaScript에서는 무시됩니다.일반적으로 JavaScript 코드 최 상단에 이 use strict가 위치하는데 이 의미에 대해서 간단하게 정리해 봤습니다. use strict를 써야하는 이유use strict의 목적은 우리의 코드가 strict mode로 실행되게끔 지시하는 것입니다. 여기서 말하는 strict mode란 프로그램 실행 시 예외를 발생시킬 만한 몇가지 특이한 동작을 수행할 수 없도록 엄격한 제한이 걸려있는 실행 context를 지칭합니다. 즉, 일반적으로 동작하는 코드를 use strict를 이용하면 에러가 발생할 수 있다는 말이지요.use strict는 함수별로 따로 지정할 수 있습니다. 즉, 함수내부에 use strict를 선언하면해당 함수는 strict mode로 실행되게 됩니다.몇가지 예를 들어보죠.\"use strict\";x = 100;        // x가 선언되지 않았기 때문에 error 발생console.log(x);x = 3.14;       // strict mode가 아니기 때문에 에러 아님.function myFunction() {    \"use strict\";    y = 3.14;   // y가 선언되지 않았기 때문에 에러 발생}myFunction();\"use strict\";var x = 3.14;delete x;   // strict mode에서는 delete를 사용할 수 없다.   \"use strict\";var public = 1500;   // strict mode에서는 키워드로 변수명을 쓸수 없다.그 외의 예로는 함수의 매개변수의 리스트에서 중복된 부분이 있을 때 오류를 발생시키고 동일한 라이브러리를 중복해서로딩하는 경우 에러를 발생시킵니다. (예를 들면, jQuery library 중복로딩 )결론적으로 잠재적인 오류가 발생할 수 있는 여지를 막아주도록 코드에 대한 문법 사항을 엄걱하게 지키도록 하는directive정도로 인식하시면 될 듯 합니다.  결론은 고민하지 말고 무조건 써야된다!! 입니다. ^^이 포스트의 내용은 w3schools.com을 참조했습니다.조금 더 자세한 사항을 알고 싶으시면 해당 사이트를 방문하세요!!End.",
        "url": "/javascript-use-strict"
    }
    ,
    
    "typescript-destructuring": {
        "title": "TypeScript 강좌(5) - Destructuring",
            "author": "moon9342",
            "category": "",
            "content": "TypeScript 강좌는 여러 절로 구성되어 있습니다.    TypeScript 강좌(1) - Introduction    TypeScript 강좌(2) - Data Type(Part 1)    TypeScript 강좌(3) - Data Type(Part 2)    TypeScript 강좌(4) - 변수 선언    TypeScript 강좌(5) - Destructuring    TypeScript 강좌(6) - Interface    TypeScript 강좌(7) - Class TypeScript Destructuring이번 포스트의 내용은 Destructuring 입니다. Destructuring은 ECMAScript 2015 문법인데 TypeScript에서도 지원합니다.  아래의 예제를 정상적으로 실행해보실려면 tsconfig.json에서 compilerOptions의 target 속성을es6로 해 주셔야 합니다.일반적으로 Destructuring Assignment(비구조할당)라고 하는데 쉽게 말하자면 배열의 요소나 객체의 속성을 배열 literal 혹은 객체 literal과 유사한 형태의 문법을 이용하여변수에 할당하는 기법입니다. 잘 알아두면 코드를 좀 더 쉽게 작성할 수 있습니다. Array Destructuring다음과 같이 배열이 있을 경우 각 배열의 원소값을 가지는 변수를 만들려고 합니다. 아마도 코드는 다음처럼 써야 할 듯 보입니다.let myArr: string[] = [\"Hello\", \"World\", \"Moon\"];let first: string = myArr[0];let second: string = myArr[1];let third: string = myArr[2];console.log(first);     // \"Hello\" 출력console.log(second);    // \"World\" 출력console.log(third);     // \"Moon\" 출력이 코드를 Destructuring Assignment(비구조할당)를 이용하면 다음과 같이 표현할 수 있습니다.let myArr: string[] = [\"Hello\", \"World\", \"Moon\"];let [first, second, third] = myArr;console.log(first);     // \"Hello\" 출력console.log(second);    // \"World\" 출력console.log(third);     // \"Moon\" 출력위의 코드에서 [first, second, third] 형태를 Destructuring Array(비구조배열)이라고 합니다.즉, let [first, second, third] 구문은 변수 선언과 동시에 Destructuring Array(비구조배열)을 생성한 것입니다.만약 Destructuring Array(비구조배열)에 data type을 지정하고 싶은경우는 다음과 같이 하시면 됩니다.let myArr: string[] = [\"Hello\", \"World\", \"Moon\"];let [first, second, third]: string[] = myArr;간단한 응용을 보도록 하죠. 두개의 변수에 대한 swap처리입니다. 기본적으로는 임시변수가 있어야 두 변수의 값을 swap처리할 수 있지만 Destructuring Assignment를 이용하면 보다 간단하게 할 수 있습니다.let myArr: string[] = [\"Hello\", \"World\"];let [first, second] = myArr;console.log(first);     // \"Hello\" 출력console.log(second);    // \"World\" 출력[second, first] = [first, second];   // swap 처리console.log(first);     // \"World\" 출력console.log(second);    // \"Hello\" 출력이런 방식은 함수에 parameter를 전달할 때도 사용할 수 있습니다.function myFunc([x, y]: [number, number]): void {    console.log(`x의 값은 ${x}`);    console.log(`y의 값은 ${y}`);}myFunc([10,20]);나머지 몇몇 응용에 대해서 알아보겟습니다. ...을 이용하면 다음과 같은 형태로 서브배열을생성할 수 있습니다.let myArr: number[] = [1, 2, 3, 4];let [first, ...others] = myArr;console.log(first);    // 1 출력console.log(others);   // [2, 3, 4] 출력 ( 서브배열 )다음과 같은 형태로 Destructuring Array를 이용할 수 있습니다.let myArr: number[] = [1, 2, 3, 4];let [first] = myArr;let [,second, ,fourth] = myArr;console.log(first);     // 1 출력console.log(second);    // 2 출력console.log(fourth);    // 4 출력 Object Destructuring이번에는 객체를 비구조할당을 통해 이용해 보도록 하겠습니다.let obj = {    key1 : \"Hello World\",    key2 : 100,    key3 : \"TypeScript\"};let { key1:a, key2:b } = obj;console.log(a);    // Hello World 출력console.log(b);    // 100 출력새로운 변수 a와 b가 생성되고 obj.key1의 값의 key1:a에 의해서 a 변수에 대입됩니다.마찬가지로 obj.key2의 값이 key2:b에 매칭되서 b 변수에 값이 할당되는 것이구요. obj.key3는 당연히 무시됩니다.변수를 선언할 때 [ ]가 아닌 { }를 이용한다는 것에 주의하셔야 합니다.만약 객체의 Key( 위의 예제에서는 key1, key2, key3 )가 비구조 객체에 쓰이는 변수의 이름과 동일하다면간소화된 형태로 이용할 수 있습니다. 아래의 예처럼 말이죠.let obj = {    key1 : \"Hello World\",    key2 : 100,    key3 : \"TypeScript\"};let { key1, key2 } = obj;console.log(key1);    // Hello World 출력console.log(key2);    // 100 출력그러면 다음과 같이 표현할 수 도 있겠네요.let { a, b } = { a: \"Hello World\", b: 100 };console.log(a);    // Hello World 출력console.log(b);    // 100 출력조금 헷갈리긴 하지만 익숙해지면 할 만 합니다. ^^;아까 위에서 나왔던 ...을 기억하시나요? 배열의 나머지를 가지고 서브배열을 생성할 때 사용했었습니다. Object Destructuring에서도 ...을 이용할 수 있습니다. 아래의 코드를 살펴보도록 하죠.let obj = {    myName: \"홍길동\",    myAddress: \"서울\",    myAge: 30};let { myName, ...otherInfo} = obj;console.log(`이름은 : ${myName}`);console.log(`나이는 : ${otherInfo.myAge}`);객체의 property의 이름을 다른 것으로 바꿀 수 있습니다. 아래의 코드를 보시죠let obj = {    a: \"홍길동\",    b: \"서울\",    c: 30};let { a:myName, b:myAddress } = obj;console.log(`이름은 : ${myName}`);     // 홍길동 출력console.log(`주소는 : ${myAddress}`);  // 서울 출력위의 코드에서 주의해야 할 점은 a:myName, b:myAddress에서 :의 의미가 data type을 지정하는 것으로 사용된 것이 아니라는 것입니다. 만약 데이터 타입을 지정해서 사용하려면 다음과 같이 사용하셔야 합니다.let obj = {    a: \"홍길동\",    b: \"서울\",    c: 30};let { a:myName, b:myAddress }: {a:string, b:string} = obj;console.log(`이름은 : ${myName}`);     // 홍길동 출력console.log(`주소는 : ${myAddress}`);  // 서울 출력점점 복잡해 지는군요. 한가지 주의해야 할 점은 ECMAScript 2015(ES6)에서의 Destructuring과 TypeScript의Destructuring이 완벽하게 똑같지는 않다는 것입니다.이번에 살펴볼 것은 default 값입니다. Destructuring하려는 속성이 존재하지 않을 때를 대비해서 default값을지정할 수 있습니다. 아래의 예를 보시죠.let obj: {myName:string, myAge?:number} = {    myName : \"홍길동\",};let { myName:uNmae, myAge:uAge = 30 } = obj;console.log(uNmae);  // 홍길동console.log(uAge);   // 30위의 예에서 myAge?:number 부분의 ?의 의미는 해당 property가 있을 수도 있고 없을 수도 있다는것을 의미합니다.myAge:uAge = 30 부분이 default value를 사용한 부분입니다. 어디에 쓰면 좋을까요?간단하게 Destructuring이 무엇인지를 살펴보았는데 그럼 도데체 이걸 어디에 써 먹어야 할까요?이런식의 응용이 가능하구나 하는 정도로 가볍게 보시면 될 듯 합니다.첫번째로 생각할 수 있는 응용은 ECMAScript 2015에서 제공되는 Iteration Protocol과의 연계사용입니다.아주 쉽게 생각하면 Map사용에 응용할 수 있다 정도로 보시면 됩니다. Map 자료구조는 key와 value의 쌍으로데이터를 저장하는 구조이고 다음과 같은 형태로 Destructuring과 함께 이용할 수 있습니다.let map = new Map();map.set(\"myName\",\"홍길동\");map.set(\"myAddress\",\"서울\");map.set(\"myAge\",30);for(let [key, value] of map) {    console.log(`${key} 의 값은 ${value} 입니다.`);}for(let [key] of map ) {    // 모든 key 값만을 출력할 수 있습니다.    console.log(`${key}`);}for(let [,value] of map ) {    // 모든 value 값만을 출력할 수 있습니다.    console.log(`${value}`);}두번째는 함수의 리턴값에 응용하는 것입니다. 리턴값이 두개 이상 필요할 때 우리는 배열형태나 객체형태로 리턴을 받게 되는데 Destructuring을 이용하면 편합니다.다음은 배열을 리턴받는 경우입니다.function myFunc(): string[] {    let arr: string[] = [];    // 로직처리 ...    arr[0] = \"첫번째 결과값\";    arr[1] = \"두번째 결과값\";    return arr;}let [result1, result2] = myFunc();console.log(result1);console.log(result2);다음은 객체를 리턴받는 경우입니다.function myFunc(): {result1:string, result2?:number} {    let obj = {        result1 : \"\",        result2 : 0    };    // 로직처리 ...    obj.result1 = \"첫번째 결과값\";    obj.result2 = 100;    return obj;}let {result1:first, result2:second} = myFunc();console.log(first);console.log(second);꼭 사용해야 할 필요는 없지만 알아두면 편하고 좋은 Destructuring에 대해서 알아보았습니다.End.이 포스트의 내용은 아래의 사이트를 참조했습니다. 조금 더 자세한 사항을 알고 싶으시면    해당 사이트를 방문하세요!!    TypeScript Official HomePage",
        "url": "/typescript-destructuring"
    }
    ,
    
    "typescript-variable": {
        "title": "TypeScript 강좌(4) - 변수 선언",
            "author": "moon9342",
            "category": "",
            "content": "TypeScript 강좌는 여러 절로 구성되어 있습니다.    TypeScript 강좌(1) - Introduction    TypeScript 강좌(2) - Data Type(Part 1)    TypeScript 강좌(3) - Data Type(Part 2)    TypeScript 강좌(4) - 변수 선언    TypeScript 강좌(5) - Destructuring    TypeScript 강좌(6) - Interface    TypeScript 강좌(7) - Class TypeScript Variable Declarations이번 포스트에서는 var, let, const에 대해서 알아보겠습니다. let은 var과 유사하지만 var이가지고 있는 우리에게 익숙치 않은 몇가지 사항들을 피하도록 도와줍니다. const는 이름에서 의미하다시피 변수에재할당을 금지하는 목적으로 사용하는 것이구요.결론을 미리 말하자면 TypeScript는 let과 const를 이용합니다.먼저 var에 대해서 알아보고 그 다음에 let, const에 대해서 알아보도록 하겠습니다. var코드로 설명하자면 다음과 같이 변수를 선언할 수 있습니다.var myVar = 100;당연한 말이지만 함수내에서도 선언할 수 있습니다.function myFunc() {    var message = \"Hello World\";    return message}JavaScript는 함수안에 다른 함수를 선언할 수 있습니다. 그러한 경우 내부 함수가 외부 함수가 가지고 있는변수를 참조할 수 있습니다. 또한 JavaScript는 1급 함수(first-class function)를 지원합니다. 쉽게 말하면JavaScript의 함수는 값의 의미로 사용될 수 있다는 것입니다. 함수가 값의 역할을 하다보니 다음과 같은 형태의코드가 가능합니다.  함수를 변수에 저장.  함수를 다른 함수의 인자로 전달.  함수를 다른 함수의 리턴값으로 사용.위와 같은 형태의 함수를 이용할 때는 함수의 이름이 특별히 필요하지 않기 때문에 이런 함수는 특별히 이름을 명시하지 않고 사용합니다.이런 함수를 우리는 익명함수( Anonymous function )라고 하죠. 다른 표현으로는 람다( Lambda )라고도 합니다.( 사실 Lambda에 대한 내용은 조금 더 파고 들어야 합니다. 나중에 다른 포스트에서 정리해볼께요 )위의 내용으로 간단한 예를 들자면 아래와 같습니다.function outerFunc() {    var a = 100;    return function() {        var b = a + 100;        return b;    }}var myFunc = outerFunc();console.log(myFunc());    // 200 출력사실 위의 예제는 좀 이상합니다. 아니 많이 이상하죠.다음과 같은var myFunc = outerFunc();코드에서 outerFunc()함수는 수행이 종료되었기때문에 그 안에 선언된 변수 a는 사실 사용할 수 없어야 합니다. 우리가 익히 알고 있는 다른 프로그래밍 언어의 변수 scope 개념으로 본다면 말이죠.하지만 JavaScript의 var 변수 scope는 좀 다릅니다. outerFunc() 함수의 호출이 끝났음에도 불구하고 a 변수값이 유지됩니다. 즉, outerFunc()에 대한 참조가 남아있는 한 메모리에 계속 유지하게 되는 구조입니다.( outerFunc() 함수가 실행중인 상태로 간주한다는 의미이기도 합니다. ) 그렇기 때문에 위에서 myFunc()를 호출했을 때 a 변수를 이용할 수 있는 것입니다.조금 다른 예제를 살펴보겠습니다.function myFunc(init) {    if (init) {        var x = 10;    }    return x;}console.log(myFunc(true));  // 10 출력위의 코드는 JavaScript 코드입니다. var 변수는 if block 안에서 선언되었음에도 불구하고 block 외부에서도 사용이 가능합니다. 위에서 언급했듯이 JavaScript의 var 변수 scope가 좀 독특해서 그렇습니다. var로 선언된 변수는 block에 상관없이 function 내에서 사용이 가능합니다.  이런 특성을 var은 function-scoping을 가진다 라고 표현합니다.var에 대해서 마지막 하나만 더 살펴보고 정리하겠습니다.다음과 같은 setTimeout을 이용한 코드가 있을 때 실행결과가 어떻게 출력될까요?for (var i = 0; i &lt; 10; i++) {    setTimeout(        function() { console.log(i); },        1000    );}   결과는 다음과 같이 출력됩니다.10101010101010101010JavaScript를 알고 있는 사람들에게는 꽤나 익숙한 코드형태이자 결과일겁니다. setTimeout은 두번째 인자로 들어가는시간을 delay로 첫번째 인자의 함수를 호출해 주는 역할을 하는 함수입니다. (내부 Thread로 동작하겠죠)for문은 순식간에 수행될 것이고 1초뒤에 다음 코드가function() { console.log(i); }10번 호출되게 됩니다. 이 때 i변수는상위 for문의 scope를 참조하게 되므로 실제 console.log(i)가 수행될 때 i값을 참조하면 10이라는 값을 가지고 있을테니화면에 10이 10번 출력되게 됩니다.그러면 0부터 9까지 순차적으로 출력하려면 어떻게 해야 할까요? 이 작업을 수행하기 위해 IIFE을 이용합니다.  IIFE는 Immediately Invoked Function Expression을 의미합니다.코드를 아래와 같이 수정합니다.for (var i = 0; i &lt; 10; i++) {    (function(tmp) {        setTimeout(            function() { console.log(tmp); },            1000        );    })(i);}즉시 실행되는 함수 표현법(IIFE)를 이용하여 새로운 function scope를 생성해서 i값을 capture하는 방식으로 처리하면 될 듯 합니다.이 부분을 정확히 이해하기 위해서는 free variable, scope chain, Closure에 대한 이해가 있어야 합니다. 너무 이야기가산으로 가니 이 부분은 JavaScript 관련 포스트에서 따로 정리해 보도록 하겠습니다. let위에서 언급한 var의 모호성을 let을 이용해 해결할 수 있습니다. 변수를 선언할 때 단순히 var대신 let을 이용하면됩니다.let myVar: string = \"Hello World!!\";let은 우리에게 친숙한 block-scoping을 가집니다. ( lexical-scoping 이라고도 합니다. )function myFunc(input: boolean) {        let a = 100;    if (input) {        let b = a + 1;   // a에 접근이 가능합니다.        return b;    }    return b;            // 코드 에러( b에 접근할 수 없습니다. )}let의 또 다른 특징은 변수의 중복 선언이 안된다는 것입니다. 사실 프로그래밍 언어에서는 거의 당연시 여겨지는 것이지만var는 중복선언이 가능합니다. 다음과 같이 말이죠.function f() {        var x;    var x;          // JavaScript의 var은 같은 변수를 중복선언할 수 있습니다.         if (true) {        var x;    }}자 그럼 아까 var로 선언했을 때 이상하게 동작했던 setTimeout을 이번에는 let을 이용해서처리하면 어떻게 될까요?for (let i = 0; i &lt; 10; i++) {    setTimeout(        function() { console.log(i); },        1000    );}  0123456789var로 선언했을 때와 다른 결과를 볼 수 있습니다.  결론적으로 let은 우리가 익히 알던 (다른 언어의) 변수 특징을 가지는 변수를 선언하기 위한 keyword라고 생각하시면 됩니다. const변수를 선언하기 위한 또 다른 방법은 const를 이용하는 것입니다. 하지만 const로 선언된 변수에는재 할당(re-assign)이 불가능 합니다. 아래의 예처럼 말이죠.const myName: string = \"홍길동\";myName = \"강감찬\";   // 코드 에러const를 사용할 때 한가지만 주의하시면 됩니다. 만약 const 변수가 객체를 지칭하게 되면 다른 객체로 reference를바꾸지는 못하지만 현재 reference하고 있는 객체의 속성에 대해서는 값을 변경할 수 있습니다.아래의 예처럼 말이죠.const count: number = 100;const myProfile = {    myName: \"홍길동\",    myAddress: \"서울\",    myCount: count};myProfile = {                  // 코드 에러 ( re-assign 안됨 )    myName: \"강감찬\",    myAddress: \"인천\",};                   myProfile.myName = \"강감찬\";   // 가능myProfile.myAddress = \"인천\";myProfile.myCount = 10;변수 선언에 대한 keyword에 대해서는 이정도 알아두시면 될 듯 보입니다. 다음 주제는 Destructuring(디스트럭쳐링)입니다.End.이 포스트의 내용은 아래의 사이트를 참조했습니다. 조금 더 자세한 사항을 알고 싶으시면    해당 사이트를 방문하세요!!    TypeScript Official HomePage",
        "url": "/typescript-variable"
    }
    ,
    
    "typescript-datatype-2": {
        "title": "TypeScript 강좌(3) - Data Type(Part 2)",
            "author": "moon9342",
            "category": "",
            "content": "TypeScript 강좌는 여러 절로 구성되어 있습니다.    TypeScript 강좌(1) - Introduction    TypeScript 강좌(2) - Data Type(Part 1)    TypeScript 강좌(3) - Data Type(Part 2)    TypeScript 강좌(4) - 변수 선언    TypeScript 강좌(5) - Destructuring    TypeScript 강좌(6) - Interface    TypeScript 강좌(7) - Class TypeScript Data Type  any  void  null &amp; undefined  never  type assertions이전 포스트에서 기본적인 data type을 알아보았으니 이번에는 조금 더 색다른 data type을 살펴보도록 하겠습니다. anyApplication을 작성하는 시점을 기준으로 할 때 어떤 변수의 data type을 결정할 수 없는 경우가 아주 간혹 있습니다.가장 쉬운 예로 3rd party library를 이용해 dynamic content를 로딩해 저장하는 변수를 생각하시면 됩니다.즉, 동적으로 로딩되는 데이터의 타입이 runtime에 결정되므로 컴파일 타임에 data type을 지정할 수 없는 경우입니다.(하지만 사실 우리는 대부분 데이터 타입을 정해놓고 구현을 진행하긴 합니다. ^^)이런 경우 “어떠한 data type도 될 수 있다”라는 의미로 any data type을 이용할 수 있습니다.data type에 구애받지 않고 쉽게 코드를 작성할 수 있도록 만들어주지만 위에서 언급한 특정 목적을 제외하고는당연히 사용하지 않는것이 좋습니다.아래의 코드를 살펴보죠.let myVar: any = 100;myVar = \"Hello World!!\"; // 가능myVar = true;            // 가능 배열의 data type으로 any를 이용하여 서로 다른 data type으로 배열을 이용하는게 가능해집니다.아래의 코드처럼 말이죠.let myArr: any[] = [100, \"Hello\", true]; void어디서 많이 본 것입니다. 일반적으로 void는 함수가 리턴값이 없을 때 함수의 리턴 type으로 이용합니다. 아래의 코드를 보시죠.function myFunc(name: string) : void {    console.log(`Hello, ${name}!!`);}myFunc(\"Moon\");일반 변수를 만약 void로 선언하면 어떻게 될까요? 변수를 void type으로 선언하면 해당 변수에는 null 혹은 undefined만 assign이 가능합니다. 이렇게 사용할 일이 과연 있을까 싶네요.let myVar: void;myVar = 100;       // 불가능(코드 에러)myVar = \"Hello\";   // 불가능(코드 에러)myVar = null;      // 가능myVar = undefined; // 가능  여기서 주의해야 할 점은 tsconfig.json파일안에 compilerOptions 부분에 \"strictNullChecks\": false option을설정해야 한다는 것입니다. null &amp; undefinedTypeScript에서 null과 undefined는 값이자 하나의 data type입니다. 그렇기 때문에 다음과 같이 사용해야 합니다.let myNull: null = null;let myUndefined: undefined = undefined;하지만 null과 undefined는 다른 모든 type의 subtype입니다. 쉽게 말하면 다른 모든 type에 null과 undefined 값을 assign할 수 있다는 말입니다.여기서 주의해야 할 점은 만약 --strictNullChecks flag를 이용해 .ts파일을 컴파일 할 경우 null과 undefined는 void 혹은자신의 data type에만 assign될 수 있게됩니다.(tsconfig.json파일안에서 \"strictNullChecks\": true로 설정한 경우를 의미 )  tsconfig.json파일안에 compilerOptions 부분에 \"strictNullChecks\": false option 적용한 경우let myName: string = \"홍길동\";let myVoid: void;let myNull: null;let myUndefined: undefined;myName = null;            // 가능myName = undefined;       // 가능myVoid = null;            // 가능myVoid = undefined;       // 가능myNull = null;            // 가능myNull = undefined;       // 가능myUndefined = null;       // 가능myUndefined = undefined;  // 가능  tsconfig.json파일안에 compilerOptions 부분에 \"strictNullChecks\": true option 적용한 경우let myName: string = \"홍길동\";let myVoid: void;let myNull: null;let myUndefined: undefined;myName = null;            // 불가능myName = undefined;       // 불가능myVoid = null;            // 불가능myVoid = undefined;       // 가능myNull = null;            // 가능myNull = undefined;       // 불가능myUndefined = null;       // 불가능myUndefined = undefined;  // 가능 nevernever type은 일반적으로 함수의 리턴 타입으로 사용됩니다. 만약 함수의 리턴 type으로 never가 사용되면 해당함수는 항상 exception을 발생시키던가 혹은 절대 return되지 않는다는 것을 의미합니다. 절대 return되지 않는다는것은 무한 loop에 빠지는 것등을 의미합니다.코드상으로 이해하자면 다음과 같은 경우입니다.function error(message: string): never {    throw new Error(message);}error(\"Something Wrong!!\");function infiniteLoop(): never {    while (true) {            }} Type assertionsType assertions는 컴파일러에게 “이 타입 사용이 맞아!!”라는 의미를 전달하는 것입니다. Type assertions은 type casting과 같은 의미로 사용되지만 실제 특별한 체크작업이나 데이터 재구조화 작업이 발생하지 않습니다.TypeScript는 프로그래머가 특정한 type check를 진행했다고 가정한 후 컴파일을 진행합니다.( TypeScript가 따로 검증하지 않는다는 거죠. )Type assertions을 하는 방법은 2가지가 있습니다. angle-bracket syntax(&lt;&gt;)를 이용하는 방법과 as syntax를이용하는 방법입니다. 아래의 코드를 보죠.let myVar: any = \"Hello World\";let myVarCount: number = (&lt;string&gt;myVar).length;myVarCount = (myVar as string).length;console.log((&lt;number&gt;myVar).toFixed());  // runtime errorany data type과 함께 사용되는 경우가 많으며 데이터 타입을 한정지어서 사용할 수 있도록 도와주는 역할을 합니다.여기까지가 TypeScript의 기본 data type입니다. 다음 포스트는 변수를 선언하기 위한 키워드인 var, let, const에 대해서 알아보도록 하겠습니다.End.이 포스트의 내용은 아래의 사이트를 참조했습니다. 조금 더 자세한 사항을 알고 싶으시면    해당 사이트를 방문하세요!!    TypeScript Official HomePage",
        "url": "/typescript-datatype-2"
    }
    ,
    
    "typescript-datatype-1": {
        "title": "TypeScript 강좌(2) - Data Type(Part 1)",
            "author": "moon9342",
            "category": "",
            "content": "TypeScript 강좌는 여러 절로 구성되어 있습니다.    TypeScript 강좌(1) - Introduction    TypeScript 강좌(2) - Data Type(Part 1)    TypeScript 강좌(3) - Data Type(Part 2)    TypeScript 강좌(4) - 변수 선언    TypeScript 강좌(5) - Destructuring    TypeScript 강좌(6) - Interface    TypeScript 강좌(7) - Class TypeScript Data Type  boolean  number  string  Array  Tuple  enum프로그래밍 언어를 배울 때 가장 먼저 학습하는 부분이 바로 Data Type입니다. 이전에도 언급했듯이TypeScript는 JavaScript의 superset이기 때문에 JavaScript의 data type을 그대로 이용합니다. 거기에추가적인 데이터 타입이 더 존재합니다.그럼 하나하나 예를 들면서 보도록 하죠. boolean우리가 알고있는 boolean type입니다. true와 false keyword를 사용할 수 있습니다.TypeScript에서는 변수선언시 var을 사용하지 않습니다. var는 전통적으로 javascript의 변수를 선언하기 위한 keyword로 사용되고 있지만몇가지 우리를 힘들게 하는 특징이 있습니다. 이부분은 나중에 다시 포스팅하기로 하겠습니다.여하간 TypeScript에서는 var대신 const와 let을 이용합니다. 다음과 같이 boolean type의 변수를 선언할수 있습니다.let myVar: boolean = false;WebStorm에서는 다음그림처럼 확인하시면 편합니다. 왼쪽창에는 .ts파일, 오른쪽 창에는 변환된 .js파일을열어서 .ts가 어떻게 .js로 변환되는지를 확인해보세요.JavaScript에는 생성자 함수라는게 있습니다. 원래 JavaScript는 객체지향언어가 아닙니다. Prototype기반의 함수형 언어입니다.그래서 JavaScript 초기버전에는 class가 도입되지 않았습니다. class는 ECMAScript 2015(ES6)에 도입되었습니다. class가 도입되기 이전에는 함수를 이용해서 객체를 생성하는 생성자 함수라는걸 사용했습니다. 지금도 역시 사용하고 있구요. 우리가 알고있는 new Date(); 이런게 다 생성자 함수를 이용한 객체의 생성입니다.그 중 특수한 생성자 함수들이 있습니다. 바로 primitive type에 대한 생성자 함수들 입니다. 이런것들을 우리는 흔히 Wrapper라고 부릅니다. JavaScript에도 Wrapper Object가 존재합니다. Boolean과 같은 생성자 함수를 이용해서 object를 만들면 우리는 그걸 primitive wrapper object라고 하는거지요.let myVar: boolean = false;let myBooleanVar: Boolean = new Boolean(true);   이제 아래의 코드를 살펴보죠.let myVar: boolean = false;let myBooleanVar: Boolean = new Boolean(true);console.log(myVar.valueOf());console.log(myBooleanVar.valueOf());위와 같은 코드는 좀 이상합니다. myVar는 primitive type임에도 불구하고 method를 호출했습니다.그럼에도 이상없이 실행이 잘 됩니다. 그 이유는 자동형변환이 일어나기 때문입니다. autoboxing이라고 하죠.let myVar: boolean = new Boolean(true);    // 코드 에러console.log(myVar.valueOf());위의 코드는 에러입니다. boolean type의 변수에 Boolean wrapper object를 assign할 수 없다는 오류가 발생합니다.혼용해서 사용하는건 좋지 않습니다. JavaScript할 때야 그냥 막(?) 했지만 TypeScript는 data type을 정확히 명시하는습관을 들이셔야 합니다.  결론적으로 booelan / Boolean 이 존재하는군요. 하나는 primitive data type이고 다른 하나는 primitive wrapper object를만들기 위한 생성자 함수입니다. data type 용도로 사용할 경우는 boolean을 이용하셔야 합니다.(나머지 data type에 대해서도동일합니다. - 권장사항) numberTypeScript는 정수와 실수를 구분하지 않습니다. 모두 다 실수( floating point values )입니다. data type으로는number를 사용합니다. 대응되는 wrapper 생성자 함수는 Number가 되겠네요.기본적인 10진수, 16진수에 더해 ECMAScript 2015에서 2진수, 8진수의 사용도 추가되었습니다.let decimal: number = 6;     let hex: number = 0xf00d;let binary: number = 0b1010;let octal: number = 0o744;console.log(octal.valueOf()); string문자열을 지칭합니다. 기본적으로 double quotes (\") 와 single quotes (') 둘 다 이용할 수 있습니다. 일반적으로는single quotes (')를 이용합니다. 대응되는 wrapper 생성자 함수는 String 입니다.한가지 더 기억해야 할 것이 있는데 template string이라는 걸 사용할 수 있습니다. backquote ( ` ) 를 이용하여여러줄에 걸쳐 문자열을 입력할 수 있고 ${ expr } 형태로 embedded expression을 사용할 수 있습니다.let myStr: string = \"Hello\";let myNumber: number = 100;let myTemplateString = `this isasampleText =&gt; ${ myNumber + 100 }myStr : ${ myStr }`;console.log(myTemplateString);실행결과는 다음과 같습니다.this isasampleText =&gt; 200myStr : Hello ArrayTypeScript는 JavaScript와 마찬가지로 Array를 지원합니다. 배열은 primitive data type이 아닌 객체입니다.배열은 두가지 방식으로 사용할 수 있습니다. 일반적인 방식은 다음과 같습니다.let myArr: string[] = [\"Hello\", \"Hi\", \"안녕하세요\"];console.log(myArr);또 다른 방식은 Array Interface와 generic을 이용하는 방법입니다. 자세한 설명은 다른 포스트에서 진행합니다. 여기서는 어떻게 배열을 선언하고 사용하는지만 보시면 됩니다.let myNumArr: Array&lt;number&gt; = [1, 2, 3, 4];console.log(myNumArr); TupleTuple은 배열입니다. 특수한 형태의 배열로 인식하시면 됩니다. 배열의 각 원소에 대해 각기 다른 data type을 허용합니다.다음과 같은 코드를 가지고 이해해보죠let myTuple: [string, number];myTuple = [\"Hello\", 100]; // 가능myTuple = [\"Hello\", \"World\"]; // 에러위의 코드의 제일 마지막 문장인myTuple = [\"Hello\", \"World\"];코드는 Tuple의 type선언에 맞지 않기때문에 Error가 발생합니다.다음의 코드를 살펴보죠let myTuple: [string, number];myTuple = [\"Hello\", 100]; // 가능console.log(myTuple[0]);  // \"Hello\" 출력console.log(myTuple[1]);  // 100 출력console.log(myTuple[2]);  // undefined 출력위에서 언급했듯이 배열로 사용합니다. 2칸짜리 배열을 만들고 첫번째 칸에는 string, 두번째 칸에는 number를 data type으로가지는 배열입니다.JavaScript의 배열은 크기를 동적으로 늘릴 수 있습니다. 3번째 칸( myTuple[2] )에 데이터를 입력해 보겠습니다.let myTuple: [string, number];myTuple = [\"Hello\", 100]; // 가능myTuple[2] = \"World\"; // 가능myTuple[2] = 200;     // 가능myTuple[2] = true;    // 불가능( 코드 에러 )3번째 칸에 string과 number는 assign이 되는것을 확인할 수 있습니다. 하지만 boolean은 들어가지 않는군요.정리하자면 현재 사용할 수 있는 index를 넘어가는 곳에 데이터를 입력할 때는 Tuple선언에서 사용한 data type의union type을 이용합니다. 쉽게 말하면 string 혹은 number가 되어야 한다는 말입니다. enumenum을 이용할 수 있습니다. C#의 enum과 동일합니다. 숫자 대신 친숙한 이름으로 설정하기 위해서 이용합니다.다음의 코드를 이용해서 살펴보죠enum Color { Red, Green, Blue }let myColor: Color = Color.Red;console.log(myColor);   // 0 출력별다른 설명이 필요없습니다. 이번에는 다음의 코드를 보죠enum Color { Red = 1, Green, Blue = 4 }let myColor: Color = Color.Green;console.log(myColor);   // 2 출력myColor = Color.Blue;console.log(myColor);   // 4 출력Color.Red의 값을 1로 설정하면 그 다음 원소들은 당연히 1부터 1씩 증가합니다. Color.Blue는 4로 명시적으로 지정했네요.아래의 예제는 좀 특이합니다. string 변수에 enum을 대입한 후 결과를 출력합니다.enum Color { Red = 1, Green, Blue }let myColorStr: string = Color.Green;  // 코드 에러( 문자열에 숫자대입 안됨 )let myColor: string = Color[3];        // 가능( 배열로 처리 - index에 주의 )console.log(myColor);                  // \"Blue\" 출력위의 코드에서let myColorStr: string = Color.Green;코드는 에러가 발생합니다. 문자열 type에 숫자를 넣으려 했기 때문이죠.또한 enum은 배열형태로 사용이 가능한 데 이런 경우 해당 문자열을 바로 이용할 수 있습니다.여기까지는 아마 우리가 알고있던 JavaScript와 거의 동일하니 이해하는데 어려움은 없을 듯 보입니다.나머지 data type은 다음 포스트에서 이어가도록 하죠.End.이 포스트의 내용은 아래의 사이트를 참조했습니다. 조금 더 자세한 사항을 알고 싶으시면    해당 사이트를 방문하세요!!    TypeScript Official HomePage",
        "url": "/typescript-datatype-1"
    }
    ,
    
    "typescript-introduction": {
        "title": "TypeScript 강좌(1) - Introduction",
            "author": "moon9342",
            "category": "",
            "content": "TypeScript 강좌는 여러 절로 구성되어 있습니다.    TypeScript 강좌(1) - Introduction    TypeScript 강좌(2) - Data Type(Part 1)    TypeScript 강좌(3) - Data Type(Part 2)    TypeScript 강좌(4) - 변수 선언    TypeScript 강좌(5) - Destructuring    TypeScript 강좌(6) - Interface    TypeScript 강좌(7) - Class TypeScript 개요 및 WebStorm 개발환경 설정TypeScript는 Microsoft에서 개발하여 2012년에 발표한 오픈 소스 프로그래밍 언어입니다. 대규모 JavaScript application 개발을 목적으로 만들어졌습니다.TypeScript의 특징은 다음과 같습니다.  TypeScript는 JavaScript의 Superset입니다. TypeScript는 JavaScript의 모든 기능을 포함하고 그 외 추가적인 기능들을 가지고 있습니다.  TypeScript는 컴파일 언어이지만 컴파일 결과가 machine code가 아닌 JavaScript 코드가 나옵니다.( 이런 프로그래밍을 메타프로그래밍 이라고 하죠. ) 그렇기 때문에 compile 대신에 transpile 이라고도 합니다.  TypeScript는 compile 시점에 type checking이 일어나는 정적 타입 언어입니다. TypeScript 개발환경 설정여기서는 Node.js를 이용하여 npm(Node Package Manager)을 설치하고 이 npm을 이용해 TypeScript를 설치하고 사용하는 방법에 대해서 알아보겠습니다.먼저 Node.js사이트에 접속해 LTS 버전이나 최신버전 둘 중 하나를 선택해다운로드 합니다. (어떤것을 설치해도 상관없습니다.)저는 LTS 버전으로 다운로드 했습니다. 다운로드가 끝나면 기본 형태로 설치를 진행합니다. 설치가 끝나면C:/Program Files/nodejs 폴더가 만들어지게 됩니다.이제 command 창을 열어서 다음과 같이 명령어를 실행해봅니다.  npmnpm(Node Package Manager)이 정상적으로 동작하면 이제 npm을 이용해 typescript를 설치할 수 있습니다.설치는 local mode와 global mode로 설치가 가능합니다. 여기서는 편의상 global mode로 설치합니다.(일반적으로는 local mode를 선호합니다.)command 창에서 다음과 같이 명령어를 이용해 typescript를 global로 설치합니다.  npm install -g typescripttypescript 2.6.2가 설치되었습니다.  global mode로 설치하면 windows 시스템을 기준으로 $USER_HOME/AppData/Roaming/npm/node_modules에 설치됩니다.이제 사용할 IDE(Integrated Development Environment)를 설치합니다. 여기서는 WebStorm(유료)을 이용합니다.Visual Studio Code(무료)를 사용하셔도 됩니다. WebStorm은 유료이지만 30일 trial을 사용할 수 있고 Student license로1년간 무료로 사용할 수 도 있습니다.JetBrains사이트로 접속한 후 WebStorm을 다운로드 받습니다.다운로드가 완료되면 기본형태로 설치합니다. 설치가 끝나면 프로젝트를 생성할 수 있는 화면이 나오게 되는데 폴더 하나를 생성해서 프로젝트를 생성합니다. (폴더명이 프로젝트명이됩니다.) 저는 D:/TypeScriptTestApp 폴더를 생성하면서 프로젝트를 하나 만들었습니다.이제 WebStorm 설정을 해야 합니다.  Files - Settings - Languages &amp; Frameworks - TypeScript 를 선택하면 아래와 같은 화면을 볼 수 있습니다.사실 WebStorm에 TypeScript가 bundle되어 들어있기 때문에 TypeScript를 따로 설치 안해도 됩니다. 하지만 어떻게 설치하는지는 알아둘 필요는 있으니 한번 설치해 본거죠. 그리고 아래의 그림처럼 Compiler 옵션부분을check합니다.컴파일을 할 때 tsconfig.json을 참조해 compile option을 설정한다고 해 놓았습니다. 우리는 아직 tsconfig.json이 없으니 하나 생성해 줍니다. WebStorm의 하단에 있는 Terminal을 클릭해서 Terminal창을 열고 다음을 입력합니다.  tsc --init프로젝트를 살펴보면 tsconfig.json이 생성되어 있는것을 볼 수 있고 안에 무언가가 많이 들어있는것을 확인할 수 있습니다.compiler option에 대해서는 다른 포스트에서 알아보기로 하고 이제 간단한 ts 파일(typescript file)을 하나 생성합니다.이름을 hello.ts라고 하죠.다음과 같은 코드를 입력합니다.class Greeting {    greeting: string;    constructor(message: string) {        this.greeting = message;    }    sayHello() {        return \"Hello \" + this.greeting;    }}let tmp = new Greeting(\"World!!\");console.log(tmp.sayHello());내가 알고있던 javascript가 아니라서 당황스럽지요? 별로 어렵지 않습니다. 객체지향 언어를 알고 있으면더욱 더 쉽게 접근할 수 있습니다. 여하간 이렇게 코딩을 하고 저장하면 자동적으로 컴파일을 진행하고 그 결과파일(.js)을 생성해 줍니다.마지막으로 coding convention을 지정할 수 있는 tslint를 설치하도록 하겠습니다. 반드시 설치해야하는건 아니지만발생할 수 있는 오류를 미리 감지하고 coding convention을 맞추기 위해서 사용하는 것이 일반적입니다.WebStorm에서 다시 터미널을 열고 다음과 같이 입력하여 tslint를 설치합니다. 역시 global mode로 설치합니다.  npm install -g tslint그리고 다시 설정으로 들어갑니다.  Files - Settings - Languages &amp; Frameworks - TypeScript - TSLint 를 선택하면 아래와 같은 화면을 볼 수 있습니다.Enable를 check합니다. tslint.json을 찾아서 Cofiguration file로 이용한다는 군요.tslint.json 파일이 있어야 하니 Terminal을 열어서 다음과 같이 입력해서 tslint.json도 생성해 줍니다.  tslint --init이제 우리가 작성한 hello.ts 파일을 다시 열어보면 여러가지 알수없는(?) 빨간색들이 산재해 있는것을 보실 수 있습니다.에러는 아니지만 tslint에 의해서 coding convention에 위배되는 것들입니다.적절하게 수정해야 합니다. 설정해야 하는 것이들 많이 있지만 연습삼아 한가지만 설정하겠습니다. console에 대한 tslint 오류를 없애보도록 하죠.수정한 tslint.json파일은 다음과 같습니다.{    \"defaultSeverity\": \"error\",    \"extends\": [        \"tslint:recommended\"    ],    \"jsRules\": {},    \"rules\": {        \"no-console\": false    },    \"rulesDirectory\": []}오류를 수정한 최종 hello.ts파일은 다음과 같습니다.class Greeting {    private greeting: string;    constructor(message: string) {        this.greeting = message;    }    public sayHello() {        return \"Hello \" + this.greeting;    }}let tmp = new Greeting(\"World!!\");console.log(tmp.sayHello());여기까지해서 TypeScript를 학습하기 위한 기본적인 환경설정을 잡으시면 됩니다.  tslint는 실 개발시에는 필요하지만 처음 TypeScript를 공부할 때는 끄고 하시는게 정신건강에 이로울 수 있습니다.사실 쓸데없는 coding convention도 많거든요.End.",
        "url": "/typescript-introduction"
    }
    ,
    
    "what-is-metaprogramming": {
        "title": "What is Meta Programming?",
            "author": "moon9342",
            "category": "",
            "content": "Introduction특정 형태의 코드를 작성한 후 컴파일하면 그 코드가 의미하는 다른언어의 코드( Java나 C++ )가 생성되는 프로그래밍을 지칭합니다. 메타프로그래밍 이란?메타프로그래밍( template metaprogramming )이라고 불리는 프로그래밍 기법은 template을 기반으로 compiler에게 다른 언어의 프로그램 코드를 생성하도록 하는 방식을 지칭합니다. 결과물이 machine code가 아닌다른 프로그래밍언어로 전환되는 것이기 때문에 compiler라는 용어대신에 transpiler라는 표현을 쓰기도 합니다. 장점과 단점이런 Meta Programming은 다음과 같은 장점과 단점을 가지고 있습니다.Advantage  컴파일 타임에 최적화가 이루어지고 결과적으로 실행 시 수행속도가 빨라질 수 있습니다.  일반화 프로그래밍( Generic Programming )이 가능합니다. 프로그래머는 처리할 구조와 데이터에 집중하고 컴파일러에 의해 특정 언어로 변환이 되는 구조이기 때문입니다.  결과로 도출되는 언어가 갖지 못하는 여러가지 개념들을 template에 정의해서 작성하고 이를결과언어로 적절하게 표현하여 기능상의 확장을 손쉽게 가져올 수 있습니다.Disadvantage  일반적으로 Template Metaprogramming은 또 다른 형식으로 프로그래밍 하기 때문에코드 자체가 더 난해합니다. 즉, Readability에 문제가 있습니다.  compiler에 의해서 새로운 코드가 생성되는 구조이기 때문에 compiler에 대한 의존도가 상당히 높습니다. 따라서 이식성의 문제가 발생할 여지를 가지고 있습니다.End.",
        "url": "/what-is-metaprogramming"
    }
    ,
    
    "what-is-yaml": {
        "title": "What is YAML?",
            "author": "moon9342",
            "category": "",
            "content": "IntroductionYAML은 JSON이나 XML처럼 데이터를 표현하는 하나의 양식입니다. 처음에는 좀 다른 의미였지만 현재는데이터를 표현하는 목적으로 사용됩니다. YAML 이란?YAML은 데이터를 사람이 쉽게 읽을 수 있는 형태로 표현하는데 사용되는 데이터 직렬화 양식입니다.데이터 직렬화(Data Serialization)란 구조화된 데이터를 특정 format으로 변환하는 개념입니다.단, 변환된 format은 본래 구조화된 데이터로 복구될 수 있어야 하고 변환된 format 형태로 공유 혹은 저장되는 것을 허용해야 합니다.YAML과 마찬가지로 우리가 자주 사용하는 XML이나 JSON 역시 데이터 직렬화 양식입니다.YAML 이라는 이름은 원래 Yet Another Markup Language(또 다른 마크업 언어)의 약어였으나 YAML의 실제 사용이마크업이 아닌 데이터 중심으로 사용되기 시작하자 YAML Ain’t Markup Language(YAML은 마크업 언어가 아니다)라는재귀적인 이름으로 변경되었습니다.우리나라 말로는 야믈 이라고 발음합니다.일반적으로 Ruby나 Python 개발자는 property파일로 많이 이용하고 있지만 C#이나 Java 개발자에게는 좀 생소합니다.Spring Boot도 현재 YAML을 지원하고 있습니다.일단 YAML은 property 형태로 어떻게 사용된다라는 식으로만 알고 있어도 충분할 듯 싶습니다. 혹시 나중에 YAML을본격적으로 사용하게 되는 날이 오면 그 때 조금 더 자세히 알아보도록 하겠습니다.(그런데 사실.. 그런날은 올거 같지 않습니다.)End.",
        "url": "/what_is_yaml"
    }
    ,
    
    "kramdown-image-resize": {
        "title": "GitHub Page에서 Image Resize 방법",
            "author": "moon9342",
            "category": "",
            "content": "Introductionkramdown에서 image를 표현할 때 resize하는 방법입니다.기본 markdown에서 이미지를 사용하는 방법은 다음과 같습니다.![이미지 텍스트](https://github.com/favicon.ico)GitHub Page는 현재 markdown engine으로 kramdown을 사용할 수 있습니다. kramdown에서는다음의 문법으로 이미지를 원하는 사이즈로 resizing 할 수 있습니다.![이미지 텍스트](https://github.com/favicon.ico){: height='100px' width='100px'}조금 더 일반화 시켜서 말하자면{: height='100px' width='100px'}부분은 tag로 변환될 때 특정 속성을 붙이는 역할을 합니다.{: class='myStyle' }만약 위와 같다면 만들어지는 tag에class='myStyle'class 속성이 붙게됩니다.End.",
        "url": "/kramdown-image-resize"
    }
    ,
    
    "javascript-history": {
        "title": "JavaScript History",
            "author": "moon9342",
            "category": "",
            "content": "Introduction아마도 JavaScript, ECMAScript, TypeScript라는 용어를 많이 들어봤을 텐데 정확하게 어떤 차이가 있는지이번 포스트에서 간단하게 정리를 해 보겠습니다. JavaScript과거부터 Web 작업을 해 오신 분들은 아시겠지만 JavaScript의 과거 인식은 “알면 좋고 몰라도 상관없는 딱 그 수준의 언어” 였습니다. 하지만 개발 방법론이 진화하면서 JavaScript기반의 Library나 Framework의 필요성이 증대되고 그에 따라JavaScript라는 언어의 위상도 상당히 올라갔습니다. ( HTML5와 Node.js의 역할이 지대했지요. )JavaScript라는 언어의 전신은 1995년 Netscape사에서 Brendan Eich가 Mocha라는 이름으로 만들어낸 스크립트 언어입니다. 개발을 완료하고 후에 LiveScript라는 이름으로 세상에 공개되었습니다. 그런데 이 시점에 Netscape사가 Java를 개발한 Sun Microsystems사와 협업하면서 Java applet이 큰 인기를 끌게 되었는데 이를 상업적으로 이용하고자 이름을 LiveScript에서 JavaScript로 변경하게 된 것입니다.  이름의 변경 순서가 Mocha  LiveScript  JavaScript 가 되는군요.MS(Microsoft)에서는 이에 대응하기 위해 JScript를 만들고 IE 3부터 JScript를 포함시켜서 제공했지요. 당연한 말이지만JavaScript와 JScript는 서로 비슷하지만 특징이 다릅니다. 그로인해 우리가 잘 알고있는 JavaScript의 고질적인 문제인 Fragmentation(파편화 현상)이 발생하게 됩니다. ECMAScript여하간 Netscape사는 이 JavaScript의 표준을 잡기 위해 ECMA(정보 통신기술 표준화 기구)에 표준화 작업을 요청합니다. 당연히JavaScript라는 이름을 사용하려고 했지만 Sun과의 라이선스 문제 때문에 ECMAScript라는 이름으로 표준화가 진행되게 됩니다.이렇게만 놓고 보면 JavaScript와 ECMAScript가 비슷한 의미로 사용되는 것처럼 보이는데 사실 작은 차이가 있습니다.우리가 흔희 말하는 JavaScript는 1개의 Core와 2개의 Module로 구성되어 있습니다. 여기서 1개의 Core는 JavaScript를 구성하고 있는 Script language(ECMAScript)입니다. 2개의 Module은 BOM(Browser Object Model), DOM(Document Object Model)을 지칭합니다.달리 말하자면 ECMAScript는 JavaScript를 구성하는 Core Script언어로 웹 환경에서만 사용되는 언어가 아닙니다. 웹 환경은 ECMAScript가 사용되는 환경 중 하나일 뿐입니다.  JavaScript = ECMAScript + BOM + DOM현재 ECMAScript version은 7까지 나와있습니다. (ECMAScript 2016 = ES7)이렇듯 JavaScript와 ECMAScript는 정확한 의미의 차이는 분명히 있지만 그냥 저냥 대충 통용해서 사용합니다. 흔히 우리가JavaScript라고 표현하면 ECMAScript를 의미한다고 보시면 됩니다. TypeScript그러면 TypeScript는 또 어떤걸까요? 왜 TypeScript가 대세로 떠오른 걸까요?TypeScript는 Microsoft에서 개발하여 2012년에 발표한 오픈 소스 프로그래밍 언어입니다. JavaScript로 대규모 application개발을 하기 위해 개발되었고 컴파일 과정을 거치면 JavaScript가 되는 언어입니다.CoffeeScript 처럼 compile하면 JavaScript가 생성되는 변환 언어의 한 종류라 볼 수 있습니다. 그냥 JavaScript로 개발하면 되지 굳이 이런 변환언어를 사용하는 이유는 무엇일까요? ( 이런 프로그래밍을 메타프로그래밍 이라고 합니다. )가장 큰 이유는 기능의 추가에 있습니다.변환언어의 가장 큰 장점은 변환되는 언어에 기능을 쉽게 추가할 수 있다는 것인데 예를 들면, 추상 클래스, 인터페이스, 정적 데이터타입 사용, 엄격한 타입 체크등을 JavaScript에 추가하여 개발을 쉽게 끌고 갈 수 있습니다.즉, 전통적인 OOP방식으로 JavaScript개발을 진행할 수 있다는 것이죠.  기존 객체지향 언어(Java, C++, C#)를 알고 있고 JavaScript를 알고 있으면 TypeScript를 아주 쉽게배울 수 있습니다.TypeScript는 다른 변환언어와는 다르게 JavaScript의 superset입니다. 그렇기 때문에 이미 JavaScript를 알고 있으면쉽게 TypeScript를 사용할 수 있으며 ES6(ECMAScript 2015)나 ES7(ECMAScript 2016)에서 제공되는 기능 중 필요한 것만 골라서 이용할 수 있습니다. 아래의 그림은 TypeScript와 ECMAScript간의 포함관계를 보여줍니다.( 이미지 출처 : https://angular2buch.de )2017년 3월부로 TypeScript는 Google의 공식언어 중 하나로 채택되었습니다. MS에서 개발한 언어를 Google이표준언어로 채택하다니 놀랍습니다. 그만큼 TypeScript의 언어적 기능이 좋고 앞으로의 발전가능성이 많다는 의미겠지요.기존 Google의 사내 표준언어 (Canonical Language)는 C, C++, Java, JavaScript, Python, Go 정도였는데 Google은 이 중 JavaScript를 이용하여 AngularJS(1.x)를 개발했었습니다.하지만 AngualrJS(1.x)의 차기버전인 Angular(2.x)를 개발하면서 JavaScript의 기능상의 한계를 느끼게 되고결국 2014년에 Google에서 발표한 AtScript를 이용해 Angular(2.x)를 개발하게 됩니다.하지만 TypeScript가 Angular의 표준언어 중 하나로 채택이 되면서 기존의 AtScript로 작성했던 Angular 2를 몽땅 TypeScript로 전환했습니다. Google에서 말하기로는 변환이 아주 쉬웠다고 하더군요.이렇게 TypeScript의 위상이 올라가면서 기존 Google에서 JavaScript의 대체 언어로 밀고있었던 Dart의 위상 역시 살짝 하락한 상태입니다. (물론 Google은 아니라고 하지만요. )  Angular는 공식적으로 3개의 언어를 지원합니다. (TypeScript, JavaScript, Dart)   그런데 공식문서에서나 커뮤니티활동에서 가장 많이 사용되는것은 TypeScript입니다. 결국 Angular는 꼭 해야할 것 중 하나이니 TypeScript도 그냥 해야지요..머..End.",
        "url": "/javascript-history"
    }
    
    
    };

</script>
<script src="assets/js/lunr.js"></script>
<script src="assets/js/search.js"></script>
            </section>

        </article>

    </div>
</main>

<!-- /post -->

<!-- The #contentFor helper here will send everything inside it up to the matching #block helper found in default.hbs -->
<script>
$(function() {
    var $postContent = $(".post-full-content");
    $postContent.fitVids();
});
</script>



        <!-- Previous/next page links - displayed on every page -->
        

        <!-- The footer at the very bottom of the screen -->
        <footer class="site-footer outer">
            <div class="site-footer-content inner">
                <section class="copyright"><a href="http://localhost:4000/">IT Technical Training</a> &copy; 2021</section>
                <section class="poweredby">Proudly published with <a href="https://jekyllrb.com/">Jekyll</a> &
                    <a href="https://pages.github.com/">GitHub Pages</a></section>
                <nav class="site-footer-nav">
                    <a href="mailto:moon9342@gmail.com">moon9342@gmail.com</a>
                    <a href="/">Latest Posts</a>
                    
                    
                </nav>
            </div>
        </footer>

    </div>

    <!-- The big email subscribe modal content -->
    
        <div id="subscribe" class="subscribe-overlay">
            <a class="subscribe-overlay-close" href="#"></a>
            <div class="subscribe-overlay-content">
                
                <h1 class="subscribe-overlay-title">Search IT Technical Training</h1>
                <p class="subscribe-overlay-description">lunr.js를 이용한 posts 검색 </p>
                <span id="searchform" method="post" action="/subscribe/" class="">
    <input class="confirm" type="hidden" name="confirm"  /><input class="location" type="hidden" name="location"  /><input class="referrer" type="hidden" name="referrer"  />

    <div class="form-group">
        <input class="subscribe-email" onkeyup="myFunc()" id="searchtext" type="text" name="searchtext"  placeholder="Search..." />
    </div>
    <!--<button class="" onclick="myFunc()" id="searchBtn" type="button" ><span>Search</span></button>-->
    <script type="text/javascript">
        function myFunc() {
            if(event.keyCode == 13) {
                var url = encodeURIComponent($("#searchtext").val());
                location.href = "/search.html?query=" + url;
            }
        }
    </script>
    <!--<script type="text/et-cetera">(function(g,h,o,s,t){h[o]('.location')[s]=h[o]('.location')[s] || g.location.href;h[o]('.referrer')[s]=h[o]('.referrer')[s] || h.referrer;})(window,document,'querySelector','value');</script>-->
</span>


            </div>
        </div>
    

    <!-- highlight.js -->
    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>

    <script type="text/javascript" src="/assets/js/jquery.fitvids.js"></script>


    <!-- Paginator increased to "infinit" in _config.yml -->
    <!-- if paginator.posts  -->
    <!-- <script>
        var maxPages = parseInt('');
    </script>
    <script src="/assets/js/infinitescroll.js"></script> -->
    <!-- /endif -->

    


    <!-- Add Google Analytics  -->
    <!-- Google Analytics Tracking code -->
 <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-113135179-1', 'auto');
  ga('send', 'pageview');

 </script>


    <!-- The #block helper will pull in data from the #contentFor other template files. In this case, there's some JavaScript which we only want to use in post.hbs, but it needs to be included down here, after jQuery has already loaded. -->
    
        <script>
$(function() {
    var $postContent = $(".post-full-content");
    $postContent.fitVids();
});
</script>

    

    <!-- Ghost outputs important scripts and data with this tag - it should always be the very last thing before the closing body tag -->
    <!-- ghost_foot -->

</body>
</html>
